<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>John Hanacek - Portfolio</title>
    <meta name="description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems. LLMs, XR, robotics.">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="./Assets/favicon-jhsigfrmpaper.png">

    <!-- Open Graph / Social Share -->
    <meta property="og:title" content="John Hanacek - Portfolio">
    <meta property="og:description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems.">
    <meta property="og:image" content="https://www.johnhanacek.com/Assets/socialgraph-jhcom.png">
    <meta property="og:url" content="https://www.johnhanacek.com/">
    <meta property="og:type" content="website">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="John Hanacek - Portfolio">
    <meta name="twitter:description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems.">
    <meta name="twitter:image" content="https://www.johnhanacek.com/Assets/socialgraph-jhcom.png">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Raleway:wght@100;200;300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles/shared.css">

    <!-- Structured Data for AI/Search -->
    <link rel="alternate" type="application/json" href="./john-hanacek.json" title="Structured data">
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "ProfilePage",
        "mainEntity": {
            "@type": "Person",
            "name": "John Hanacek",
            "url": "https://www.johnhanacek.com",
            "image": "https://www.johnhanacek.com/Assets/socialgraph-jhcom.png",
            "jobTitle": ["Founding Designer", "Design Engineer", "Product Designer"],
            "description": "Founding Designer & Design Engineer building at the intersection of AI, spatial computing, and human-computer symbiosis.",
            "email": "hi@johnhanacek.com",
            "sameAs": [
                "https://www.linkedin.com/in/johnhanacek/",
                "https://bsky.app/profile/johnhanacek.bsky.social",
                "https://x.com/johnhanacek"
            ],
            "knowsAbout": ["AI-native product design", "Agentic systems", "LLM integration", "XR/Spatial interface design", "Design engineering", "MetaMedium", "Robotics"],
            "worksFor": {
                "@type": "Organization",
                "name": "JH Design LLC"
            }
        }
    }
    </script>

    <style>
        /* Override hero-hint to be vertically centered (like art page) */
        .hero-hint {
            bottom: auto;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        /* Debug toggle for fish minigame */
        .canvas-controls {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 1rem;
            z-index: 100;
            opacity: 0.6;
            transition: opacity 0.2s ease;
        }
        .canvas-controls:hover {
            opacity: 1;
        }
        .canvas-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(125, 216, 247, 0.5);
            cursor: pointer;
        }
        .canvas-toggle input {
            display: none;
        }
        .toggle-switch {
            width: 28px;
            height: 14px;
            background: rgba(10, 22, 40, 0.6);
            border: 1px solid rgba(77, 201, 246, 0.2);
            border-radius: 7px;
            position: relative;
            transition: all 0.2s ease;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 8px;
            height: 8px;
            background: rgba(125, 216, 247, 0.4);
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        .canvas-toggle input:checked + .toggle-switch {
            background: rgba(77, 201, 246, 0.15);
            border-color: rgba(77, 201, 246, 0.4);
        }
        .canvas-toggle input:checked + .toggle-switch::after {
            left: 16px;
            background: rgba(125, 216, 247, 0.9);
            box-shadow: 0 0 6px rgba(77, 201, 246, 0.5);
        }
        .canvas-toggle:hover {
            color: rgba(125, 216, 247, 0.7);
        }
    </style>
</head>
<body>
    <!-- Interactive Cursor Spotlight -->
    <div id="cursorSpotlight"></div>

    <a href="#about" class="skip-link">Skip to main content</a>

    <nav id="nav" role="navigation" aria-label="Main navigation">
        <div class="nav-inner">
            <div class="nav-left">
                <a href="index.html" class="shape-link active" aria-label="Home" aria-current="page">
                    <svg class="shape triangle" viewBox="0 0 40 40"><polygon points="20,8 34,32 6,32"/></svg>
                    <img class="shape-label shape-label-img" src="./Assets/footer-JHsig.png" alt="JH">
                </a>
                <a href="design.html" class="shape-link" aria-label="Design">
                    <svg class="shape rounded-square" viewBox="0 0 40 40"><rect x="6" y="6" width="28" height="28" rx="6"/></svg>
                    <span class="shape-label">DESIGN</span>
                </a>
                <a href="art.html" class="shape-link" aria-label="Art">
                    <svg class="shape circle" viewBox="0 0 40 40"><circle cx="20" cy="20" r="14"/></svg>
                    <span class="shape-label">ART</span>
                </a>
                <a href="index.html" class="nav-title">John Hanacek</a>
                <a href="about.html" class="shape-link secondary" aria-label="About">
                    <svg class="shape diamond" viewBox="0 0 40 40"><polygon points="20,6 34,20 20,34 6,20"/></svg>
                    <span class="shape-label">ABOUT</span>
                </a>
                <a href="services.html" class="shape-link secondary" aria-label="Services">
                    <svg class="shape star" viewBox="0 0 40 40"><polygon points="20,6 23,16 34,16 25,22 28,34 20,26 12,34 15,22 6,16 17,16"/></svg>
                    <span class="shape-label">SERVICES</span>
                </a>
            </div>
            <button class="nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-right">
                <li><a href="#about">About</a></li>
                <li><a href="#believe">I Believe</a></li>
                <li><a href="#highlights">Highlights</a></li>
                <li><a href="#endorsements">Endorsements</a></li>
                <li><a href="#explore">Explore</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </div>
    </nav>

    <header class="hero" id="top">
        <!-- Interactive Canvas -->
        <canvas id="heroCanvas"></canvas>

        <!-- Shape nav: direct child of hero, matches design/art positioning -->
        <nav class="shape-nav" aria-label="Page navigation">
            <a href="index.html" class="shape-link active" aria-label="Home" aria-current="page">
                <svg class="shape triangle" viewBox="0 0 40 40"><polygon points="20,8 34,32 6,32"/></svg>
                <img class="shape-label shape-label-img" src="./Assets/footer-JHsig.png" alt="JH">
            </a>
            <a href="design.html" class="shape-link" aria-label="Design">
                <svg class="shape rounded-square" viewBox="0 0 40 40"><rect x="6" y="6" width="28" height="28" rx="6"/></svg>
                <span class="shape-label">DESIGN</span>
            </a>
            <a href="art.html" class="shape-link" aria-label="Art">
                <svg class="shape circle" viewBox="0 0 40 40"><circle cx="20" cy="20" r="14"/></svg>
                <span class="shape-label">ART</span>
            </a>
        </nav>

        <!-- Hero Oval: unified glass identity container -->
        <div class="hero-oval" role="banner">
            <!-- Identity content -->
            <div class="hero-content">
                <img class="hero-sig-inline" src="./Assets/footer-JHsig.png" alt="John Hanacek signature">
                <h1>John <span class="meta">Hanacek</span></h1>
                <p class="tagline">DESIGN ENGINEER · PRODUCT DESIGNER · ARTIST</p>
                <p class="byline"><span class="role">Sounds like · (Hana-check)</span></p>
            </div>

            <!-- Goto content: below sig, inside oval -->
            <a href="#about" class="oval-scroll-btn" aria-label="Scroll to content">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M7 13l5 5 5-5M7 6l5 5 5-5"/>
                </svg>
                <span class="oval-scroll-label">view content</span>
            </a>
        </div>

        <!-- Draw hint — on canvas, fades after 5 interactions -->
        <div class="hero-hint" id="heroDrawHint" aria-hidden="true">
            <span class="hint-icon">✎</span>
            <span class="hint-text">draw a fish · drop food · blow bubbles</span>
        </div>

        <!-- Debug Controls — fixed bottom-left, off by default -->
        <div class="canvas-controls">
            <label class="canvas-toggle">
                <input type="checkbox" id="toggleDebug">
                <span class="toggle-switch"></span>
                Debug
            </label>
        </div>
    </header>

    <main>
        <!-- ABOUT -->
        <section id="about">
            <h2>About</h2>

            <div class="content-card about">
                <p><strong>Founding Designer </strong>& <strong>Design Engineer</strong> building at the intersection of AI, spatial computing, and human-computer symbiosis.</p>
                <p>I design and develop <strong>agentic systems</strong>, XR interfaces, and AI-augmented tools. Currently exploring <strong>MetaMedium</strong> concepts, dynamic design systems that blur the line between tool and medium, and self improving automated agentic research systems.</p>
            </div>
        </section>

        <!-- I BELIEVE -->
        <section id="believe">
            <h2>I Believe</h2>

            <div class="content-card">
                <p>Imagination is within reality.</p>
                <p>Infinite Games are more powerful than Finite Games.</p>
                <p>Technology can augment human intelligence & collaboration.</p>
                <p>Optimism and pessimism are self-fulfilling prophecies.</p>
                <p>We can choose better prophecies...</p>
            </div>
        </section>

        <!-- HIGHLIGHTS -->
        <section id="highlights">
            <h2>Highlights</h2>

            <div class="card-grid cols-3">
                <div class="content-card" data-num="01">
                    <h4>Georgetown MA 2016</h4>
                    <p>Awarded <strong>"Most Meta"</strong> by peers in Communication, Culture & Technology</p>
                </div>

                <div class="content-card" data-num="02">
                    <h4>Founder Institute 2020</h4>
                    <p>Graduate as CEO of <strong><a href="https://www.avatarmedic.com" target="_blank" rel="noopener">AvatarMEDIC</a></strong></p>
                </div>

                <div class="content-card" data-num="03">
                    <h4>Aerospace Medical Association 2022</h4>
                    <p><strong>R&D Innovation Award</strong> for XR Digital Twin robotics control</p>
                </div>
            </div>
        </section>



        <!-- ENDORSEMENTS -->
        <section id="endorsements">
            <h2>Featured Endorsements</h2>

            <div class="grid-2">
                <div class="content-card endorsement">
                    <p>"My choice for the most plausible vision of a future I desire goes to John Hanacek's scenario. I think I'd like to live there, and I think it is plausible in 100 years. My $100 goes to him."</p>
                    <cite><strong><a href="https://kk.org/thetechnium/a-desirable-future-haiku/" target="_blank" rel="noopener">Kevin Kelly</a></strong>, Futurist, Founder of Wired Magazine</cite>
                </div>

                <div class="content-card endorsement short">
                    <p>"Talented and very experienced designer!"</p>
                    <cite><strong><a href="https://www.linkedin.com/in/ipetryaevskaya/" target="_blank" rel="noopener">Inga Petryaevskaya</a></strong>, CEO <a href="https://www.shapesxr.com" target="_blank" rel="noopener">ShapesXR</a></cite>
                </div>

                <div class="content-card endorsement span-full">
                    <p>"He's not only a true Visionary, but also an amazing listener with incredible intuition. I've never seen anyone able to so readily understand scientists, then design an experience they can scarcely imagine, but recognize as what they wanted."</p>
                    <cite><strong>Sheila Zipfel</strong>, Product Manager, Nanome</cite>
                </div>
            </div>
        </section>

        <!-- EXPLORE & CONTACT - side by side on widescreen -->
        <div class="widescreen-split">
            <section id="explore">
                <h2>Explore</h2>

                <div class="content-card">
                    <h4><a href="design.html">Design Portfolio</a></h4>
                    <p>Professional work, case studies, and XR projects</p>
                </div>

                <div class="content-card">
                    <h4><a href="art.html">Art & Creative</a></h4>
                    <p>Visual art, photography, and creative experiments</p>
                </div>

                <div class="content-card">
                    <h4><a href="about.html">About & Experience</a></h4>
                    <p>Full bio, work history, and expertise</p>
                </div>

                <div class="content-card">
                    <h4><a href="services.html">Services & Consulting</a></h4>
                    <p>Founding designer, design engineering, and AI product services</p>
                </div>
            </section>

            <section id="contact">
                <h2>Contact</h2>

                <div class="content-card">
                    <h4>Email</h4>
                    <p><a href="mailto:hi@johnhanacek.com">hi@johnhanacek.com</a></p>

                    <h4>Writing</h4>
                    <ul>
                        <li><a href="https://spatialandimmersivedesign.substack.com/" target="_blank" rel="noopener">Spatial & Immersive Design Blog</a></li>
                        <li><a href="https://johnhanacek.substack.com" target="_blank" rel="noopener">Personal Blog (Tech, Strategy & Research)</a></li>
                    </ul>

                    <h4>Social</h4>
                    <ul>
                        <li><a href="https://bsky.app/profile/johnhanacek.bsky.social" target="_blank" rel="noopener">Bluesky</a></li>
                        <li><a href="https://x.com/johnhanacek" target="_blank" rel="noopener">X (Twitter)</a></li>
                        <li><a href="https://www.linkedin.com/in/johnhanacek/" target="_blank" rel="noopener">LinkedIn</a></li>
                    </ul>
                </div>
            </section>
        </div>

    </main>

    <footer>
        <div class="footer-oval">
            <p class="footer-signature"><img src="./Assets/footer-JHsig.png" alt="John Hanacek signature" loading="lazy"></p>
            <p class="footer-copyright">© 2026 John Hanacek · JHDesign LLC</p>
            <p class="version">Portfolio v1.2 · Feb 2026<br>Made with Claude Code &amp; Open Code</p>
        </div>
    </footer>

    <script>
        // Navigation scroll visibility - show after scrolling past hero
        const nav = document.getElementById('nav');
        const hero = document.querySelector('.hero');

        function updateNavVisibility() {
            const heroBottom = hero.offsetTop + hero.offsetHeight - 60;
            if (window.scrollY > heroBottom) {
                nav.classList.add('visible');
            } else {
                nav.classList.remove('visible');
            }
        }

        window.addEventListener('scroll', updateNavVisibility);
        window.addEventListener('resize', updateNavVisibility);
        updateNavVisibility();

        // Mobile navigation toggle
        const navToggle = document.querySelector('.nav-toggle');
        const navMenu = document.querySelector('nav ul');

        navToggle.addEventListener('click', function() {
            const isExpanded = this.getAttribute('aria-expanded') === 'true';
            this.setAttribute('aria-expanded', !isExpanded);
            this.classList.toggle('active');
            navMenu.classList.toggle('open');
        });

        // Close menu when clicking a link
        navMenu.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', () => {
                navToggle.setAttribute('aria-expanded', 'false');
                navToggle.classList.remove('active');
                navMenu.classList.remove('open');
            });
        });
    </script>

    <!-- Hero Canvas Drawing Interaction -->
    <script>
        const canvas = document.getElementById('heroCanvas');
        const ctx = canvas.getContext('2d');
        
        // ============================================
        // Unified Timing Constants (in ms)
        // ============================================
        const TIMING = {
            strokeHold: 1500,       // Time before stroke starts fading
            strokeFade: 2000,       // Fade duration for strokes
        };
        TIMING.strokeTotal = TIMING.strokeHold + TIMING.strokeFade;
        
        let isDrawing = false;
        let strokes = [];           // Raw strokes (fade out)
        let currentStroke = null;
        let ripples = [];           // Tap ripple effects
        let particles = [];         // Recognition particle bursts
        let ambientParticles = [];  // Floating ambient particles

        // ============================================
        // Entity State (Fish Minigame)
        // ============================================
        let jellyfish = [];
        let fish = [];
        let coral = [];
        let bubbles = [];
        let food = [];
        let tempLines = [];
        let entityIdCounter = 0;

        const MAX_JELLYFISH = 2;
        const MAX_FISH = 18;  // Total cap (3+6+9)
        const MAX_LARGE_FISH = 2;  // Max 2 large fish at a time
        const MAX_MEDIUM_FISH = 6; // Larger school
        const MAX_SMALL_FISH = 9;  // More small fish
        const MAX_CORAL = 6;
        const MAX_BUBBLES = 20;
        const MAX_FOOD = 12;
        const FOOD_LIFETIME = 15000;
        const LINE_DURATION = 1500;

        // Debug mode - toggle with UI
        let debugMode = false;

        const aquaColors = {
            jellyfish: ['#c77dff', '#a78bfa', '#e879f9'],
            fish: ['#00d9ff', '#4dc9f6', '#38bdf8'],
            coral: ['#ff6ec7', '#f472b6', '#fb7185'],
            bubble: 'rgba(77, 201, 246, 0.3)',
            food: '#7ae582',
            line: 'rgba(77, 201, 246, 0.5)'
        };

        // Deep Sea Terminal color palette
        const colors = {
            bg: '#020a12',
            stroke: 'rgba(77, 201, 246, 0.85)',
            cursor: 'rgba(212, 175, 55, 0.85)',
            glow: 'rgba(77, 201, 246, 0.4)',
        };

        // ============================================
        // Helper Functions
        // ============================================
        function getBounds(points) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            points.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            return { minX, minY, maxX, maxY };
        }

        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        // Shortest angular difference (returns value in [-PI, PI])
        function angleDiff(target, current) {
            let d = target - current;
            while (d > Math.PI) d -= Math.PI * 2;
            while (d < -Math.PI) d += Math.PI * 2;
            return d;
        }

        // Check if food position is inside any bubble (hidden from fish)
        function isFoodInBubble(fx, fy) {
            for (let i = 0; i < bubbles.length; i++) {
                const b = bubbles[i];
                const dx = fx - b.x;
                const dy = fy - b.y;
                if (dx * dx + dy * dy < b.radius * b.radius) return true;
            }
            return false;
        }

        // Check if line segment intersects a circle
        function segmentIntersectsCircle(p1, p2, cx, cy, r) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const fx = p1.x - cx;
            const fy = p1.y - cy;
            const a = dx * dx + dy * dy;
            const b2 = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - r * r;
            let disc = b2 * b2 - 4 * a * c;
            if (disc < 0) return false;
            disc = Math.sqrt(disc);
            const t1 = (-b2 - disc) / (2 * a);
            const t2 = (-b2 + disc) / (2 * a);
            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
        }

        function getCircleScore(points, center, radius) {
            let totalError = 0;
            points.forEach(p => {
                const dist = distance(p, center);
                totalError += Math.abs(dist - radius) / radius;
            });
            return Math.max(0, 1 - (totalError / points.length));
        }

        // Exact scoring functions from design.html
        function getRectScore(points, bounds) {
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            let cornerCount = 0;
            const corners = [
                { x: bounds.minX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.maxY },
                { x: bounds.minX, y: bounds.maxY }
            ];
            const threshold = Math.max(width, height) * 0.15;
            corners.forEach(corner => {
                if (points.some(p => distance(p, corner) < threshold)) cornerCount++;
            });
            return cornerCount / 4;
        }

        function getTriangleScore(points, bounds) {
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;

            // Count sharp corners — tightened window (0.5–2.3 rad) avoids
            // picking up the gradual curves of fish-loop strokes
            let turns = 0;
            const step = Math.max(1, Math.floor(points.length / 20));
            for (let i = step; i < points.length - step; i += step) {
                const prev = points[i - step];
                const curr = points[i];
                const next = points[Math.min(i + step, points.length - 1)];
                const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                let diff = Math.abs(angle2 - angle1);
                if (diff > Math.PI) diff = 2 * Math.PI - diff;
                if (diff > 0.5 && diff < 2.3) turns++;
            }

            // Aspect ratio check - triangles shouldn't be too thin
            const aspect = Math.min(width, height) / Math.max(width, height);
            const aspectOk = aspect > 0.3;

            // Graded score: exactly 3 corners = clear triangle, 2 or 4 = marginal
            if (turns === 3 && aspectOk) return 0.75;
            if ((turns === 2 || turns === 4) && aspectOk) return 0.58;
            return 0.2;
        }

        function getLineScore(points) {
            if (points.length < 3) return 0;
            const start = points[0];
            const end = points[points.length - 1];
            const lineLen = distance(start, end);
            if (lineLen < 30) return 0;

            let totalDev = 0;
            points.forEach(p => {
                const t = Math.max(0, Math.min(1,
                    ((p.x - start.x) * (end.x - start.x) + (p.y - start.y) * (end.y - start.y)) / (lineLen * lineLen)
                ));
                const proj = { x: start.x + t * (end.x - start.x), y: start.y + t * (end.y - start.y) };
                totalDev += distance(p, proj);
            });
            return Math.max(0, 1 - (totalDev / points.length) / (lineLen * 0.1));
        }

        function detectArrowHead(points) {
            if (points.length < 10) return false;
            const last10 = points.slice(-10);
            const end = points[points.length - 1];
            const beforeEnd = points[Math.max(0, points.length - 8)];
            const mainDir = Math.atan2(end.y - beforeEnd.y, end.x - beforeEnd.x);

            // Check for splaying at end
            let hasSplay = false;
            for (let i = 1; i < last10.length - 1; i++) {
                const dir = Math.atan2(last10[i].y - end.y, last10[i].x - end.x);
                const diff = Math.abs(dir - mainDir);
                if (diff > 0.4 && diff < 2.7) hasSplay = true;
            }
            return hasSplay;
        }

        // ============================================
        // Shape Detection
        // ============================================
        function detectShape(points) {
            if (points.length < 5) return null;

            const bounds = getBounds(points);
            const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const size = Math.max(width, height);

            if (size < 20) return null; // Too small

            // Check if closed (start near end)
            const start = points[0];
            const end = points[points.length - 1];
            const closedThreshold = size * 0.25;
            const isClosed = distance(start, end) < closedThreshold;

            if (isClosed) {
                // Analyze closed shape
                const circleScore = getCircleScore(points, center, size / 2);
                const rectScore = getRectScore(points, bounds);
                const triScore = getTriangleScore(points, bounds);

                if (circleScore > 0.7 && circleScore > rectScore && circleScore > triScore) {
                    return { type: 'circle', center, radius: size / 2, confidence: circleScore };
                }
                if (rectScore > 0.6 && rectScore > triScore) {
                    return { type: 'rectangle', bounds, center, confidence: rectScore };
                }
                if (triScore > 0.5) {
                    return { type: 'triangle', bounds, center, confidence: triScore };
                }
            } else {
                // Open shape - line or arrow
                const lineScore = getLineScore(points);
                if (lineScore > 0.7) {
                    const hasArrow = detectArrowHead(points);
                    return {
                        type: hasArrow ? 'arrow' : 'line',
                        start, end, center,
                        confidence: lineScore
                    };
                }
            }

            return null;
        }

        // ============================================
        // Stroke → Entity Classification
        // ============================================

        // Check if two line segments intersect, return intersection point
        function segmentsIntersect(p1, p2, p3, p4, returnPoint = false) {
            const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (Math.abs(d) < 0.001) return returnPoint ? null : false;
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / d;
            if (t > 0 && t < 1 && u > 0 && u < 1) {
                if (returnPoint) {
                    return {
                        x: p1.x + t * (p2.x - p1.x),
                        y: p1.y + t * (p2.y - p1.y)
                    };
                }
                return true;
            }
            return returnPoint ? null : false;
        }

        // Detect self-intersection and find loop center (fish body pivot)
        // Returns { loopCenter, loopStart, loopEnd, intersectionPoint } or null
        function findSelfIntersectionLoop(points) {
            if (points.length < 15) return null;

            const step = Math.max(1, Math.floor(points.length / 50));

            for (let i = 0; i < points.length - step * 4; i += step) {
                const a1 = points[i];
                const a2 = points[Math.min(i + step, points.length - 1)];

                for (let j = i + step * 3; j < points.length - step; j += step) {
                    const b1 = points[j];
                    const b2 = points[Math.min(j + step, points.length - 1)];

                    const intersection = segmentsIntersect(a1, a2, b1, b2, true);
                    if (intersection) {
                        // Found intersection - extract the loop (points between i and j)
                        const loopPoints = points.slice(i, j + 1);

                        // Check loop is curved (not sharp angular)
                        // Measure curvature by checking angle changes
                        let totalAngleChange = 0;
                        const sampleStep = Math.max(1, Math.floor(loopPoints.length / 10));
                        for (let k = sampleStep; k < loopPoints.length - sampleStep; k += sampleStep) {
                            const prev = loopPoints[k - sampleStep];
                            const curr = loopPoints[k];
                            const next = loopPoints[Math.min(k + sampleStep, loopPoints.length - 1)];
                            const a1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                            const a2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                            let diff = Math.abs(a2 - a1);
                            if (diff > Math.PI) diff = 2 * Math.PI - diff;
                            totalAngleChange += diff;
                        }

                        // Reject if too angular (sharp corners)
                        const avgAngleChange = totalAngleChange / (loopPoints.length / sampleStep);
                        if (avgAngleChange > 0.8) continue; // Too sharp, not a curved loop

                        // Calculate loop centroid (fish body center)
                        let cx = 0, cy = 0;
                        loopPoints.forEach(p => { cx += p.x; cy += p.y; });
                        cx /= loopPoints.length;
                        cy /= loopPoints.length;

                        // Check loop has decent size
                        const loopBounds = getBounds(loopPoints);
                        const loopW = loopBounds.maxX - loopBounds.minX;
                        const loopH = loopBounds.maxY - loopBounds.minY;
                        const loopSize = Math.max(loopW, loopH);
                        if (loopSize < 25) continue; // Loop too small

                        // Aspect ratio — rejects tiny crossings on long thin lines
                        const loopAspect = Math.min(loopW, loopH) / (Math.max(loopW, loopH) + 0.001);

                        return {
                            loopCenter: { x: cx, y: cy },
                            loopStart: i,
                            loopEnd: j,
                            intersectionPoint: intersection,
                            loopSize: loopSize,
                            loopAspect: loopAspect
                        };
                    }
                }
            }
            return null;
        }

        // Simple boolean check for backwards compatibility
        function hasSelfIntersection(points) {
            return findSelfIntersectionLoop(points) !== null;
        }

        // Generate jellyfish replacement art (bell + flowing tentacles)
        // Generate jellyfish with bell and separate tentacle data for animation
        function generateJellyfishShape(size) {
            const r = size * 0.35;
            const numTentacles = 5 + Math.floor(Math.random() * 3);
            const tentacleLength = 4 + Math.floor(Math.random() * 3);

            return {
                bellRadius: r,
                bellHeight: r * 0.6,
                numTentacles: numTentacles,
                tentacleLength: tentacleLength,
                // Random variation per jellyfish
                tentacleSpacing: 0.7 + Math.random() * 0.3,
                wobbleOffset: Math.random() * Math.PI * 2,
                pulseOffset: Math.random() * Math.PI * 2
            };
        }

        // Generate coral - simplified for performance
        function generateCoralShape(size, bounds) {
            const width = bounds ? (bounds.maxX - bounds.minX) : size;
            const height = bounds ? (bounds.maxY - bounds.minY) : size * 0.8;

            // Fewer stalks for better performance
            const numStalks = Math.max(2, Math.min(6, Math.floor(width / 25)));
            const stalks = [];

            for (let s = 0; s < numStalks; s++) {
                const xPos = -width / 2 + (s + 0.5) * (width / numStalks);
                const stalkHeight = height * (0.5 + Math.random() * 0.4);

                // 2-3 branches per stalk
                const numBranches = 2 + Math.floor(Math.random() * 2);

                stalks.push({
                    x: xPos + (Math.random() - 0.5) * 6,
                    height: stalkHeight,
                    branches: []
                });

                for (let b = 0; b < numBranches; b++) {
                    const branchY = stalkHeight * (0.3 + (b / numBranches) * 0.5);
                    const branchDir = (b % 2 === 0) ? -1 : 1;
                    const branchLen = 8 + Math.random() * 15;
                    const branchAngle = (0.3 + Math.random() * 0.4) * branchDir;

                    stalks[s].branches.push({
                        y: branchY,
                        angle: branchAngle,
                        length: branchLen,
                        hasTip: Math.random() > 0.3
                    });
                }
            }

            return {
                width: width,
                height: height,
                stalks: stalks,
                swayOffset: Math.random() * Math.PI * 2
            };
        }

        // Generate SIMPLE fish shape for small fish - procedural outline
        function generateSimpleFishShape(loopInfo, originalPoints, size) {
            const loopPoints = originalPoints.slice(loopInfo.loopStart, loopInfo.loopEnd + 1);
            const loopBounds = getBounds(loopPoints);
            const loopWidth = loopBounds.maxX - loopBounds.minX;
            const loopHeight = loopBounds.maxY - loopBounds.minY;

            // Fish dimensions based on drawn loop
            const bodyLen = Math.max(loopWidth, loopHeight) * 0.45;
            const bodyH = Math.min(loopWidth, loopHeight) * 0.35;
            const tailLen = bodyLen * 0.6;
            const tailSpread = bodyH * 0.9;

            // Head direction from intersection point
            const headDir = Math.atan2(
                loopInfo.intersectionPoint.y - loopInfo.loopCenter.y,
                loopInfo.intersectionPoint.x - loopInfo.loopCenter.x
            );

            // Create fish outline centered at body center (not geometric center)
            // Offset so body center is at origin, nose at +X
            const bodyCenter = bodyLen * 0.1; // Body center offset from geometric center
            const pts = [];

            pts.push({ x: bodyLen - bodyCenter, y: 0 }); // Nose
            pts.push({ x: bodyLen * 0.7 - bodyCenter, y: -bodyH * 0.5 });
            pts.push({ x: bodyLen * 0.3 - bodyCenter, y: -bodyH * 0.8 });
            pts.push({ x: -bodyLen * 0.2 - bodyCenter, y: -bodyH * 0.6 });
            pts.push({ x: -bodyLen * 0.5 - bodyCenter, y: -bodyH * 0.3 });
            pts.push({ x: -bodyLen * 0.5 - tailLen - bodyCenter, y: -tailSpread }); // Tail top
            pts.push({ x: -bodyLen * 0.5 - tailLen * 0.5 - bodyCenter, y: 0 }); // Tail notch
            pts.push({ x: -bodyLen * 0.5 - tailLen - bodyCenter, y: tailSpread }); // Tail bottom
            pts.push({ x: -bodyLen * 0.5 - bodyCenter, y: bodyH * 0.3 });
            pts.push({ x: -bodyLen * 0.2 - bodyCenter, y: bodyH * 0.6 });
            pts.push({ x: bodyLen * 0.3 - bodyCenter, y: bodyH * 0.8 });
            pts.push({ x: bodyLen * 0.7 - bodyCenter, y: bodyH * 0.5 });
            pts.push({ x: bodyLen - bodyCenter, y: 0 }); // Back to nose

            // Calculate actual bounds for collision
            const shapeBounds = getBounds(pts);
            const actualWidth = shapeBounds.maxX - shapeBounds.minX;
            const actualHeight = shapeBounds.maxY - shapeBounds.minY;

            return {
                points: pts,
                initialHeading: headDir,
                bodyWidth: actualWidth / 2,  // Half-width for radius
                bodyHeight: actualHeight / 2,
                noseOffset: bodyLen - bodyCenter,  // Distance from center to nose
                isStrokeBased: false
            };
        }

        // SVG fish template path - from Assets/fish-large-template.svg
        // This is a single continuous stroke: body loop + through-line + tail
        const FISH_SVG_PATH = "M1069 305.184C1002.34 474.878 823 512 717 512C326.131 512 316.472 334.531 316.472 297.439M316.472 297.439C326.5 177.5 512.371 120 723.55 120C883.704 120 1093.74 215.974 1065.61 256.375C1057.99 267.316 971.358 328.708 749.191 334.531C506.537 340.891 388.979 316.987 316.472 297.439ZM316.472 297.439C249.891 279.489 145.743 99.6744 111.909 127.568C95.6466 140.975 188.625 248.318 188.626 334.531C188.626 413.321 80.6552 501.811 118 518.5C155.345 535.189 189.091 402.659 284.5 384.5";

        // SVG dimensions for scaling - measured from the actual path
        // Body spans roughly x=316 to x=1069, y=120 to y=512
        // Tail extends to x≈80
        const FISH_SVG_BODY_WIDTH = 753;   // 1069 - 316 (body only, not tail)
        const FISH_SVG_BODY_HEIGHT = 392;  // 512 - 120
        const FISH_SVG_CENTER_X = 690;     // Center of body: (316 + 1069) / 2 ≈ 690
        const FISH_SVG_CENTER_Y = 316;     // Center Y: (120 + 512) / 2
        const FISH_SVG_NOSE_X = 1069;      // Nose position (rightmost point)

        // Create the Path2D object once
        let fishPath2D = null;
        try {
            fishPath2D = new Path2D(FISH_SVG_PATH);
        } catch (e) {
            console.warn('Path2D not supported, falling back to simple fish');
        }

        // Generate STROKE-BASED fish shape for big fish - uses SVG template
        function generateStrokeFishShape(loopInfo, originalPoints, size) {
            const loopPoints = originalPoints.slice(loopInfo.loopStart, loopInfo.loopEnd + 1);
            const loopBounds = getBounds(loopPoints);
            const loopWidth = loopBounds.maxX - loopBounds.minX;
            const loopHeight = loopBounds.maxY - loopBounds.minY;

            // Calculate centroid for position
            let cx = 0, cy = 0;
            loopPoints.forEach(p => { cx += p.x; cy += p.y; });
            cx /= loopPoints.length;
            cy /= loopPoints.length;

            // Head direction from loop shape - nose points away from intersection
            const headDir = Math.atan2(
                cy - loopInfo.intersectionPoint.y,
                cx - loopInfo.intersectionPoint.x
            );

            // Scale factor based on drawn size vs SVG body size
            const drawnSize = Math.max(loopWidth, loopHeight);
            const scaleFactor = drawnSize / FISH_SVG_BODY_WIDTH;

            // Calculate actual dimensions after scaling
            const scaledBodyWidth = FISH_SVG_BODY_WIDTH * scaleFactor;
            const scaledBodyHeight = FISH_SVG_BODY_HEIGHT * scaleFactor;
            const noseOffset = (FISH_SVG_NOSE_X - FISH_SVG_CENTER_X) * scaleFactor;

            return {
                useSvgPath: true,
                scaleFactor: scaleFactor,
                initialHeading: headDir,
                bodyWidth: scaledBodyWidth / 2,
                bodyHeight: scaledBodyHeight / 2,
                noseOffset: noseOffset,
                isStrokeBased: true
            };
        }

        // Main fish shape generator - chooses style based on size
        function generateFishShape(loopInfo, originalPoints, size) {
            // Big fish (loop size > 60) get stroke-based shape
            // Small fish get simple procedural shape
            if (loopInfo.loopSize > 60) {
                return generateStrokeFishShape(loopInfo, originalPoints, size);
            } else {
                return generateSimpleFishShape(loopInfo, originalPoints, size);
            }
        }

        // Shape classification - matches design.html detectShape() exactly, plus fish
        function classifyStroke(points) {
            if (!points || points.length === 0) return null;

            // Tiny tap/dot → food (before other checks)
            if (points.length < 8) {
                const bounds = getBounds(points);
                const size = Math.max(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
                if (size < 25) {
                    const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
                    return { type: 'food', center, size, points };
                }
            }

            if (points.length < 5) return null;

            const bounds = getBounds(points);
            const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const size = Math.max(width, height);

            if (size < 20) return null; // Too small

            // Check if closed (start near end) - exact design.html logic
            const start = points[0];
            const end = points[points.length - 1];
            const closedThreshold = size * 0.25;
            const isClosed = distance(start, end) < closedThreshold;

            if (isClosed) {
                // Analyze closed shape - exact design.html scoring and comparison
                const circleScore = getCircleScore(points, center, size / 2);
                const rectScore = getRectScore(points, bounds);
                const triScore = getTriangleScore(points, bounds);

                // Circle → bubble (must beat both others)
                if (circleScore > 0.7 && circleScore > rectScore && circleScore > triScore) {
                    return { type: 'bubble', center, radius: size / 2, size, points, confident: circleScore > 0.75 };
                }
                // Rectangle → coral (must beat triangle)
                if (rectScore > 0.6 && rectScore > triScore) {
                    const coralShape = generateCoralShape(size, bounds);
                    return { type: 'coral', center, size, bounds, shape: coralShape, confident: rectScore > 0.65 };
                }
                // Triangle → jellyfish (raised from 0.5 → 0.57 so 3-corner draws are reliable)
                if (triScore > 0.57) {
                    const jellyShape = generateJellyfishShape(size);
                    return { type: 'jellyfish', center, size, bounds, shape: jellyShape, confident: triScore >= 0.75 };
                }
                // Unrecognized closed shape → no entity
                return null;
            }

            // OPEN STROKES - check for self-intersecting fish shape (ichthys)
            // Raised loopSize minimum 25→45 and require loopAspect>0.3
            // to reject tiny crossings on long thin lines
            const loopInfo = findSelfIntersectionLoop(points);
            if (loopInfo && loopInfo.loopSize > 45 && loopInfo.loopAspect > 0.3) {
                const fishShape = generateFishShape(loopInfo, points, size);
                return {
                    type: 'fish',
                    center: loopInfo.loopCenter,
                    size: loopInfo.loopSize,
                    fishShape: fishShape,
                    loopInfo: loopInfo,
                    confident: loopInfo.loopSize > 55 && loopInfo.loopAspect > 0.35
                };
            }

            // Open stroke → temporary line (for bubble-popping)
            return { type: 'line', center, size, points, start, end };
        }

        // ============================================
        // Canvas Setup
        // ============================================

        // applyCanvasSize: pure sizing, safe to call before animation vars are initialized
        function applyCanvasSize() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // resizeCanvas: called by resize listener after full init — cancels the running
        // loop, resizes, then restarts cleanly to avoid duplicate animate() chains
        function resizeCanvas() {
            applyCanvasSize();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            isAnimating = false;
            startAnimation();
        }

        applyCanvasSize(); // initial sizing only — animation starts after full script init
        window.addEventListener('resize', resizeCanvas);
        
        // ============================================
        // Drawing Functions
        // ============================================
        function drawGrid() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, w, h);
        }
        
        
        function drawRawStrokes() {
            const now = Date.now();
            
            strokes = strokes.filter(stroke => {
                const age = now - stroke.startTime;
                if (age > stroke.fadeStart + TIMING.strokeFade) return false;
                
                let opacity = 1;
                if (age > stroke.fadeStart) {
                    opacity = 1 - ((age - stroke.fadeStart) / TIMING.strokeFade);
                }
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                if (stroke.points.length < 2) return true;
                
                ctx.shadowColor = colors.glow;
                ctx.shadowBlur = 12 * easedOpacity;
                ctx.strokeStyle = `rgba(147, 197, 253, ${0.85 * easedOpacity})`;
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    const p0 = stroke.points[i - 1];
                    const p1 = stroke.points[i];
                    ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                return true;
            });
        }

        // ============================================
        // Entity Rendering
        // ============================================
        function drawFishEntities() {
            const now = Date.now();
            // ---- DELTA TIME: Real elapsed ms since last frame, capped to prevent jumps ----
            // Replaces hardcoded 16ms assumptions — correct on all devices/framerates
            const deltaTime = Math.min(now - (this._lastFrameTime || now), 50);
            this._lastFrameTime = now;
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            // Physics constants - tuned for smooth movement
            const DETECT_RANGE = 400;
            const EAT_RANGE = 35;  // Distance from mouth to eat (larger for better pickup)
            const SEEK_SPEED = 1.2;
            const IDLE_SPEED = 0.5;
            const FLEE_SPEED = 5.0;         // Fast escape when scared - INCREASED from 3.5
            const TURN_RATE = 0.04;         // Turning speed - REDUCED for smoother turns
            const MAX_TURN_PER_FRAME = 0.04; // Cap heading change per frame - REDUCED
            const EDGE_MARGIN = 50;
            const EDGE_FORCE = 0.1;

            // Boids - separation is critical to prevent overlap
            // NOTE: These fixed ranges are now FALLBACKS - see getPerceptionRanges()
            const BOID_SEP_RANGE = 100;
            const BOID_ALIGN_RANGE = 200;
            const BOID_COHESION_RANGE = 300;

            // ---- PHASE 1: Size-Based Perception Ranges ----
            // Fish perceive the world proportional to their body size
            function getPerceptionRanges(bodyWidth) {
                return {
                    separation: bodyWidth * 2.5,  // Small(25px)=62, Medium(45px)=112, Large(80px)=200
                    alignment: bodyWidth * 5,     // Small=125, Medium=225, Large=400
                    cohesion: bodyWidth * 7       // Small=175, Medium=315, Large=560
                };
            }

            // ---- PHASE 2: Cross-Size Awareness ----
            // Smaller fish detect larger fish (predators) at greater distances
            const SIZE_AWARENESS = {
                small_sees_large: 2.5,    // Small fish see large 150% farther (fear)
                small_sees_medium: 1.5,   // Small fish see medium 50% farther
                medium_sees_large: 1.8,   // Medium fish see large 80% farther
                large_sees_small: 0.6,    // Large fish less interested in small
                same_size: 1.0
            };

            // Helper to get awareness multiplier between two fish sizes
            function getAwarenessMultiplier(mySize, otherSize) {
                if (mySize === otherSize) return SIZE_AWARENESS.same_size;
                if (mySize === 'small' && otherSize === 'large') return SIZE_AWARENESS.small_sees_large;
                if (mySize === 'small' && otherSize === 'medium') return SIZE_AWARENESS.small_sees_medium;
                if (mySize === 'medium' && otherSize === 'large') return SIZE_AWARENESS.medium_sees_large;
                if (mySize === 'large' && otherSize === 'small') return SIZE_AWARENESS.large_sees_small;
                return 1.0;
            }

            // ---- PHASE 3: Predator Wake Avoidance ----
            // Fish avoid the predicted PATH of large fish, not just their position
            // This creates a "parting" effect as large fish swim toward a school
            const WAKE_LOOKAHEAD = 80;         // Project predator path 80px ahead
            const WAKE_WIDTH = 60;             // Width of avoidance corridor
            const WAKE_AVOIDANCE_FORCE = 0.02; // Gentle steering

            function getWakeAvoidance(targetFish, predators, isSmall, isMedium) {
                // Only small/medium fish avoid wakes - large fish don't care
                if (!isSmall && !isMedium) return { angle: 0, strength: 0 };

                let avoidX = 0, avoidY = 0;

                // predators is pre-filtered to large fish only (no size check needed)
                predators.forEach(pred => {

                    // Calculate predator's future position
                    const predFutureX = pred.x + Math.cos(pred.heading || 0) * WAKE_LOOKAHEAD;
                    const predFutureY = pred.y + Math.sin(pred.heading || 0) * WAKE_LOOKAHEAD;

                    // Vector from predator to target fish
                    const toPredX = pred.x - targetFish.x;
                    const toPredY = pred.y - targetFish.y;

                    // Predator heading direction
                    const wakeDirX = Math.cos(pred.heading || 0);
                    const wakeDirY = Math.sin(pred.heading || 0);

                    // Project fish position onto wake line (predator -> future)
                    const dot = toPredX * wakeDirX + toPredY * wakeDirY;

                    // Only avoid if fish is in front of or alongside predator (not behind)
                    if (dot > -20 && dot < WAKE_LOOKAHEAD + 40) {
                        // Calculate perpendicular distance to wake line
                        const perpX = toPredX - wakeDirX * dot;
                        const perpY = toPredY - wakeDirY * dot;
                        const perpDist = Math.sqrt(perpX * perpX + perpY * perpY);

                        // If fish is within wake corridor, steer perpendicular to escape
                        if (perpDist < WAKE_WIDTH && perpDist > 0) {
                            const strength = (WAKE_WIDTH - perpDist) / WAKE_WIDTH;
                            // Escape direction: perpendicular to wake, away from center
                            const escapeX = -perpX / perpDist;
                            const escapeY = -perpY / perpDist;
                            avoidX += escapeX * strength * WAKE_AVOIDANCE_FORCE;
                            avoidY += escapeY * strength * WAKE_AVOIDANCE_FORCE;
                        }
                    }
                });

                if (avoidX === 0 && avoidY === 0) {
                    return { angle: 0, strength: 0 };
                }

                return {
                    angle: Math.atan2(avoidY, avoidX),
                    strength: Math.sqrt(avoidX * avoidX + avoidY * avoidY)
                };
            }

            // Size categories (based on bodyWidth)
            const SMALL_THRESHOLD = 35;     // Below = small
            const MEDIUM_THRESHOLD = 60;    // Below = medium, above = large

            // Coral repulsion for medium/large fish
            const CORAL_REPEL_RANGE = 100;
            const CORAL_REPEL_FORCE = 0.15;

            // ---- PHASE 8: Centralized Force Weights for Tuning ----
            // All boid and steering forces can be adjusted here
            const FORCE_WEIGHTS = {
                // Boids forces
                small_alignment: 0.015,     // Small fish match neighbors' heading
                small_cohesion: 0.01,       // Small fish drift toward group center
                medium_soft_align: 0.008,   // Medium fish subtle alignment
                medium_soft_cohesion: 0.006,// Medium fish drift to school center
                medium_school_heading: 0.04, // Medium fish follow school direction
                medium_leader_follow: 0.015, // Medium fish follow leader

                // Separation and collision
                soft_separation: 0.04,       // Comfort zone steering (max)
                collision_steer: 0.025,      // Collision avoidance (normal)
                collision_gentle: 0.005,     // Large fish gentle collision

                // Special behaviors
                wake_avoidance: 0.02,        // Predator wake avoidance
                center_repulsion: 0.006,     // Prevent center pile-up
                territorial: 2.0,            // Large fish territory strength
                regroup_cohesion: 0.04       // School regroup blend rate
            };

            // ---- SHARED SCHOOL TARGET for medium fish ----
            // Calculate school center and pick a shared wander target
            // SMOOTHED to reduce jitter with more fish
            let rawSchoolCenterX = 0, rawSchoolCenterY = 0, mediumCount = 0;
            fish.forEach(f => {
                const bw = f.bodyWidth || 20;
                if (bw >= SMALL_THRESHOLD && bw < MEDIUM_THRESHOLD) {
                    rawSchoolCenterX += f.x;
                    rawSchoolCenterY += f.y;
                    mediumCount++;
                }
            });
            if (mediumCount > 0) {
                rawSchoolCenterX /= mediumCount;
                rawSchoolCenterY /= mediumCount;
            }

            // Smooth the school center to prevent jitter
            const CENTER_SMOOTH = 0.15; // Low value = smoother, higher = more responsive
            if (this.smoothSchoolCenterX === undefined) {
                this.smoothSchoolCenterX = rawSchoolCenterX;
                this.smoothSchoolCenterY = rawSchoolCenterY;
            } else {
                this.smoothSchoolCenterX += (rawSchoolCenterX - this.smoothSchoolCenterX) * CENTER_SMOOTH;
                this.smoothSchoolCenterY += (rawSchoolCenterY - this.smoothSchoolCenterY) * CENTER_SMOOTH;
            }
            const schoolCenterX = this.smoothSchoolCenterX;
            const schoolCenterY = this.smoothSchoolCenterY;

            // ---- PHASE 5: Track school spread for re-cohesion ----
            // PERFORMANCE: Throttle O(n²) calculation to every ~500ms (30 frames)
            this.schoolSpreadCounter = (this.schoolSpreadCounter || 0) + 1;
            const shouldCalcSpread = this.schoolSpreadCounter % 30 === 0;

            const SCHOOL_SCATTER_THRESHOLD = 200; // School is "scattered" if spread > this
            let maxSchoolSpread = this.cachedMaxSchoolSpread || 0;

            if (shouldCalcSpread && mediumCount > 1) {
                maxSchoolSpread = 0;
                const mediumFish = fish.filter(f => {
                    const bw = f.bodyWidth || 20;
                    return bw >= SMALL_THRESHOLD && bw < MEDIUM_THRESHOLD;
                });

                for (let i = 0; i < mediumFish.length; i++) {
                    for (let j = i + 1; j < mediumFish.length; j++) {
                        const dx = mediumFish[i].x - mediumFish[j].x;
                        const dy = mediumFish[i].y - mediumFish[j].y;
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d > maxSchoolSpread) maxSchoolSpread = d;
                    }
                }
                this.cachedMaxSchoolSpread = maxSchoolSpread;
            }
            const schoolScattered = maxSchoolSpread > SCHOOL_SCATTER_THRESHOLD;

            // Store for debug visualization
            window.debugSchoolScattered = schoolScattered;
            window.debugSchoolSpread = maxSchoolSpread;

            // ---- INTELLIGENT SCHOOL WAYPOINT ----
            // Priority 1: Flee from threats (large fish) - ONLY if very close
            // Priority 2: Move toward food cluster
            // Priority 3: Patrol smoothly when idle
            // TARGET IS SMOOTHED to prevent jumping

            let schoolTargetReason = 'patrol';  // For debug
            let rawTargetX = this.schoolTarget?.x || w * 0.5;
            let rawTargetY = this.schoolTarget?.y || h * 0.4;

            // ---- SCHOOL FLEE COOLDOWN ----
            // Don't constantly flip between fleeing and not fleeing
            this.schoolFleeCooldown = (this.schoolFleeCooldown || 0) - deltaTime;
            const canSchoolFlee = this.schoolFleeCooldown <= 0;

            // Priority 1: Check for threatening large fish near school
            // Two zones: close = always flee, far = only if facing school
            let threat = null;
            let threatDist = Infinity;
            const THREAT_RANGE_CLOSE = 160;  // Always flee - no cooldown blocks this
            const THREAT_RANGE_FAR = 280;    // Only flee if predator facing school

            fish.forEach(other => {
                const otherBw = other.bodyWidth || 20;
                if (otherBw < 60) return;  // Only large fish are threats

                const dx = other.x - schoolCenterX;
                const dy = other.y - schoolCenterY;
                const d = Math.sqrt(dx * dx + dy * dy);
                if (d > THREAT_RANGE_FAR) return;

                if (d < THREAT_RANGE_CLOSE) {
                    // Always react when very close, even through cooldown
                    if (d < threatDist) { threat = other; threatDist = d; }
                    return;
                }

                // Farther: only if predator heading toward school (within 80°)
                if (!canSchoolFlee) return;
                const angleToSchool = Math.atan2(-dy, -dx);
                const facingDiff = Math.abs(angleDiff(angleToSchool, other.heading || 0));
                if (facingDiff < Math.PI * 0.45 && d < threatDist) {
                    threat = other;
                    threatDist = d;
                }
            });

            if (threat && mediumCount > 0) {
                // FLEE: Move school waypoint strongly away from threat
                schoolTargetReason = 'fleeing';
                this.schoolFleeCooldown = 1500; // Shorter cooldown - can re-evaluate sooner
                const fleeAngle = Math.atan2(schoolCenterY - threat.y, schoolCenterX - threat.x);
                const fleeDist = 250; // Larger escape distance
                rawTargetX = schoolCenterX + Math.cos(fleeAngle) * fleeDist;
                rawTargetY = schoolCenterY + Math.sin(fleeAngle) * fleeDist;

                // Clamp to safe zones
                rawTargetX = Math.max(120, Math.min(w - 120, rawTargetX));
                rawTargetY = Math.max(80, Math.min(h * 0.6, rawTargetY));
            }
            // Priority 2: Check for nearby food cluster
            // NOTE: Food takes priority over regrouping - school will go to food even if scattered
            else if (food.length > 0 && mediumCount > 0) {
                // PERFORMANCE: Cache food sorting for 200ms instead of every frame
                // Skip sort entirely if <= 3 items (all will be used anyway)
                this.foodSortTimer = (this.foodSortTimer || 0) - deltaTime;
                if (this.foodSortTimer <= 0 || !this.cachedSortedFood || this.cachedFoodCount !== food.length) {
                    this.foodSortTimer = 200;
                    this.cachedFoodCount = food.length;
                    if (food.length <= 3) {
                        this.cachedSortedFood = food; // No sort needed, use all items as-is
                    } else {
                        this.cachedSortedFood = food.slice().sort((a, b) => {
                            const da = Math.sqrt((a.x - schoolCenterX) ** 2 + (a.y - schoolCenterY) ** 2);
                            const db = Math.sqrt((b.x - schoolCenterX) ** 2 + (b.y - schoolCenterY) ** 2);
                            return da - db;
                        });
                    }
                }
                const sortedFood = this.cachedSortedFood;

                const nearestFoods = sortedFood.slice(0, Math.min(3, sortedFood.length));
                const foodClusterX = nearestFoods.reduce((sum, fd) => sum + fd.x, 0) / nearestFoods.length;
                const foodClusterY = nearestFoods.reduce((sum, fd) => sum + fd.y, 0) / nearestFoods.length;

                const foodDist = Math.sqrt((foodClusterX - schoolCenterX) ** 2 + (foodClusterY - schoolCenterY) ** 2);

                // FIXED: Increased range from 350 to 600, removed minimum distance
                // Food anywhere in reasonable range will attract the school
                if (foodDist < 600) {
                    schoolTargetReason = 'food';
                    rawTargetX = foodClusterX;
                    rawTargetY = foodClusterY;
                } else {
                    schoolTargetReason = 'patrol';
                }
            }
            // Priority 2.5: Regroup when scattered (AFTER food check, not before)
            else if (schoolScattered && mediumCount > 1) {
                schoolTargetReason = 'regrouping';
                // Target is school center - forces fish to converge
                rawTargetX = schoolCenterX;
                rawTargetY = schoolCenterY;
                // Clamp to safe zone (don't regroup into edges)
                rawTargetX = Math.max(120, Math.min(w - 120, rawTargetX));
                rawTargetY = Math.max(100, Math.min(h * 0.55, rawTargetY));
            }

            // Priority 3: Patrol smoothly when no threats or food
            if (schoolTargetReason === 'patrol') {
                this.schoolTargetTimer = (this.schoolTargetTimer || 0) - deltaTime;

                if (!this.schoolTarget || this.schoolTargetTimer <= 0) {
                    // REDUCED: 4-6 seconds per waypoint (was 8-12s)
                    this.schoolTargetTimer = 4000 + Math.random() * 2000;

                    // Patrol pattern - predictable movement
                    this.schoolPatrolIndex = ((this.schoolPatrolIndex || 0) + 1) % 4;
                    const patrolPoints = [
                        { x: w * 0.3, y: h * 0.35 },
                        { x: w * 0.7, y: h * 0.35 },
                        { x: w * 0.7, y: h * 0.5 },
                        { x: w * 0.3, y: h * 0.5 },
                    ];
                    rawTargetX = patrolPoints[this.schoolPatrolIndex].x;
                    rawTargetY = patrolPoints[this.schoolPatrolIndex].y;
                }
            }

            // ---- EDGE-AWARE WAYPOINT CLAMPING ----
            // Ensure waypoint stays in safe zone (not too close to edges)
            const waypointMargin = 100;
            rawTargetX = Math.max(waypointMargin, Math.min(w - waypointMargin, rawTargetX));
            rawTargetY = Math.max(80, Math.min(h * 0.55, rawTargetY));

            // ---- SMOOTH school target toward raw target (prevents jumping) ----
            // REDUCED blend rates to prevent jitter with more fish
            const blendRate = (schoolTargetReason === 'fleeing') ? 0.08 :
                              (schoolTargetReason === 'regrouping') ? 0.05 : 0.03;
            if (!this.schoolTarget) {
                this.schoolTarget = { x: rawTargetX, y: rawTargetY };
            } else {
                this.schoolTarget.x += (rawTargetX - this.schoolTarget.x) * blendRate;
                this.schoolTarget.y += (rawTargetY - this.schoolTarget.y) * blendRate;
            }

            // Store reason for debug
            window.debugSchoolReason = schoolTargetReason;
            this.schoolTargetReason = schoolTargetReason; // Also store on this for fish to access

            // ---- ARRIVAL DETECTION: Advance waypoint immediately when school arrives ----
            if (this.schoolTarget && schoolTargetReason === 'patrol') {
                const distToTarget = Math.sqrt(
                    (schoolCenterX - this.schoolTarget.x) ** 2 +
                    (schoolCenterY - this.schoolTarget.y) ** 2
                );
                if (distToTarget < 80) {
                    // School has arrived - force next waypoint immediately
                    this.schoolTargetTimer = 0;
                }
            }

            // School heading updates based on school CENTER movement toward target
            // NOT based on individual fish - this prevents feedback loops
            if (mediumCount > 0 && this.schoolTarget) {
                const dx = this.schoolTarget.x - schoolCenterX;
                const dy = this.schoolTarget.y - schoolCenterY;
                const distToTarget = Math.sqrt(dx * dx + dy * dy);

                if (distToTarget > 30) {
                    // Steer school toward target
                    const targetHeading = Math.atan2(dy, dx);
                    this.schoolHeading = this.schoolHeading || targetHeading;
                    this.schoolHeading += angleDiff(targetHeading, this.schoolHeading) * 0.02;
                }
                // When close to target, maintain current heading (don't spin)
            }

            // Store for debug visualization
            window.debugSchoolTarget = this.schoolTarget;
            window.debugSchoolHeading = this.schoolHeading;

            // ---- PHASE 7: Dynamic Leadership ----
            // Calculate which medium fish is the "leader" based on position and facing
            // Leader is the fish closest to school target AND facing toward it
            let schoolLeader = null;
            let maxLeadershipScore = 0;

            if (mediumCount > 0 && this.schoolTarget) {
                fish.forEach(f => {
                    const bw = f.bodyWidth || 20;
                    if (bw < SMALL_THRESHOLD || bw >= MEDIUM_THRESHOLD) return; // Only medium fish

                    const toTargetX = this.schoolTarget.x - f.x;
                    const toTargetY = this.schoolTarget.y - f.y;
                    const distToTarget = Math.sqrt(toTargetX * toTargetX + toTargetY * toTargetY);
                    const angleToTarget = Math.atan2(toTargetY, toTargetX);

                    // Facing score: how aligned is fish with target direction (0 to 1)
                    const facingDiff = Math.abs(angleDiff(angleToTarget, f.heading || 0));
                    const facingScore = 1 - (facingDiff / Math.PI);

                    // Leadership score: closer + more aligned = higher score
                    // Distance component is inverse (closer = higher)
                    const distScore = 1 / (distToTarget + 50);
                    const leadershipScore = distScore * facingScore * 100;

                    f.leadershipScore = leadershipScore; // Store for debug

                    if (leadershipScore > maxLeadershipScore) {
                        maxLeadershipScore = leadershipScore;
                        schoolLeader = f;
                    }
                });
            }

            // Store current leader for use in fish loop
            this.schoolLeader = schoolLeader;
            window.debugSchoolLeader = schoolLeader?.id;

            // ---- PERFORMANCE: Pre-filter large fish once before main loop ----
            // Used by getWakeAvoidance() instead of scanning all fish each call
            const largeFishList = fish.filter(f => (f.bodyWidth || 20) >= MEDIUM_THRESHOLD);

            // ---- PERFORMANCE: Frame counter for throttling periodic calculations ----
            this.frameCounter = (this.frameCounter || 0) + 1;

            // Track fish caught by jellyfish tentacles this frame (avoid splice mid-iteration)
            const jellyfishCaughtFish = new Set();

            fish.forEach((f, fi) => {
                const pts = f.points;
                // SVG fish don't have points array, skip this check for them
                if (!f.useSvgPath && (!pts || pts.length < 2)) return;

                // Per-fish unique color using hue shift
                const baseColor = aquaColors.fish[f.id % aquaColors.fish.length];
                const hueShift = f.hueShift || 0;
                // Apply hue shift by rotating through color spectrum
                const hsl = `hsl(${(180 + hueShift) % 360}, 80%, 65%)`;
                const color = hueShift ? hsl : baseColor;

                // Per-fish randomness offset (consistent per fish)
                const fishRand = (f.id * 0.618) % 1;

                // ---- Fish AI: seek visible food (not inside bubbles) ----
                // Calculate mouth position - 78% toward nose from center
                const rawNoseOffset = f.useSvgPath
                    ? (f.noseOffset || f.bodyWidth || 20)
                    : (f.noseOffset || f.bodyWidth || 20) * (f.scaleX || 1);
                const mouthOffset = rawNoseOffset * 0.78; // Mouth forward 30% from previous 0.6
                const mouthX = f.x + Math.cos(f.heading) * mouthOffset;
                const mouthY = f.y + Math.sin(f.heading) * mouthOffset;

                let nearestFood = null;
                let nearestDist = Infinity;
                let nearestMouthDist = Infinity;
                food.forEach(fd => {
                    if (fd.inBubble) return; // Updated each frame in drawBubbleEntities()
                    // Use mouth distance for both detection and proximity ranking.
                    // Avoids "seeing" food that's already behind the fish's eating point.
                    const md = Math.sqrt((mouthX - fd.x) ** 2 + (mouthY - fd.y) ** 2);
                    if (md < nearestDist) {
                        nearestDist = md;
                        nearestMouthDist = md;
                        nearestFood = fd;
                    }
                });

                // Get personality (with defaults for old fish)
                const energy = f.energy || 0.5;
                const curiosity = f.curiosity || 0.4;
                const nervousness = f.nervousness || 0.4;

                // Determine size category
                const bw = f.bodyWidth || 20;
                const isSmall = bw < SMALL_THRESHOLD;
                const isLarge = bw >= MEDIUM_THRESHOLD;
                const isMedium = !isSmall && !isLarge;

                // Initialize state timers if missing
                if (f.huntTimer === undefined) f.huntTimer = 0;
                if (f.fleeTimer === undefined) f.fleeTimer = 0;
                if (f.challengeTimer === undefined) f.challengeTimer = 0;
                if (f.cruiseAngle === undefined) f.cruiseAngle = f.heading; // Stable cruise direction

                // Dominance for large fish (based on body size + small random factor)
                if (f.dominance === undefined) {
                    f.dominance = (f.bodyWidth || 20) + Math.random() * 10;
                }

                // ---- STATE CHANGE COOLDOWN ----
                // Prevents rapid state switching that causes erratic behavior
                f.stateChangeCooldown = Math.max(0, (f.stateChangeCooldown || 0) - deltaTime);
                const canChangeState = f.stateChangeCooldown <= 0;

                // ---- TRACK BASE TARGET HEADING (for per-frame change cap) ----
                // Save at start of frame to limit total steering force accumulation
                const baseTargetHeading = f.targetHeading || f.heading;

                // ---- DECREMENT STATE TIMERS ----
                f.huntTimer = Math.max(0, (f.huntTimer || 0) - deltaTime);
                f.fleeTimer = Math.max(0, (f.fleeTimer || 0) - deltaTime);
                f.challengeTimer = Math.max(0, (f.challengeTimer || 0) - deltaTime);

                // ---- FOOD SEEKING (highest priority for all fish) ----
                // Eat range varies by size: large=35, medium=17 (50%), small=9 (25%)
                const sizeEatRange = isLarge ? EAT_RANGE : (isMedium ? EAT_RANGE * 0.5 : EAT_RANGE * 0.25);

                // Clear food target if not seeking
                if (f.state !== 'seeking') {
                    f.debugFoodTarget = null;
                }

                if (nearestFood && nearestDist < DETECT_RANGE && f.state !== 'fleeing' && f.state !== 'hiding') {
                    // Steer mouth toward food, not center toward food.
                    // This prevents overshooting: the fish aligns its eating point, not its pivot.
                    const foodAngle = Math.atan2(nearestFood.y - mouthY, nearestFood.x - mouthX);
                    const angleToFood = Math.abs(angleDiff(foodAngle, f.heading));

                    // ---- MEDIUM FISH: Check if large fish is competing for same food ----
                    // Large fish startle medium fish away - they get priority
                    let largeFishCompeting = null;
                    if (isMedium) {
                        const FOOD_COMPETITION_RANGE = 150; // If large fish is this close to food
                        fish.forEach(other => {
                            if (other.id === f.id) return;
                            const otherBw = other.bodyWidth || 20;
                            if (otherBw < MEDIUM_THRESHOLD) return; // Only check large fish

                            // Check if large fish is close to this food
                            const largeFoodDist = Math.sqrt((other.x - nearestFood.x) ** 2 + (other.y - nearestFood.y) ** 2);
                            if (largeFoodDist < FOOD_COMPETITION_RANGE) {
                                // Check if large fish is heading toward food (not away)
                                const largeToFoodAngle = Math.atan2(nearestFood.y - other.y, nearestFood.x - other.x);
                                const largeAngleDiff = Math.abs(angleDiff(largeToFoodAngle, other.heading));
                                if (largeAngleDiff < Math.PI * 0.6) { // Large fish is facing food
                                    largeFishCompeting = other;
                                }
                            }
                        });
                    }

                    // If large fish is competing, medium fish flees instead of seeking
                    if (largeFishCompeting) {
                        f.state = 'fleeing';
                        f.stateChangeCooldown = 2000;
                        f.fleeTimer = 1500; // INCREASED from 1000 - flee longer
                        // Flee away from the large fish (not the food)
                        const fleeAngle = Math.atan2(f.y - largeFishCompeting.y, f.x - largeFishCompeting.x);
                        f.targetHeading = fleeAngle;
                        f.heading = fleeAngle; // INSTANT turn toward escape
                        f.committedHeading = fleeAngle; // Commit to flee direction
                        f.reversalPressure = 0;
                        f.debugFoodTarget = null;
                        // IMMEDIATE velocity kick in flee direction
                        const kickSpeed = 3.0;
                        f.vx = Math.cos(fleeAngle) * kickSpeed;
                        f.vy = Math.sin(fleeAngle) * kickSpeed;
                    }
                    // UNREACHABLE FOOD DETECTION: If food is behind us (>100 degrees) for too long, give up
                    // Reduced timeout to 800ms - fish should turn faster now with heading commitment bypass
                    else if (angleToFood > Math.PI * 0.55) {
                        f.unreachableFoodTimer = (f.unreachableFoodTimer || 0) + deltaTime;
                        if (f.unreachableFoodTimer > 800) {
                            // Give up on this food
                            f.ignoreFoodId = nearestFood.id;
                            f.unreachableFoodTimer = 0;
                        }
                    } else {
                        f.unreachableFoodTimer = 0;
                    }

                    // Don't seek food we're ignoring (and not fleeing from large fish)
                    if (!largeFishCompeting && f.ignoreFoodId === nearestFood.id) {
                        // Skip this food, check for others
                    } else if (!largeFishCompeting) {
                        f.state = 'seeking';
                        // Store food target for debug visualization
                        f.debugFoodTarget = { x: nearestFood.x, y: nearestFood.y };

                        // SMOOTH: Blend toward food, don't snap
                        // INCREASED blend strength for better food tracking
                        const foodBlendStrength = isMedium ? 0.18 : 0.14; // Further increased
                        f.targetHeading += angleDiff(foodAngle, f.targetHeading) * foodBlendStrength;
                    }

                    if (nearestMouthDist < sizeEatRange && f.ignoreFoodId !== nearestFood.id) {
                        const idx = food.indexOf(nearestFood);
                        if (idx !== -1) {
                            food.splice(idx, 1);
                            for (let i = 0; i < 5; i++) {
                                const a = (i / 5) * Math.PI * 2;
                                particles.push({
                                    x: nearestFood.x, y: nearestFood.y,
                                    vx: Math.cos(a) * 0.8, vy: Math.sin(a) * 0.8,
                                    life: 1, createdAt: now
                                });
                            }
                        }
                        f.state = 'idle';
                    }
                }
                // ---- FLEEING STATE: Active escape with goal completion ----
                else if (f.state === 'fleeing' && f.fleeTimer > 0) {
                    if (isSmall) {
                        // Small fish: Continuously steer toward coral while fleeing
                        let nearestCoral = null;
                        let nearestCoralDist = Infinity;
                        coral.forEach(c => {
                            if (!c.settled) return;
                            const d = Math.sqrt((c.x - f.x) ** 2 + (c.y - f.y) ** 2);
                            if (d < nearestCoralDist) {
                                nearestCoralDist = d;
                                nearestCoral = c;
                            }
                        });

                        if (nearestCoral) {
                            const coralH = nearestCoral.shape?.height || 60;
                            const coralW = (nearestCoral.shape?.width || 50) * 0.5;
                            const safeY = nearestCoral.y - coralH * 0.5;

                            // Continuously update heading toward coral
                            const fleeAngle = Math.atan2(safeY - f.y, nearestCoral.x - f.x);
                            f.targetHeading += angleDiff(fleeAngle, f.targetHeading) * 0.06;

                            // COMPLETION: Check if inside coral zone
                            const inCoral = Math.abs(f.x - nearestCoral.x) < coralW * 1.5 &&
                                           f.y > nearestCoral.y - coralH - 20;
                            if (inCoral) {
                                // Reached safety! Enter hiding state
                                f.state = 'hiding';
                                f.hideTimer = 2000; // Hide for 2 seconds
                                f.fleeTimer = 0;
                                f.isReturningToCoral = false;
                                f.fleeTowardCoral = false;
                            }
                        }
                    } else if (isMedium) {
                        // Medium fish: Check if far enough from threat
                        // (Continue fleeing in scatter direction)
                    }
                    // Timer still decrements as backup exit
                }
                // ---- HIDING STATE: Small fish resting in coral after fleeing ----
                else if (f.state === 'hiding' && isSmall) {
                    f.hideTimer = (f.hideTimer || 0) - deltaTime;
                    // Stay very still
                    f.targetHeading = f.heading; // Don't turn
                    f.currentSpeed = IDLE_SPEED * 0.1; // Almost stopped

                    if (f.hideTimer <= 0) {
                        f.state = 'idle';
                    }
                }
                // ---- HUNTING STATE (persists until timer expires or prey eaten/lost) ----
                else if (f.state === 'hunting' && f.huntTimer > 0 && isLarge) {
                    const prey = fish.find(p => p.id === f.huntTarget);
                    if (prey) {
                        const preyDist = Math.sqrt((prey.x - f.x) ** 2 + (prey.y - f.y) ** 2);
                        const huntAngle = Math.atan2(prey.y - f.y, prey.x - f.x);
                        // BLEND toward prey instead of snapping
                        f.targetHeading += angleDiff(huntAngle, f.targetHeading) * 0.06;

                        // Check if close enough to eat
                        const EAT_PREY_RANGE = 30;
                        if (preyDist < EAT_PREY_RANGE) {
                            const preyIdx = fish.findIndex(p => p.id === prey.id);
                            if (preyIdx !== -1) {
                                fish.splice(preyIdx, 1);
                                f.lastAteAt = now;
                                for (let i = 0; i < 8; i++) {
                                    const a = (i / 8) * Math.PI * 2;
                                    particles.push({
                                        x: prey.x, y: prey.y,
                                        vx: Math.cos(a) * 1.5, vy: Math.sin(a) * 1.5,
                                        life: 1, createdAt: now
                                    });
                                }
                            }
                            f.state = 'idle';
                            f.huntTarget = null;
                            f.huntTimer = 0;
                        }
                    } else {
                        // Prey gone, stop hunting
                        f.state = 'idle';
                        f.huntTarget = null;
                        f.huntTimer = 0;
                    }
                }
                // ---- CHALLENGING STATE: Large fish dominance display (advance toward rival) ----
                else if (f.state === 'challenging' && f.challengeTimer > 0 && isLarge) {
                    const rival = fish.find(p => p.id === f.rivalId);
                    if (rival) {
                        const rivalDist = Math.sqrt((rival.x - f.x) ** 2 + (rival.y - f.y) ** 2);

                        // COMPLETION: If rival is retreating and far enough, we won
                        if (rival.state === 'retreating' && rivalDist > 150) {
                            f.state = 'idle';
                            // PHASE 12: Winner also remembers position to move away
                            f.lastRivalPos = { x: rival.x, y: rival.y };
                            f.rivalId = null;
                            f.lastChallengeTime = now; // Start cooldown
                        } else {
                            // Continue advancing toward rival
                            const rivalAngle = Math.atan2(rival.y - f.y, rival.x - f.x);
                            f.targetHeading += angleDiff(rivalAngle, f.targetHeading) * 0.05;
                        }
                    } else {
                        f.state = 'idle';
                        f.rivalId = null;
                        f.lastChallengeTime = now;
                    }
                }
                // ---- RETREATING STATE: Large fish yielding to dominant rival ----
                else if (f.state === 'retreating' && f.fleeTimer > 0 && isLarge) {
                    const rival = fish.find(p => p.id === f.rivalId);
                    if (rival) {
                        const rivalDist = Math.sqrt((rival.x - f.x) ** 2 + (rival.y - f.y) ** 2);

                        // COMPLETION: If far enough from rival, safe to stop retreating
                        if (rivalDist > 250) {
                            f.state = 'idle';
                            // PHASE 12: Add ignore period to prevent re-triggering
                            f.ignoreRivalId = f.rivalId;
                            f.ignoreRivalUntil = now + 8000;  // Ignore for 8 seconds
                            f.lastRivalPos = { x: rival.x, y: rival.y };  // Remember position
                            f.rivalId = null;
                            f.fleeTimer = 0;
                        } else {
                            // Keep retreating away from rival
                            const retreatAngle = Math.atan2(f.y - rival.y, f.x - rival.x);
                            f.targetHeading += angleDiff(retreatAngle, f.targetHeading) * 0.04;
                        }
                    } else {
                        f.state = 'idle';
                        f.rivalId = null;
                    }
                }
                // ---- IDLE STATE: Check for threats and behaviors ----
                else {
                    // If we just finished fleeing, add brief cooldown to prevent immediate re-trigger
                    if (f.state === 'fleeing' || f.state === 'retreating') {
                        f.stateChangeCooldown = Math.max(f.stateChangeCooldown || 0, 1500);
                    }
                    f.state = 'idle';

                    // ---- LARGE FISH: Tuna-like territorial behavior ----
                    if (isLarge) {
                        const TERRITORY_RANGE = 100;  // REDUCED - must be close to trigger challenge
                        const HUNT_RANGE = 120;       // REDUCED - don't chase prey from far away
                        const DISPERSE_RANGE = 80;    // REDUCED - scatter range for medium fish

                        let rival = null;
                        let rivalDist = Infinity;
                        let prey = null;
                        let preyDist = Infinity;

                        // Scan for other fish
                        fish.forEach(other => {
                            if (other.id === f.id) return;
                            const otherBw = other.bodyWidth || 20;
                            const dx = other.x - f.x;
                            const dy = other.y - f.y;
                            const d = Math.sqrt(dx * dx + dy * dy);

                            // Check for rival large fish
                            // PHASE 12: Skip ignored rivals (recently retreated from)
                            const isIgnored = f.ignoreRivalId === other.id && f.ignoreRivalUntil && now < f.ignoreRivalUntil;
                            if (!isIgnored && otherBw >= MEDIUM_THRESHOLD && d < TERRITORY_RANGE && d < rivalDist) {
                                rival = other;
                                rivalDist = d;
                            }

                            // Check for small fish prey
                            if (otherBw < SMALL_THRESHOLD && d < HUNT_RANGE && d < preyDist) {
                                prey = other;
                                preyDist = d;
                            }
                        });

                        // Priority 1: Territorial challenge with rival large fish
                        // ONLY if canChangeState (prevents rapid state flipping)
                        if (rival && canChangeState) {
                            const rivalDominance = rival.dominance || rival.bodyWidth || 20;

                            // Check challenge cooldown (5 seconds between challenges)
                            const CHALLENGE_COOLDOWN = 5000;
                            const canChallenge = !f.lastChallengeTime || (now - f.lastChallengeTime > CHALLENGE_COOLDOWN);

                            // ASYMMETRY FIX: If rival is already challenging ME, I MUST retreat
                            const rivalIsChallengingMe = rival.state === 'challenging' && rival.rivalId === f.id;

                            if (rivalIsChallengingMe) {
                                // Rival got there first - I retreat
                                f.state = 'retreating';
                                f.stateChangeCooldown = 2000;  // Can't change state for 2s
                                f.rivalId = rival.id;
                                f.fleeTimer = 2000;
                                const retreatAngle = Math.atan2(f.y - rival.y, f.x - rival.x);
                                f.targetHeading = retreatAngle;
                            } else if (f.dominance > rivalDominance && canChallenge) {
                                // I'm dominant and can challenge - advance
                                f.state = 'challenging';
                                f.stateChangeCooldown = 2000;
                                f.rivalId = rival.id;
                                f.challengeTimer = 1500;
                                const challengeAngle = Math.atan2(rival.y - f.y, rival.x - f.x);
                                f.targetHeading = challengeAngle;
                            } else if (f.dominance <= rivalDominance) {
                                // I'm submissive - retreat immediately
                                f.state = 'retreating';
                                f.stateChangeCooldown = 2000;
                                f.rivalId = rival.id;
                                f.fleeTimer = 2000;
                                const retreatAngle = Math.atan2(f.y - rival.y, f.x - rival.x);
                                f.targetHeading = retreatAngle;
                            }
                            // If on cooldown, just avoid (handled by separation forces)
                        }
                        // Priority 2: Hunt small fish (only if canChangeState)
                        else if (prey && canChangeState) {
                            f.state = 'hunting';
                            f.stateChangeCooldown = 3000;  // Commit to hunting for 3s
                            f.huntTarget = prey.id;
                            f.huntTimer = 2500 + energy * 1500;
                            const huntAngle = Math.atan2(prey.y - f.y, prey.x - f.x);
                            f.targetHeading = huntAngle;
                        }
                        // Priority 3: Cruise/patrol (tuna-like steady swimming)
                        else {
                            // Tuna cruise in relatively straight lines, changing direction slowly
                            f.cruiseTimer = (f.cruiseTimer || 0) - deltaTime;

                            // Initialize cruiseAngle if not set
                            if (f.cruiseAngle === undefined) {
                                f.cruiseAngle = f.heading;
                            }

                            // Check if current turn is complete (within 30° of target)
                            const turnComplete = Math.abs(angleDiff(f.cruiseAngle, f.heading)) < Math.PI / 6;

                            // Force new direction if near edges (prevents getting stuck)
                            const nearLeftEdge = f.x < w * 0.2;
                            const nearRightEdge = f.x > w * 0.8;
                            const nearTopEdge = f.y < h * 0.15;
                            const nearBottomEdge = f.y > h * 0.6;

                            // Edge emergency: must change direction even mid-turn
                            const edgeEmergency = (nearLeftEdge && Math.cos(f.cruiseAngle) < -0.3) ||
                                                  (nearRightEdge && Math.cos(f.cruiseAngle) > 0.3);

                            // Only pick new direction when turn is COMPLETE (prevents snap)
                            // Exception: edge emergencies override this
                            if ((f.cruiseTimer <= 0 && turnComplete) || edgeEmergency) {

                                f.cruiseTimer = 10000 + Math.random() * 6000;

                                // Pick direction AWAY from nearby edges
                                let baseAngle;
                                if (nearRightEdge) {
                                    baseAngle = Math.PI;  // Head left
                                } else if (nearLeftEdge) {
                                    baseAngle = 0;  // Head right
                                } else {
                                    // In middle — keep roughly same left/right direction but
                                    // add enough vertical angle to avoid snapping back to 0/π
                                    // and triggering turnComplete immediately again
                                    const currentDir = Math.cos(f.heading) > 0 ? 0 : Math.PI;
                                    // Diagonal sweep: ±20-50° off horizontal so fish swims on an angle
                                    const sweep = (Math.random() * 0.5 + 0.35) * (Math.random() < 0.5 ? 1 : -1);
                                    baseAngle = currentDir + sweep;
                                }

                                // Add vertical adjustment based on position
                                if (nearTopEdge) {
                                    baseAngle += 0.4; // Bias downward
                                } else if (nearBottomEdge) {
                                    baseAngle -= 0.4; // Bias upward
                                }

                                f.cruiseAngle = baseAngle;
                            }

                            // Steer toward cruise angle smoothly
                            // STRONGER steering force to maintain cruise direction
                            const cruiseSteer = angleDiff(f.cruiseAngle, f.heading) * 0.06;
                            f.targetHeading += cruiseSteer;

                            // Also commit heading to cruise angle to reduce wobble from other forces
                            if (Math.abs(angleDiff(f.cruiseAngle, f.committedHeading || f.heading)) < Math.PI * 0.5) {
                                f.committedHeading = f.heading + cruiseSteer;
                            }
                        }
                    }

                    // ---- SMALL FISH: Flee from predators TOWARD CORAL ----
                    // Add cooldown check to prevent rapid flee-idle-flee oscillation
                    if (isSmall && f.state === 'idle' && canChangeState) {
                        let predator = null;
                        let predatorDist = Infinity;
                        // Two zones: close range triggers always, far range only if predator facing us
                        const DANGER_RANGE_CLOSE = 100; // Always flee if this close
                        const DANGER_RANGE_FAR = 220;   // Only flee if predator facing us

                        fish.forEach(other => {
                            if (other.id === f.id) return;
                            const otherBw = other.bodyWidth || 20;
                            if (otherBw < MEDIUM_THRESHOLD) return;

                            const dx = other.x - f.x;
                            const dy = other.y - f.y;
                            const d = Math.sqrt(dx * dx + dy * dy);
                            if (d > DANGER_RANGE_FAR) return;

                            // Always react if very close
                            if (d < DANGER_RANGE_CLOSE) {
                                if (d < predatorDist) { predator = other; predatorDist = d; }
                                return;
                            }

                            // Farther away: only react if predator is facing toward us (within 90°)
                            const angleToMe = Math.atan2(-dy, -dx); // Angle from predator to me
                            const facingDiff = Math.abs(angleDiff(angleToMe, other.heading || 0));
                            if (facingDiff < Math.PI * 0.5 && d < predatorDist) {
                                predator = other;
                                predatorDist = d;
                            }
                        });

                        if (predator) {
                            f.state = 'fleeing';
                            f.stateChangeCooldown = 2000; // Can't change state for 2s after fleeing
                            f.fleeTimer = 1500 + nervousness * 1000;

                            // Find nearest coral and flee TOWARD it (safe haven)
                            let nearestCoral = null;
                            let nearestCoralDist = Infinity;
                            coral.forEach(c => {
                                if (!c.settled) return;
                                const d = Math.sqrt((c.x - f.x) ** 2 + (c.y - f.y) ** 2);
                                if (d < nearestCoralDist) {
                                    nearestCoralDist = d;
                                    nearestCoral = c;
                                }
                            });

                            if (nearestCoral && nearestCoralDist < 400) {
                                // Flee toward coral (safety) - NO random, direct path
                                const coralH = nearestCoral.shape?.height || 60;
                                const safeY = nearestCoral.y - coralH * 0.5;
                                const fleeAngle = Math.atan2(safeY - f.y, nearestCoral.x - f.x);
                                f.targetHeading = fleeAngle;
                                f.fleeTowardCoral = true; // Flag for edge avoidance
                            } else {
                                // No coral nearby, flee away from predator and down
                                const fleeAngle = Math.atan2(f.y - predator.y, f.x - predator.x);
                                // Bias toward bottom of screen where coral usually is
                                const biasedAngle = fleeAngle * 0.6 + (Math.PI * 0.5) * 0.4;
                                f.targetHeading = biasedAngle;
                                f.fleeTowardCoral = false;
                            }
                        }
                    }

                    // ---- MEDIUM FISH: Scatter from large fish ----
                    // Two-zone: always flee when very close, facing check required at medium range
                    if (isMedium && f.state === 'idle' && canChangeState) {
                        let threat = null;
                        let threatDist = Infinity;
                        const SCATTER_CLOSE = 110;  // Always scatter regardless of facing
                        const SCATTER_FAR  = 200;   // Only scatter if large fish is facing us

                        fish.forEach(other => {
                            if (other.id === f.id) return;
                            const otherBw = other.bodyWidth || 20;
                            if (otherBw < MEDIUM_THRESHOLD) return;

                            const dx = other.x - f.x;
                            const dy = other.y - f.y;
                            const d = Math.sqrt(dx * dx + dy * dy);
                            if (d >= SCATTER_FAR) return;

                            if (d < SCATTER_CLOSE) {
                                // Always a threat when very close
                                if (d < threatDist) { threat = other; threatDist = d; }
                            } else {
                                // Far zone: only if large fish is facing us
                                const angleToMe = Math.atan2(-dy, -dx);
                                const facingDiff = Math.abs(angleDiff(angleToMe, other.heading || 0));
                                if (facingDiff < Math.PI * 0.45 && d < threatDist) {
                                    threat = other; threatDist = d;
                                }
                            }
                        });

                        if (threat) {
                            f.state = 'fleeing';
                            f.stateChangeCooldown = 1800; // Can't change state for 1.8s after scattering
                            f.fleeTimer = 1400 + nervousness * 800; // Scatter for 1.4-2.2 seconds
                            // Scatter away from threat - direct escape
                            const scatterAngle = Math.atan2(f.y - threat.y, f.x - threat.x);
                            f.targetHeading = scatterAngle;
                            f.heading = scatterAngle; // INSTANT turn
                            f.committedHeading = scatterAngle;
                            f.reversalPressure = 0;
                            // IMMEDIATE velocity kick - stronger than before
                            const kickSpeed = 3.2;
                            f.vx = Math.cos(scatterAngle) * kickSpeed;
                            f.vy = Math.sin(scatterAngle) * kickSpeed;
                        }
                    }

                    // ---- WANDER SYSTEM (only if still idle) ----
                    if (f.state === 'idle') {
                        // ---- MEDIUM FISH: Formation-based schooling ----
                        if (isMedium) {
                            // Assign stable formation slot if not already assigned
                            if (f.formationSlot === undefined) {
                                // Count existing medium fish to determine slot
                                let slotIndex = 0;
                                fish.forEach(other => {
                                    if (other.id < f.id) {
                                        const otherBw = other.bodyWidth || 20;
                                        if (otherBw >= SMALL_THRESHOLD && otherBw < MEDIUM_THRESHOLD) {
                                            slotIndex++;
                                        }
                                    }
                                });
                                f.formationSlot = slotIndex;
                            }

                            // Formation offsets - V-shape behind leader
                            // WIDER spacing to prevent collisions and spinning
                            const formationOffsets = [
                                { x: 0, y: 0 },           // Leader
                                { x: -45, y: 35 },        // Left wing 1 (was -30, 25)
                                { x: -45, y: -35 },       // Right wing 1 (was -30, -25)
                                { x: -85, y: 60 },        // Left wing 2 (was -55, 45)
                                { x: -85, y: -60 },       // Right wing 2 (was -55, -45)
                                { x: -120, y: 30 },       // Back left (was -80, 20)
                                { x: -120, y: -30 },      // Back right (was -80, -20)
                                { x: -150, y: 0 },        // Tail (was -100, 0)
                            ];

                            const slot = f.formationSlot % formationOffsets.length;
                            const offset = formationOffsets[slot];

                            // Calculate school heading (direction school is moving)
                            const schoolHeading = this.schoolHeading || 0;

                            // Rotate offset by school heading
                            const cos = Math.cos(schoolHeading);
                            const sin = Math.sin(schoolHeading);
                            const rotatedOffsetX = offset.x * cos - offset.y * sin;
                            const rotatedOffsetY = offset.x * sin + offset.y * cos;

                            // Target position = school target + rotated formation offset
                            // Clamp formation targets to safe zone so fish don't get pushed to edges
                            const FORM_SAFE_MARGIN = 80; // Keep formation slots this far from canvas edges
                            const target = this.schoolTarget || { x: w * 0.5, y: h * 0.45 };
                            const myTargetX = Math.max(FORM_SAFE_MARGIN, Math.min(w - FORM_SAFE_MARGIN, target.x + rotatedOffsetX));
                            const myTargetY = Math.max(FORM_SAFE_MARGIN, Math.min(h - FORM_SAFE_MARGIN, target.y + rotatedOffsetY));

                            // Store for debug
                            f.debugFormationTarget = { x: myTargetX, y: myTargetY, slot: slot };

                            const dx = myTargetX - f.x;
                            const dy = myTargetY - f.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            // ---- UNIFIED SCHOOL HEADING ----
                            // ALL medium fish follow the SAME school heading
                            // Position correction is secondary and very gentle

                            // PRIMARY: Match school heading (this is what makes them move together)
                            f.targetHeading += angleDiff(schoolHeading, f.targetHeading) * 0.04;

                            // ---- PHASE 7: Dynamic Leadership ----
                            // Non-leaders also blend toward the current leader's heading
                            // This creates more organic, flowing movement
                            const leader = this.schoolLeader;
                            if (leader && leader.id !== f.id && leader.heading !== undefined) {
                                // Blend toward leader's heading (gentle influence)
                                f.targetHeading += angleDiff(leader.heading, f.targetHeading) * 0.015;
                                f.debugIsLeader = false;
                            } else if (leader && leader.id === f.id) {
                                f.debugIsLeader = true;
                            }

                            // ---- SCHOOL COHESION: Always pull toward global school center ----
                            // Use the smoothed global school center (not per-fish neighbor average).
                            // Per-fish cohesion breaks down when fish are farther than perception range —
                            // they end up with medCohCount=0 and just swim in parallel forever.
                            // Global center is always known regardless of inter-fish distance.
                            const distToSchoolCenter = Math.sqrt(
                                (schoolCenterX - f.x)**2 + (schoolCenterY - f.y)**2
                            );

                            // ---- REGROUPING BURST: When far from school, override heading to regroup ----
                            const REGROUP_THRESHOLD = 80;   // Trigger burst this far from school center
                            const CRITICAL_THRESHOLD = 150; // Emergency: fully commit heading to regroup

                            // SECONDARY: Gentle drift toward formation slot (suppressed during regroup)
                            // When far from school center, skip slot correction — regrouping takes full priority
                            const slotAngle = Math.atan2(dy, dx);
                            const slotAngleDiff = Math.abs(angleDiff(slotAngle, schoolHeading));
                            const farFromSchool = distToSchoolCenter > REGROUP_THRESHOLD;

                            if (!farFromSchool && slotAngleDiff < Math.PI * 0.5 && dist > 40) {
                                // Slot is ahead of us and we're close to school - gentle correction
                                f.targetHeading += angleDiff(slotAngle, f.targetHeading) * 0.01;
                            }
                            // If regrouping or slot is behind us, skip - getting back to school first

                            let regroupingBurst = false;

                            if (distToSchoolCenter > REGROUP_THRESHOLD) {
                                regroupingBurst = true;
                                const cohAngle = Math.atan2(schoolCenterY - f.y, schoolCenterX - f.x);

                                if (distToSchoolCenter > CRITICAL_THRESHOLD) {
                                    // Emergency: ignore school heading, rush directly back
                                    f.targetHeading = cohAngle; // Full override
                                    f.committedHeading = cohAngle;
                                    f.reversalPressure = 0;
                                } else {
                                    // Strong pull — urgency scales 0→1 over the threshold range
                                    const cohUrgency = (distToSchoolCenter - REGROUP_THRESHOLD) / (CRITICAL_THRESHOLD - REGROUP_THRESHOLD);
                                    const cohStrength = 0.10 + cohUrgency * 0.15; // 0.10–0.25
                                    f.targetHeading += angleDiff(cohAngle, f.targetHeading) * cohStrength;
                                }
                            } else if (distToSchoolCenter > 35) {
                                // Gentle maintenance cohesion when close — prevents drift
                                const cohAngle = Math.atan2(schoolCenterY - f.y, schoolCenterX - f.x);
                                const cohUrgency = (distToSchoolCenter - 35) / (REGROUP_THRESHOLD - 35);
                                const cohStrength = 0.015 + cohUrgency * 0.025; // 0.015–0.04
                                f.targetHeading += angleDiff(cohAngle, f.targetHeading) * cohStrength;
                            }

                            // Soft velocity alignment with nearby school members (local, short range)
                            let medAlignVx = 0, medAlignVy = 0, medAlignCount = 0;
                            fish.forEach(other => {
                                if (other.id === f.id) return;
                                const otherBw = other.bodyWidth || 20;
                                if (otherBw < SMALL_THRESHOLD || otherBw >= MEDIUM_THRESHOLD) return;
                                const odx = other.x - f.x;
                                const ody = other.y - f.y;
                                const od = Math.sqrt(odx * odx + ody * ody);
                                if (od < 200 && od > 0) {
                                    medAlignVx += other.vx || 0;
                                    medAlignVy += other.vy || 0;
                                    medAlignCount++;
                                }
                            });
                            if (medAlignCount > 0) {
                                const avgAngle = Math.atan2(medAlignVy / medAlignCount, medAlignVx / medAlignCount);
                                f.targetHeading += angleDiff(avgAngle, f.targetHeading) * 0.008;
                            }

                            // Speed based on distance (faster to catch up, slower when in position)
                            // REGROUPING BURST: Speed scales with how far we are from school center
                            let speedMod;
                            if (regroupingBurst) {
                                // Scale from 1.75× at threshold to 2.5× at critical and beyond
                                const regroupUrgency = Math.min(1, (distToSchoolCenter - REGROUP_THRESHOLD) / (CRITICAL_THRESHOLD - REGROUP_THRESHOLD));
                                speedMod = 1.75 + regroupUrgency * 0.75; // 1.75→2.5
                            } else {
                                speedMod = dist < 20 ? 0.6 : (dist < 50 ? 0.85 : (dist < 100 ? 1.0 : 1.15));
                            }

                            // FOOD SLOWDOWN: Reduce speed when school is approaching food
                            let foodSpeedMod = 1.0;
                            if (this.schoolTargetReason === 'food' && this.schoolTarget) {
                                const distToFood = Math.sqrt(
                                    (f.x - this.schoolTarget.x) ** 2 +
                                    (f.y - this.schoolTarget.y) ** 2
                                );
                                if (distToFood < 100) {
                                    // Slow down to 50-100% based on proximity
                                    foodSpeedMod = 0.5 + (distToFood / 100) * 0.5;
                                }
                            }

                            f.currentSpeed = IDLE_SPEED * speedMod * foodSpeedMod;
                        } else {
                            // ---- SMALL and LARGE fish: Use wanderTimer system ----
                            f.wanderTimer = (f.wanderTimer || 0) - deltaTime;
                            f.restTimer = (f.restTimer || 0) - deltaTime;

                            // Rest behavior - fish slows down and holds position
                            if (f.restTimer > 0) {
                                f.currentSpeed = IDLE_SPEED * 0.2;
                                // NO random jitter - fish rests calmly
                            } else {
                                if (Math.random() < 0.0005 * (1 - energy)) {
                                    f.restTimer = 2000 + Math.random() * 3000;
                                }
                                f.currentSpeed = IDLE_SPEED * (0.7 + energy * 0.6);
                            }

                            // Pick new wander target with BEHAVIOR LOCKING
                            // Small fish lock into behavior for minimum time to prevent oscillation
                            f.behaviorLockTimer = (f.behaviorLockTimer || 0) - deltaTime;

                            // Check if we need a new target AND lock has expired
                            const needsNewTarget = !f.wanderTarget || f.wanderTimer <= 0;
                            const lockExpired = f.behaviorLockTimer <= 0;

                            if (needsNewTarget && lockExpired) {
                                // 6-12 seconds between wander target changes
                                f.wanderTimer = 6000 + Math.random() * 6000 * (1 - curiosity * 0.5);

                                if (isSmall) {
                                    let targetX, targetY;
                                    let behaviorType = 'coral_deep'; // For debug

                                    // Find home coral for this fish
                                    let homeCoral = null;
                                    let homeCoralDist = Infinity;
                                    coral.forEach(c => {
                                        if (!c.settled) return;
                                        const d = Math.sqrt((c.x - f.x) ** 2 + (c.y - f.y) ** 2);
                                        if (d < homeCoralDist) {
                                            homeCoralDist = d;
                                            homeCoral = c;
                                        }
                                    });

                                    if (homeCoral) {
                                        const coralW = (homeCoral.shape?.width || 50) * 0.5;
                                        const coralH = homeCoral.shape?.height || 60;
                                        const coralTop = homeCoral.y - coralH;

                                        // EXPANDED coral zone check (prevents frequent teleporting)
                                        // Horizontal: within 3x coral width (was 2x)
                                        // Vertical: above coral base, below coral top + 80px buffer (was 50px)
                                        const horizontallyNear = Math.abs(f.x - homeCoral.x) < coralW * 3;
                                        const verticallyNear = f.y > coralTop - 80 && f.y < homeCoral.y + 50;
                                        const inCoralZone = horizontallyNear && verticallyNear;

                                        // Track if we're actively returning (for edge avoidance priority)
                                        const wasReturning = f.debugBehavior === 'returning';

                                        // If currently OUTSIDE coral, always go back IN (no exploring)
                                        // This prevents the out-flip-in-flip loop
                                        if (!inCoralZone) {
                                            behaviorType = 'returning';
                                            // Target DEEP inside coral, not edge
                                            const xOffset = (Math.random() - 0.5) * coralW * 0.4;
                                            const yOffset = coralH * 0.4 + Math.random() * coralH * 0.3;
                                            targetX = homeCoral.x + xOffset;
                                            targetY = homeCoral.y - yOffset;
                                            // LONG lock when returning - must reach coral
                                            f.behaviorLockTimer = 5000 + Math.random() * 3000;
                                            // Mark fish as returning (for edge avoidance to respect)
                                            f.isReturningToCoral = true;
                                        } else {
                                            // Successfully in coral zone
                                            f.isReturningToCoral = false;
                                            // Currently IN coral zone - can pick behavior
                                            const behaviorRoll = Math.random();

                                            if (behaviorRoll < 0.75) {
                                                // 75%: Stay DEEP in coral
                                                behaviorType = 'coral_deep';
                                                const xOffset = (Math.random() - 0.5) * coralW * 0.8;
                                                const yOffset = coralH * 0.2 + Math.random() * coralH * 0.5;
                                                targetX = homeCoral.x + xOffset;
                                                targetY = homeCoral.y - yOffset;
                                                f.behaviorLockTimer = 3000 + Math.random() * 2000;
                                            } else if (behaviorRoll < 0.95) {
                                                // 20%: Venture to coral edge/top
                                                behaviorType = 'coral_edge';
                                                const edgeRoll = Math.random();
                                                if (edgeRoll < 0.5) {
                                                    targetX = homeCoral.x + (Math.random() - 0.5) * coralW;
                                                    targetY = homeCoral.y - coralH - 10 - Math.random() * 15;
                                                } else {
                                                    const side = Math.random() < 0.5 ? -1 : 1;
                                                    targetX = homeCoral.x + side * (coralW + 8);
                                                    targetY = homeCoral.y - coralH * 0.4;
                                                }
                                                // Lock into venture behavior
                                                f.behaviorLockTimer = 2500 + Math.random() * 1500;
                                            } else {
                                                // 5%: Explore toward another coral
                                                behaviorType = 'exploring';
                                                if (coral.length > 1) {
                                                    const otherCorals = coral.filter(c => c !== homeCoral && c.settled);
                                                    if (otherCorals.length > 0) {
                                                        const destCoral = otherCorals[Math.floor(Math.random() * otherCorals.length)];
                                                        const destH = destCoral.shape?.height || 60;
                                                        targetX = destCoral.x + (Math.random() - 0.5) * 30;
                                                        targetY = destCoral.y - destH * 0.5;
                                                    } else {
                                                        targetX = homeCoral.x;
                                                        targetY = homeCoral.y - coralH * 0.5;
                                                    }
                                                } else {
                                                    targetX = homeCoral.x + (Math.random() - 0.5) * coralW;
                                                    targetY = homeCoral.y - coralH - 5;
                                                }
                                                f.behaviorLockTimer = 5000 + Math.random() * 3000;
                                            }
                                        }

                                        f.debugBehavior = behaviorType;
                                    } else {
                                        // No coral exists, wander in lower area
                                        targetX = w * 0.2 + Math.random() * w * 0.6;
                                        targetY = h * 0.7 + Math.random() * h * 0.2;
                                    }
                                    f.wanderTarget = { x: targetX, y: targetY };
                                }
                                // Large fish use cruise behavior (handled above), not wander targets
                            }

                            // Swim toward wander target (small fish only)
                            if (f.wanderTarget && isSmall) {
                                const dx = f.wanderTarget.x - f.x;
                                const dy = f.wanderTarget.y - f.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);

                                if (dist < 40) {
                                    // Near target, slow down and linger
                                    f.wanderTimer = Math.min(f.wanderTimer, 2000);
                                } else {
                                    const wanderAngle = Math.atan2(dy, dx);
                                    const turnRate = 0.015 + energy * 0.015;
                                    f.targetHeading += angleDiff(wanderAngle, f.heading) * turnRate;
                                }
                            }
                        }

                        // No random wobble - swimming animation handles movement
                    }
                }

                // ---- Store size category for debug ----
                let sizeCategory;
                if (isSmall) sizeCategory = 'small';
                else if (isMedium) sizeCategory = 'medium';
                else sizeCategory = 'large';
                f.sizeCategory = sizeCategory;

                // ---- Fish collision and separation based on OVAL body shape ----
                // TIERED BUFFERS: Like edge avoidance, we use multiple zones
                // 1. Comfort zone (outer) - gentle early steering
                // 2. Buffer zone (middle) - moderate steering
                // 3. Emergency zone (overlapping) - strong steering + push

                // Oval dimensions (half-widths) for collision detection.
                // The nose extends noseOffset ahead of center - we add half that to the forward
                // radius so head-on encounters register before noses visually overlap.
                const fNoseOff = f.noseOffset || (f.bodyWidth || 20);
                const fWidthH = (f.bodyWidth || 20) + fNoseOff * 0.5; // Nose-aware forward reach
                const fHeightH = (f.bodyHeight || (f.bodyWidth || 20) * 0.4 || 8) * 1.4; // Perpendicular (tighter than before to avoid false positives side-by-side)

                // Helper: get oval radius in a given direction (relative to fish heading)
                function getOvalRadius(widthH, heightH, heading, dirAngle) {
                    const relAngle = dirAngle - heading;
                    const cos = Math.cos(relAngle);
                    const sin = Math.sin(relAngle);
                    return (widthH * heightH) / Math.sqrt((heightH * cos) ** 2 + (widthH * sin) ** 2);
                }

                // ---- SIMPLE MODE FOR LARGE FISH ----
                // When large fish are cruising (idle), skip most forces to prevent jitter
                const largeFishSimpleMode = isLarge && f.state === 'idle';

                // ---- PERFORMANCE: Reset debug collision array once per fish (reuse allocation) ----
                if (f.debugCollisions) { f.debugCollisions.length = 0; }
                else { f.debugCollisions = []; }

                let sepX = 0, sepY = 0;
                let alignVx = 0, alignVy = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohCount = 0;
                let inEmergencyCollision = false; // Set true if any emergency overlap detected this frame

                // ---- PHASE 1: Get MY perception ranges (size-based) ----
                // Use cached value set at spawn - bodyWidth never changes after creation
                const myPerception = f.percRanges || getPerceptionRanges(f.bodyWidth || 20);

                fish.forEach((other, oi) => {
                    if (oi === fi) return;
                    const dx = f.x - other.x;
                    const dy = f.y - other.y;
                    const d = Math.sqrt(dx * dx + dy * dy);
                    if (d === 0) return;

                    // PERFORMANCE: Early exit for fish beyond any interaction range
                    // Max interaction is cohesion range (~560px for large fish) * awareness (2.5) ≈ 1400px
                    // Using 600px as reasonable cutoff covers most interactions
                    const MAX_INTERACT_DIST = 600;
                    if (d > MAX_INTERACT_DIST) return;

                    const dirAngle = Math.atan2(dy, dx);

                    // Get other fish's size category FIRST (needed for collision gentling)
                    const otherBw = other.bodyWidth || 20;
                    let otherSize;
                    if (otherBw < SMALL_THRESHOLD) otherSize = 'small';
                    else if (otherBw < MEDIUM_THRESHOLD) otherSize = 'medium';
                    else otherSize = 'large';

                    // ---- PHASE 2: Cross-size awareness multiplier ----
                    // Smaller fish detect predators from farther away
                    const awarenessMultiplier = getAwarenessMultiplier(sizeCategory, otherSize);

                    // Effective perception ranges for this fish-other pair
                    const effectiveSepRange = myPerception.separation * awarenessMultiplier;
                    const effectiveAlignRange = myPerception.alignment * awarenessMultiplier;
                    const effectiveCohRange = myPerception.cohesion * awarenessMultiplier;

                    // Get oval radii — nose-aware for both fish.
                    // Forward radius accounts for nose overhang so head-on collisions
                    // register before noses visually overlap.
                    const fRadius = getOvalRadius(fWidthH, fHeightH, f.heading, dirAngle);
                    const otherNoseOff = other.noseOffset || otherBw;
                    const otherWidthH = otherBw + otherNoseOff * 0.5; // Nose-aware, matches fWidthH logic
                    const otherHeightH = (other.bodyHeight || otherBw * 0.4 || 8) * 1.4;
                    const otherRadius = getOvalRadius(otherWidthH, otherHeightH, other.heading, dirAngle + Math.PI);

                    const minDist = fRadius + otherRadius;
                    const comfortDist = minDist * 2.0;  // INCREASED from 1.6x for earlier steering
                    const emergencyDist = minDist * 0.8;  // NEW: Emergency zone for severe overlap

                    // ---- TIERED COLLISION RESPONSE ----
                    // Like edge avoidance, use multiple zones with increasing force
                    // ---- PHASE 6: Large fish now respond gently instead of skipping entirely ----

                    if (d < minDist) {
                        const overlap = minDist - d;
                        const avoidAngle = dirAngle; // Direction away from other fish

                        // SEEKING FOOD: Reduce collision avoidance so fish can actually eat
                        // When close to food target, prioritize eating over avoiding other fish
                        const seekingFood = f.state === 'seeking' && f.debugFoodTarget;
                        const closeToFood = seekingFood && f.debugFoodTarget &&
                            Math.sqrt((f.x - f.debugFoodTarget.x)**2 + (f.y - f.debugFoodTarget.y)**2) < 60;
                        const collisionReduction = closeToFood ? 0.3 : 1.0; // 70% reduction when near food

                        // Large fish in simple mode: position push ONLY — no heading change
                        // Heading nudges cause oscillation when cruise angle fights the correction
                        if (largeFishSimpleMode) {
                            const pushStrength = Math.min(2.5, overlap * 0.2) * collisionReduction;
                            f.x += (dx / d) * pushStrength;
                            f.y += (dy / d) * pushStrength;
                        } else {
                            // TIERED RESPONSE based on overlap severity
                            const bothMedium = isMedium && otherSize === 'medium';
                            const bothLarge = isLarge && otherSize === 'large';

                            if (d < emergencyDist && !closeToFood) {
                                // EMERGENCY: Severe overlap - strong steering + direct position push
                                // SKIP position push when close to food
                                inEmergencyCollision = true;
                                const emergencyStrength = (bothMedium ? 0.10 : 0.08) * collisionReduction;
                                f.targetHeading += angleDiff(avoidAngle, f.heading) * emergencyStrength;

                                // Emergency position nudge - SKIP when seeking food nearby
                                const pushStrength = bothMedium
                                    ? Math.min(3, overlap * 0.25)
                                    : Math.min(2, overlap * 0.15);
                                f.x += (dx / d) * pushStrength;
                                f.y += (dy / d) * pushStrength;
                            } else {
                                // BUFFER: Normal overlap - moderate steering
                                // Large-vs-large: halve the steer to reduce oscillation during challenge/retreat
                                const baseSteeer = bothMedium ? 0.06 : bothLarge ? 0.022 : 0.045;
                                const steerStrength = baseSteeer * collisionReduction;
                                const overlapFactor = Math.min(1.5, overlap / 15);
                                f.targetHeading += angleDiff(avoidAngle, f.heading) * steerStrength * (1 + overlapFactor);
                            }
                        }

                        // Store for debug
                        if (f.debugCollisions.length < 3) {
                            f.debugCollisions.push({ ox: other.x, oy: other.y, overlap: overlap });
                        }
                    }

                    // Soft separation - steering when in comfort zone (BEFORE overlap)
                    // Uses size-based separation range
                    // STRENGTHENED for medium fish to prevent bunching up
                    const bothMediumSep = isMedium && otherSize === 'medium';
                    const softSepRange = Math.max(comfortDist, effectiveSepRange);
                    if (d < softSepRange && d >= minDist) {
                        const strength = 1 - (d / softSepRange);
                        // Stronger multiplier for medium-medium to keep school spread
                        const forceMult = bothMediumSep ? 2.0 : ((d < comfortDist) ? 1.5 : 1.0);
                        sepX += (dx / d) * strength * forceMult;
                        sepY += (dy / d) * strength * forceMult;
                    }

                    // ---- LARGE FISH TERRITORIAL SEPARATION ----
                    // Large fish avoid each other at distance (territory) — capped to prevent jitter
                    if (isLarge && otherSize === 'large') {
                        const TERRITORY_DIST = myPerception.separation * 2.0; // ~400px (reduced from 2.5)
                        if (d < TERRITORY_DIST && d > softSepRange) {
                            const terStrength = (1 - d / TERRITORY_DIST) * 0.8; // Reduced from 2.0 — gentler drift apart
                            sepX += (dx / d) * terStrength;
                            sepY += (dy / d) * terStrength;
                        }
                    }

                    // Alignment and cohesion - school with SAME SIZE fish (NOT large fish - they're solitary)
                    // Uses size-based perception ranges with cross-size awareness
                    if (otherSize === sizeCategory && !isLarge) {
                        if (d < effectiveAlignRange && d > comfortDist) {
                            alignVx += other.vx;
                            alignVy += other.vy;
                            alignCount++;
                        }
                        if (d < effectiveCohRange && d > comfortDist) {
                            cohX += other.x;
                            cohY += other.y;
                            cohCount++;
                        }
                    }
                });

                // Apply soft separation as heading adjustment
                // Skip for large fish in simple mode - they just cruise (position push handles overlap)
                if ((sepX !== 0 || sepY !== 0) && !largeFishSimpleMode) {
                    const sepAngle = Math.atan2(sepY, sepX);
                    const sepMag = Math.sqrt(sepX * sepX + sepY * sepY);
                    const sepStrength = isLarge
                        ? Math.min(0.03, sepMag * 0.015)  // Large: much gentler — prevents oscillation with cruise angle
                        : Math.min(0.12, sepMag * 0.06);  // Others: unchanged
                    f.targetHeading += angleDiff(sepAngle, f.heading) * sepStrength;
                }

                // Apply alignment (school with same size) - ONLY for small fish
                // Medium fish use unified school heading, not boids alignment
                // Large fish are solitary
                if (alignCount > 0 && isSmall) {
                    const avgAngle = Math.atan2(alignVy / alignCount, alignVx / alignCount);
                    f.targetHeading += angleDiff(avgAngle, f.heading) * 0.015;
                }

                // Apply cohesion - ONLY for small fish
                // Medium fish use formation, large fish are solitary
                if (cohCount > 0 && isSmall) {
                    const centerX = cohX / cohCount;
                    const centerY = cohY / cohCount;
                    const cohAngle = Math.atan2(centerY - f.y, centerX - f.x);
                    f.targetHeading += angleDiff(cohAngle, f.heading) * 0.01;
                }

                // ---- PHASE 11: Zone Preferences + Center Separation ----
                // Each fish type has a preferred vertical zone
                // Small fish: Bottom half (near coral) - handled by coral targets
                // Medium fish: Middle band - handled by school target
                // Large fish: Upper half - explicit zone bias

                // ---- ZONE PREFERENCES (skip for large fish in simple mode) ----
                if (f.state === 'idle' && !largeFishSimpleMode) {
                    // Small/medium fish zone preferences
                    // (Large fish just cruise - their zone is enforced by edge avoidance)

                    // Center separation: Prevent small/medium from piling up in center
                    const centerX = w / 2;
                    const centerY = h * 0.45;
                    const toCenterX = centerX - f.x;
                    const toCenterY = centerY - f.y;
                    const centerDist = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY);

                    if (centerDist < 100 && centerDist > 10) {
                        const pushAngle = Math.atan2(-toCenterY, -toCenterX);
                        const pushStrength = (100 - centerDist) / 100;
                        f.targetHeading += angleDiff(pushAngle, f.heading) * 0.006 * pushStrength;
                    }
                }

                // ---- PHASE 3: Predator Wake Avoidance ----
                // Small/medium fish drift aside when in the path of a cruising large fish
                // This creates a natural "parting" effect as predators approach
                // PERFORMANCE: Throttled to every 4 frames, result cached on fish
                if ((isSmall || isMedium) && f.state === 'idle') {
                    if (this.frameCounter % 4 === fi % 4) {
                        // Stagger recalc across fish so not all update same frame
                        f.cachedWakeForce = getWakeAvoidance(f, largeFishList, isSmall, isMedium);
                    }
                    const wakeAvoid = f.cachedWakeForce || { angle: 0, strength: 0 };
                    if (wakeAvoid.strength > 0) {
                        f.targetHeading += angleDiff(wakeAvoid.angle, f.heading) * wakeAvoid.strength;
                        f.debugWakeAvoid = true;
                    } else {
                        f.debugWakeAvoid = false;
                    }
                }

                // ---- Jellyfish avoidance + tentacle predation ----
                const JELLY_AVOID_RANGE = 60;
                const JELLY_AVOID_FORCE = 0.06;
                jellyfish.forEach(j => {
                    if (!j.shape) return;
                    const shape = j.shape;
                    const dx = f.x - j.x;
                    const dy = f.y - j.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Steering avoidance
                    const minDist = JELLY_AVOID_RANGE + shape.bellRadius;
                    if (dist < minDist && dist > 0) {
                        const avoidAngle = Math.atan2(dy, dx);
                        const strength = (minDist - dist) / minDist;
                        f.targetHeading += angleDiff(avoidAngle, f.heading) * JELLY_AVOID_FORCE * strength;
                    }

                    // Inner danger zone — force immediate flee if within tentacle reach
                    const r = shape.bellRadius;
                    const tentacleReach = r + shape.tentacleLength * r * 0.4 + 10;
                    if (dist < tentacleReach) {
                        f.state = 'fleeing';
                        f.fleeTimer = Math.max(f.fleeTimer || 0, 1500);
                        f.behaviorLockTimer = Math.max(f.behaviorLockTimer || 0, 1500);
                    }

                    // Tentacle tip collision — small fish only
                    if (isSmall && !jellyfishCaughtFish.has(f.id)) {
                        const bellH = shape.bellHeight || r * 0.6;
                        const segLen = r * 0.4;
                        const tentacleTime = now * 0.002 + (shape.wobbleOffset || 0);
                        for (let t = 0; t < shape.numTentacles; t++) {
                            const tx = -r * 0.8 + (t / Math.max(1, shape.numTentacles - 1)) * r * 1.6;
                            const s = shape.tentacleLength;
                            const wave = Math.sin(tentacleTime + t * 0.7 + s * 0.5) * (8 + s * 2);
                            const drift = Math.sin(tentacleTime * 0.5 + t) * 3;
                            const tipX = j.x + tx + wave + drift;
                            const tipY = j.y + bellH * 0.05 + s * segLen;
                            const tipDist = Math.sqrt((f.x - tipX) ** 2 + (f.y - tipY) ** 2);
                            if (tipDist < 16) {
                                jellyfishCaughtFish.add(f.id);
                                j.flashUntil = now + 350;
                                for (let p = 0; p < 6; p++) {
                                    const a = (p / 6) * Math.PI * 2;
                                    particles.push({ x: f.x, y: f.y, vx: Math.cos(a), vy: Math.sin(a) - 0.5, life: 1, createdAt: now });
                                }
                                break;
                            }
                        }
                    }
                });

                // ---- Coral interaction based on fish size ----
                // Large fish: stay buffer away from coral (can't get close)
                // Medium fish: can approach coral edge but not enter
                // Small fish: attracted to coral (handled in wander/flee)
                coral.forEach(c => {
                    if (!c.settled || !c.shape) return;
                    const coralW = (c.shape.width || 50) * 0.5;
                    const coralH = c.shape.height || 60;
                    const coralTop = c.y - coralH; // Top of coral (grows upward from base)

                    const dx = f.x - c.x;
                    const dy = f.y - c.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (sizeCategory === 'large') {
                        // Large fish: stay FAR from coral - buffer of coral height + 100px
                        const largeBuffer = coralH + 100;
                        const keepOutRadius = coralW + largeBuffer;
                        if (dist < keepOutRadius && dist > 0) {
                            const avoidAngle = Math.atan2(dy, dx);
                            const strength = (keepOutRadius - dist) / keepOutRadius;
                            // REDUCED from 0.35 to 0.08 - gentle steering, not violent
                            f.targetHeading += angleDiff(avoidAngle, f.heading) * 0.08 * strength;
                            // Gentle upward bias if near coral vertical zone (reduced from 0.2 to 0.04)
                            if (f.y > coralTop - 60) {
                                f.targetHeading += angleDiff(-Math.PI * 0.5, f.heading) * 0.04 * strength;
                            }
                        }
                        // Soft boundary - gentle push away if very close (no teleporting)
                        const hardLimit = coralW + coralH + 40;
                        if (dist < hardLimit && dist > 0) {
                            const pushStrength = (hardLimit - dist) * 0.005; // Reduced from 0.02
                            f.x += (dx / dist) * pushStrength;
                            f.y += (dy / dist) * pushStrength;
                        }
                    } else if (sizeCategory === 'medium') {
                        // Medium fish: PROACTIVE avoidance of coral zone
                        // Buffer zone around coral to steer away before entering
                        const CORAL_BUFFER = 40; // Buffer distance around coral
                        const coralAvoidW = coralW + CORAL_BUFFER;
                        const coralAvoidTop = coralTop - CORAL_BUFFER;

                        // Check if fish is in avoidance zone (approaching coral)
                        const nearCoral = Math.abs(dx) < coralAvoidW && f.y > coralAvoidTop;
                        const insideCoral = Math.abs(dx) < coralW && f.y > coralTop;

                        if (insideCoral) {
                            // INSIDE: Strong push out - find shortest exit
                            const exitLeft = -(coralW + 10) - dx;
                            const exitRight = (coralW + 10) - dx;
                            const exitUp = coralTop - 15 - f.y;
                            let exitAngle;
                            if (Math.abs(exitUp) < Math.min(Math.abs(exitLeft), Math.abs(exitRight))) {
                                f.y += exitUp * 0.4; // Stronger push
                                exitAngle = -Math.PI * 0.5; // Point up
                            } else if (Math.abs(exitLeft) < Math.abs(exitRight)) {
                                f.x += exitLeft * 0.4;
                                exitAngle = Math.PI; // Point left
                            } else {
                                f.x += exitRight * 0.4;
                                exitAngle = 0; // Point right
                            }
                            // Strong blend toward exit direction
                            f.targetHeading += angleDiff(exitAngle, f.heading) * 0.25;
                        } else if (nearCoral) {
                            // APPROACHING: Proactive steering away from coral
                            const avoidAngle = Math.atan2(dy, dx); // Away from coral center
                            const proximity = Math.max(
                                (coralAvoidW - Math.abs(dx)) / CORAL_BUFFER,
                                (f.y - coralAvoidTop) / CORAL_BUFFER
                            );
                            const strength = Math.min(1, proximity) * 0.12;
                            f.targetHeading += angleDiff(avoidAngle, f.heading) * strength;
                        }
                    }
                });

                // ---- ANTICIPATORY EDGE AVOIDANCE SYSTEM ----
                // Look ahead to predict collision BEFORE reaching buffer zone
                const LOOKAHEAD_FRAMES = 60;  // How many frames ahead to predict
                const ANTICIPATE_ZONE = 180;  // Start anticipating this far from edge
                const BUFFER_ZONE = 100;      // Reactive steering zone
                const HARD_EDGE = 30;         // Emergency zone - instant turn
                const EMERGENCY_EDGE = 15;    // Physical boundary - teleport back

                // SPECIAL CASE: Small fish near coral at edges get reduced edge avoidance
                // This prevents conflict between "stay in coral" and "avoid edge"
                let bottomEdgeMultiplier = 1.0;
                let leftEdgeMultiplier = 1.0;
                let rightEdgeMultiplier = 1.0;

                if (isSmall) {
                    // Find home coral
                    let homeCoral = null;
                    let homeCoralDist = Infinity;
                    coral.forEach(c => {
                        if (!c.settled) return;
                        const d = Math.sqrt((c.x - f.x) ** 2 + (c.y - f.y) ** 2);
                        if (d < homeCoralDist) {
                            homeCoralDist = d;
                            homeCoral = c;
                        }
                    });

                    if (homeCoral) {
                        const coralW = (homeCoral.shape?.width || 50) * 0.5;
                        const coralH = homeCoral.shape?.height || 60;

                        // If coral is at bottom edge, disable bottom edge avoidance
                        if (homeCoral.y > h - BUFFER_ZONE - 30) {
                            bottomEdgeMultiplier = 0.1; // Almost disabled
                        }
                        // If coral is at left edge
                        if (homeCoral.x - coralW < BUFFER_ZONE) {
                            leftEdgeMultiplier = 0.1;
                        }
                        // If coral is at right edge
                        if (homeCoral.x + coralW > w - BUFFER_ZONE) {
                            rightEdgeMultiplier = 0.1;
                        }
                    }

                    // Extra reduction for fish actively returning to coral
                    if (f.isReturningToCoral || f.fleeTowardCoral) {
                        bottomEdgeMultiplier *= 0.3;
                        leftEdgeMultiplier *= 0.3;
                        rightEdgeMultiplier *= 0.3;
                    }
                }

                // Current speed for prediction
                const currentSpeed = Math.sqrt(f.vx * f.vx + f.vy * f.vy) || 1;

                // Predict future position
                const futureX = f.x + Math.cos(f.heading) * currentSpeed * LOOKAHEAD_FRAMES;
                const futureY = f.y + Math.sin(f.heading) * currentSpeed * LOOKAHEAD_FRAMES;

                // Store for debug visualization
                f.debugFutureX = futureX;
                f.debugFutureY = futureY;
                f.debugEdgeAvoid = { x: 0, y: 0, strength: 0, anticipating: false };

                let avoidX = 0, avoidY = 0;
                let avoidStrength = 0;
                let isAnticipating = false;
                let inEmergency = false;

                // Check ANTICIPATED collision (gentle early turn)
                // Apply edge multipliers for small fish near coral at edges
                if (futureX < ANTICIPATE_ZONE && f.x > BUFFER_ZONE) {
                    const urgency = 1 - (futureX / ANTICIPATE_ZONE);
                    avoidX += urgency * 0.8 * leftEdgeMultiplier;
                    isAnticipating = true;
                }
                if (futureX > w - ANTICIPATE_ZONE && f.x < w - BUFFER_ZONE) {
                    const urgency = 1 - ((w - futureX) / ANTICIPATE_ZONE);
                    avoidX -= urgency * 0.8 * rightEdgeMultiplier;
                    isAnticipating = true;
                }
                if (futureY < ANTICIPATE_ZONE && f.y > BUFFER_ZONE) {
                    const urgency = 1 - (futureY / ANTICIPATE_ZONE);
                    avoidY += urgency * 0.8; // Top edge - no multiplier needed
                    isAnticipating = true;
                }
                if (futureY > h - ANTICIPATE_ZONE && f.y < h - BUFFER_ZONE) {
                    const urgency = 1 - ((h - futureY) / ANTICIPATE_ZONE);
                    avoidY -= urgency * 0.8 * bottomEdgeMultiplier;
                    isAnticipating = true;
                }

                // Check CURRENT position (stronger reactive steering)
                if (f.x < BUFFER_ZONE) {
                    const depth = (BUFFER_ZONE - f.x) / BUFFER_ZONE;
                    avoidX += depth * 2 * leftEdgeMultiplier;
                    avoidStrength = Math.max(avoidStrength, depth * 0.5 * leftEdgeMultiplier);
                }
                if (f.x > w - BUFFER_ZONE) {
                    const depth = (f.x - (w - BUFFER_ZONE)) / BUFFER_ZONE;
                    avoidX -= depth * 2 * rightEdgeMultiplier;
                    avoidStrength = Math.max(avoidStrength, depth * 0.5 * rightEdgeMultiplier);
                }
                if (f.y < BUFFER_ZONE) {
                    const depth = (BUFFER_ZONE - f.y) / BUFFER_ZONE;
                    avoidY += depth * 2;
                    avoidStrength = Math.max(avoidStrength, depth * 0.5);
                }
                if (f.y > h - BUFFER_ZONE) {
                    const depth = (f.y - (h - BUFFER_ZONE)) / BUFFER_ZONE;
                    avoidY -= depth * 2 * bottomEdgeMultiplier;
                    avoidStrength = Math.max(avoidStrength, depth * 0.5 * bottomEdgeMultiplier);
                }

                // EMERGENCY ZONE - hard edge - STRONG steering but NO instant heading snap
                // Direct heading assignment causes 180° snaps - must go through smoothing
                if (f.x < HARD_EDGE) {
                    avoidX = 3; avoidStrength = 1; inEmergency = true;
                    f.targetHeading = 0; // Want to go right
                    f.committedHeading = 0; // Commit to this direction
                    f.cruiseAngle = 0; // Reset cruise to match (prevents fighting)
                    f.reversalPressure = 0; // Allow immediate turn
                }
                if (f.x > w - HARD_EDGE) {
                    avoidX = -3; avoidStrength = 1; inEmergency = true;
                    f.targetHeading = Math.PI;
                    f.committedHeading = Math.PI;
                    f.cruiseAngle = Math.PI;
                    f.reversalPressure = 0;
                }
                if (f.y < HARD_EDGE) {
                    avoidY = 3; avoidStrength = 1; inEmergency = true;
                    f.targetHeading = Math.PI * 0.5;
                    f.committedHeading = Math.PI * 0.5;
                    f.cruiseAngle = Math.PI * 0.5;
                    f.reversalPressure = 0;
                }
                if (f.y > h - HARD_EDGE) {
                    // Small fish returning to coral can go closer to bottom edge
                    if (!f.isReturningToCoral) {
                        avoidY = -3; avoidStrength = 1; inEmergency = true;
                        f.targetHeading = -Math.PI * 0.5;
                        f.committedHeading = -Math.PI * 0.5;
                        f.cruiseAngle = -Math.PI * 0.5;
                        f.reversalPressure = 0;
                    } else {
                        // Softer avoidance for returning fish
                        avoidY -= 1.5;
                        avoidStrength = 0.5;
                    }
                }

                // Physical boundary - gentle push back (not teleport)
                const PUSH_STRENGTH = 0.5;
                if (f.x < EMERGENCY_EDGE) f.x += PUSH_STRENGTH;
                if (f.x > w - EMERGENCY_EDGE) f.x -= PUSH_STRENGTH;
                if (f.y < EMERGENCY_EDGE) f.y += PUSH_STRENGTH;
                if (f.y > h - EMERGENCY_EDGE) f.y -= PUSH_STRENGTH;

                // Store debug info
                f.debugEdgeAvoid = { x: avoidX, y: avoidY, strength: avoidStrength, anticipating: isAnticipating, emergency: inEmergency };

                // ---- DECISIVE EDGE TURN COMMITMENT ----
                // When entering edge zone, pick a turn direction and stick with it
                // This prevents wobbling between left and right
                const needsEdgeAvoid = avoidX !== 0 || avoidY !== 0;
                const wasAvoiding = f.edgeAvoidActive || false;

                if (needsEdgeAvoid && !inEmergency) {
                    const avoidAngle = Math.atan2(avoidY, avoidX);

                    // COMMIT to turn direction when first entering edge zone
                    if (!wasAvoiding || f.edgeCommittedAngle === undefined) {
                        // Entering edge zone - commit to this turn angle
                        f.edgeCommittedAngle = avoidAngle;
                        f.edgeAvoidActive = true;
                    } else {
                        // Already avoiding - only update if angle is SIMILAR (within 60°)
                        // This allows gradual adjustments while preventing flip-flops
                        const angleDelta = Math.abs(angleDiff(avoidAngle, f.edgeCommittedAngle));
                        if (angleDelta < Math.PI / 3) {
                            // Gradual update toward new angle
                            f.edgeCommittedAngle += angleDiff(avoidAngle, f.edgeCommittedAngle) * 0.1;
                        }
                        // If angle is very different (opposite), keep committed angle
                        // This prevents wobbling when forces conflict
                    }

                    // Use committed angle for steering
                    const baseForce = isAnticipating ? 0.10 : (0.25 + avoidStrength); // Increased force
                    f.targetHeading += angleDiff(f.edgeCommittedAngle, f.heading) * baseForce;

                    // Reset cruise angle when strongly avoiding
                    if (avoidStrength > 0.3 && isLarge) {
                        f.cruiseAngle = f.edgeCommittedAngle;
                        f.cruiseTimer = 2000;
                    }
                } else {
                    // Not avoiding edges - clear commitment
                    f.edgeAvoidActive = false;
                    f.edgeCommittedAngle = undefined;
                }

                // ---- CAP TOTAL TARGET HEADING CHANGE PER FRAME ----
                // Prevents oscillation from competing forces accumulating
                const MAX_TARGET_CHANGE = 0.10;  // ~5.7 degrees max change per frame - REDUCED
                const targetDeltaFromBase = angleDiff(f.targetHeading, baseTargetHeading);
                if (Math.abs(targetDeltaFromBase) > MAX_TARGET_CHANGE) {
                    // Clamp to max change
                    const sign = targetDeltaFromBase > 0 ? 1 : -1;
                    f.targetHeading = baseTargetHeading + sign * MAX_TARGET_CHANGE;
                }
                // Store for debug
                f.debugTargetDelta = targetDeltaFromBase;

                // ---- HEADING COMMITMENT SYSTEM ----
                // Prevent rapid 180° flips by requiring sustained pressure to change direction
                // EXCEPTION: Food seeking bypasses this to allow quick turns for eating
                // Track desired heading separately and blend toward it
                if (f.committedHeading === undefined) f.committedHeading = f.heading;
                if (f.headingMomentum === undefined) f.headingMomentum = 0;

                const rawTargetDelta = angleDiff(f.targetHeading, f.committedHeading);

                // Check if seeking food (should bypass commitment for quick turns)
                const seekingFood = f.state === 'seeking' && f.debugFoodTarget;

                // If target is trying to flip us more than 90°, resist unless sustained
                if (Math.abs(rawTargetDelta) > Math.PI * 0.5) {
                    if (seekingFood) {
                        // FOOD SEEKING: Bypass commitment - allow immediate turn
                        // This fixes fish overshooting food and getting stuck spinning
                        f.committedHeading = f.targetHeading;
                        f.reversalPressure = 0;
                    } else {
                        // Normal heading commitment for non-food states
                        // Build up reversal pressure over time
                        f.reversalPressure = (f.reversalPressure || 0) + Math.abs(rawTargetDelta) * 0.02;

                        // Only allow reversal if pressure builds up enough (about 0.5 seconds)
                        if (f.reversalPressure > 0.5 || inEmergency) {
                            f.committedHeading = f.targetHeading;
                            f.reversalPressure = 0;
                        }
                        // Otherwise, steer perpendicular (curve around instead of flip)
                        else {
                            const curveDir = rawTargetDelta > 0 ? 1 : -1;
                            f.committedHeading += curveDir * 0.03;
                        }
                    }
                } else {
                    // Small adjustment - apply smoothly
                    f.committedHeading += rawTargetDelta * 0.1;
                    f.reversalPressure = Math.max(0, (f.reversalPressure || 0) - 0.05);
                }

                // Store for debug
                f.debugReversalPressure = f.reversalPressure || 0;

                // ---- Smooth heading interpolation with capped turn rate ----
                // LARGE FISH CRUISE: Simpler heading control to prevent wobble
                // Directly follow cruise angle with gentle interpolation
                let headingDelta;
                let rawHeadingDelta; // For bend animation
                if (largeFishSimpleMode && f.cruiseAngle !== undefined) {
                    // Direct blend toward cruise angle, bypassing complex commitment
                    rawHeadingDelta = angleDiff(f.cruiseAngle, f.heading);
                    headingDelta = rawHeadingDelta * 0.02; // Gentle, steady turn
                    // Allow faster turning when far from cruise angle
                    if (Math.abs(rawHeadingDelta) > Math.PI * 0.3) {
                        headingDelta = rawHeadingDelta * 0.04;
                    }
                } else {
                    rawHeadingDelta = angleDiff(f.committedHeading, f.heading);
                    headingDelta = rawHeadingDelta * TURN_RATE;
                }
                // Cap maximum turn per frame to prevent jittery oscillation
                headingDelta = Math.max(-MAX_TURN_PER_FRAME, Math.min(MAX_TURN_PER_FRAME, headingDelta));
                f.heading += headingDelta;

                // Track turn intensity for body bend animation
                // Use raw heading delta for more responsive bend
                const turnIntensity = rawHeadingDelta * 3; // Amplify for visibility
                f.bendAmount = (f.bendAmount || 0) * 0.7 + turnIntensity * 0.3; // More responsive blend
                // Clamp to reasonable range
                f.bendAmount = Math.max(-1, Math.min(1, f.bendAmount));

                // ---- STUCK DETECTION: Nudge fish that are spinning in place ----
                // Track spinning time
                if (Math.abs(f.bendAmount) > 0.6) {
                    f.spinTime = (f.spinTime || 0) + deltaTime;
                } else {
                    f.spinTime = Math.max(0, (f.spinTime || 0) - 8); // Decay slowly
                }

                // If spinning for over 1.2 seconds, give a strong nudge
                // NO direct heading assignment - set committed heading and let smoothing work
                if (f.spinTime > 1200) {
                    let escapeAngle;
                    if (isSmall) {
                        // Small fish: nudge toward nearest coral
                        let nearestCoral = null;
                        let nearestDist = Infinity;
                        coral.forEach(c => {
                            if (!c.settled) return;
                            const d = Math.sqrt((c.x - f.x) ** 2 + (c.y - f.y) ** 2);
                            if (d < nearestDist) {
                                nearestDist = d;
                                nearestCoral = c;
                            }
                        });
                        if (nearestCoral) {
                            const coralH = nearestCoral.shape?.height || 60;
                            const tgtY = nearestCoral.y - coralH * 0.5;
                            escapeAngle = Math.atan2(tgtY - f.y, nearestCoral.x - f.x);
                            f.behaviorLockTimer = 0;
                            f.isReturningToCoral = true;
                        } else {
                            escapeAngle = f.heading + Math.PI / 2; // Turn 90 degrees
                        }
                    } else {
                        // Medium/Large: nudge toward a spread-out position
                        const spreadAngle = (f.id % 4) * (Math.PI / 2);
                        const targetX = w * 0.5 + Math.cos(spreadAngle) * w * 0.2;
                        const targetY = (isLarge ? h * 0.3 : h * 0.45) + Math.sin(spreadAngle) * h * 0.1;
                        escapeAngle = Math.atan2(targetY - f.y, targetX - f.x);
                    }
                    // Set all heading-related values to escape angle (but don't set f.heading directly)
                    f.targetHeading = escapeAngle;
                    f.committedHeading = escapeAngle;
                    f.reversalPressure = 0;
                    f.spinTime = 0;
                    if (isLarge) {
                        f.cruiseAngle = escapeAngle;
                        f.cruiseTimer = 5000;
                    }
                    if (isMedium) {
                        f.wanderTarget = null; // Clear any conflicting target
                    }
                }

                // ---- RETURNING TIMEOUT: Teleport small fish if stuck returning too long ----
                // IMPROVED: Only count stuck time when NOT making progress toward coral
                if (isSmall && f.isReturningToCoral) {
                    // Find home coral first
                    let homeCoral = null;
                    let homeCoralDist = Infinity;
                    coral.forEach(c => {
                        if (!c.settled) return;
                        const d = Math.sqrt((c.x - f.x) ** 2 + (c.y - f.y) ** 2);
                        if (d < homeCoralDist) {
                            homeCoralDist = d;
                            homeCoral = c;
                        }
                    });

                    if (homeCoral) {
                        const coralH = homeCoral.shape?.height || 60;
                        const coralTargetY = homeCoral.y - coralH * 0.5;
                        const distToCoral = Math.sqrt((f.x - homeCoral.x) ** 2 + (f.y - coralTargetY) ** 2);

                        // PROGRESS CHECK: Only count stuck time if not making progress
                        if (f.lastCoralDist !== undefined && distToCoral < f.lastCoralDist - 3) {
                            // Making progress toward coral - reset stuck timer
                            f.returningTime = 0;
                        } else {
                            // Not making progress - increment stuck timer
                            f.returningTime = (f.returningTime || 0) + deltaTime;
                        }
                        f.lastCoralDist = distToCoral;

                        // RESCUE MODE: Strong steering override after 15s stuck (no teleport)
                        if (f.returningTime > 15000) {
                            const rescueX = homeCoral.x;
                            const rescueY = homeCoral.y - coralH * 0.5;
                            const toCoralAngle = Math.atan2(rescueY - f.y, rescueX - f.x);
                            // Override all other forces - snap heading directly toward coral
                            f.targetHeading = toCoralAngle;
                            f.committedHeading = toCoralAngle;
                            f.heading = toCoralAngle;
                            f.reversalPressure = 0;
                            // Strong velocity burst toward coral
                            const rescueSpeed = 2.5;
                            f.vx = Math.cos(toCoralAngle) * rescueSpeed;
                            f.vy = Math.sin(toCoralAngle) * rescueSpeed;
                            // Arrival check
                            if (distToCoral < 30) {
                                f.isReturningToCoral = false;
                                f.lastCoralDist = undefined;
                                f.returningTime = 0;
                            }
                        }
                    }
                } else {
                    f.returningTime = 0;
                    f.lastCoralDist = undefined;
                }

                // ---- Apply velocity with per-fish speed variation ----
                const speedMult = 0.85 + fishRand * 0.3;

                // Slow down during sharp turns (fish can't turn fast at high speed)
                const turnSlowdown = 1 - Math.abs(f.bendAmount) * 0.4; // Up to 40% slower when turning hard

                let speed;
                if (f.state === 'fleeing' || f.state === 'retreating') {
                    // Fleeing/retreating - fast escape
                    speed = FLEE_SPEED * speedMult * turnSlowdown;
                } else if (f.state === 'hunting') {
                    // Hunting prey - fast pursuit
                    speed = SEEK_SPEED * 1.3 * speedMult * turnSlowdown;
                } else if (f.state === 'challenging') {
                    // Dominance display - aggressive advance
                    speed = SEEK_SPEED * 1.5 * speedMult * turnSlowdown;
                } else if (f.state === 'seeking') {
                    speed = SEEK_SPEED * speedMult * turnSlowdown;
                } else if (isLarge) {
                    // Large fish cruise faster (tuna-like)
                    speed = IDLE_SPEED * 1.8 * speedMult * turnSlowdown;
                } else {
                    speed = IDLE_SPEED * speedMult * turnSlowdown;
                }
                // ---- VELOCITY SMOOTHING: Blend for smooth movement ----
                const targetVx = Math.cos(f.heading) * speed;
                const targetVy = Math.sin(f.heading) * speed;
                // Hard edge emergency: bypass smoothing - turn immediately (was getting stuck)
                // Emergency collision: strong immediate response
                // Fleeing: 70% old + 30% new (responsive burst)
                // Normal: 95% old + 5% new (ultra-smooth)
                const isFleeing = f.state === 'fleeing' || f.state === 'retreating';
                let smoothOld, smoothNew;
                if (inEmergency) {
                    smoothOld = 0.10; smoothNew = 0.90; // Almost instant turn at hard edge
                } else if (inEmergencyCollision) {
                    smoothOld = 0.40; smoothNew = 0.60; // Strong immediate response
                } else if (isFleeing) {
                    smoothOld = 0.70; smoothNew = 0.30;
                } else {
                    smoothOld = 0.95; smoothNew = 0.05;
                }
                f.vx = (f.vx || 0) * smoothOld + targetVx * smoothNew;
                f.vy = (f.vy || 0) * smoothOld + targetVy * smoothNew;

                // Track previous position for safety cap
                const prevX = f.x;
                const prevY = f.y;
                f.x += f.vx;
                f.y += f.vy;

                // ---- POSITION CHANGE CAP: Prevent teleporting ----
                // FLEEING: Allow faster movement (5px vs 3px)
                const MAX_POS_CHANGE = isFleeing ? 5 : 3;
                const posDx = f.x - prevX;
                const posDy = f.y - prevY;
                const posDist = Math.sqrt(posDx * posDx + posDy * posDy);
                if (posDist > MAX_POS_CHANGE) {
                    const scale = MAX_POS_CHANGE / posDist;
                    f.x = prevX + posDx * scale;
                    f.y = prevY + posDy * scale;
                }

                // ---- Render ----
                // Wiggle parameters based on state
                let wiggleSpeed, wiggleAmt;
                if (f.state === 'fleeing' || f.state === 'retreating') {
                    wiggleSpeed = 60;  // Fast panic wiggle
                    wiggleAmt = 10;
                } else if (f.state === 'hunting' || f.state === 'challenging') {
                    wiggleSpeed = 80;  // Fast aggressive wiggle
                    wiggleAmt = 8;
                } else if (f.state === 'seeking') {
                    wiggleSpeed = 100;
                    wiggleAmt = 7;
                } else if (isLarge) {
                    // Large fish have slower, more powerful tail beats
                    wiggleSpeed = 140;
                    wiggleAmt = 6;
                } else {
                    wiggleSpeed = 180;
                    wiggleAmt = 4;
                }
                const wiggle = Math.sin(now / wiggleSpeed + f.id) * wiggleAmt;

                // Stroke animation - subtle pulse
                const strokePulse = 1 + 0.15 * Math.sin(now / 800 + f.id * 2);
                const baseLineWidth = f.state === 'fleeing' ? 3 : 2.5;

                const scaleX = f.scaleX || 1;
                const scaleY = f.scaleY || 1;

                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.heading);

                ctx.strokeStyle = color;
                ctx.lineWidth = baseLineWidth * strokePulse;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Body bend based on turning (fish bend into turns)
                const bendAmount = f.bendAmount || 0;

                // Check if this fish uses the SVG path template
                // FORCE small fish (bodyWidth < 35) to use simple visual IF they have points data
                // SVG fish that were drawn large but scaled small still use SVG (no points to fall back to)
                const hasPointsData = pts && pts.length >= 2;
                const useSimpleVisual = !f.useSvgPath || (hasPointsData && f.bodyWidth && f.bodyWidth < SMALL_THRESHOLD);

                if (f.useSvgPath && !useSimpleVisual) {
                    const sf = f.scaleFactor || 0.1;

                    // Scale line width inversely, with pulse
                    ctx.lineWidth = (3 * strokePulse) / sf;
                    ctx.scale(sf, sf);

                    // Fleeing fish flash brighter
                    ctx.globalAlpha = f.state === 'fleeing' ? 1 : 0.9;

                    // Draw SVG fish manually with tail deformation
                    // Fish faces RIGHT (+X direction), tail on left
                    // Body center at FISH_SVG_CENTER_X, FISH_SVG_CENTER_Y
                    // Tail extends to x ≈ 80-285 (left side)

                    // Swimming tail wag - sinusoidal
                    const tailWag = wiggle * 1.5; // Amplified for large fish
                    const turnBend = bendAmount * 40; // Bend from turning

                    ctx.beginPath();

                    // BODY LOOP (upper arc) - minimal deformation
                    // Start at body center-right, curve up and around
                    ctx.moveTo(1069 - FISH_SVG_CENTER_X, 305 - FISH_SVG_CENTER_Y);

                    // Upper body curve (mostly stable)
                    ctx.bezierCurveTo(
                        1002 - FISH_SVG_CENTER_X, 475 - FISH_SVG_CENTER_Y,
                        823 - FISH_SVG_CENTER_X, 512 - FISH_SVG_CENTER_Y,
                        717 - FISH_SVG_CENTER_X, 512 - FISH_SVG_CENTER_Y
                    );

                    // Continue to body pivot point
                    ctx.bezierCurveTo(
                        450 - FISH_SVG_CENTER_X, 512 - FISH_SVG_CENTER_Y,
                        316 - FISH_SVG_CENTER_X, 400 - FISH_SVG_CENTER_Y,
                        316 - FISH_SVG_CENTER_X, 297 - FISH_SVG_CENTER_Y
                    );

                    // Lower body curve back to nose
                    ctx.bezierCurveTo(
                        326 - FISH_SVG_CENTER_X, 177 - FISH_SVG_CENTER_Y,
                        512 - FISH_SVG_CENTER_X, 120 - FISH_SVG_CENTER_Y,
                        724 - FISH_SVG_CENTER_X, 120 - FISH_SVG_CENTER_Y
                    );
                    ctx.bezierCurveTo(
                        884 - FISH_SVG_CENTER_X, 120 - FISH_SVG_CENTER_Y,
                        1066 - FISH_SVG_CENTER_X, 256 - FISH_SVG_CENTER_Y,
                        1069 - FISH_SVG_CENTER_X, 305 - FISH_SVG_CENTER_Y
                    );
                    ctx.closePath();
                    ctx.stroke();

                    // Fill body - half opacity
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.globalAlpha = f.state === 'fleeing' ? 1 : 0.9;

                    // TAIL (with deformation) - separate path
                    // Tail starts at body pivot (316, 297) and extends left
                    const tailDeform = tailWag + turnBend;

                    ctx.beginPath();
                    ctx.moveTo(316 - FISH_SVG_CENTER_X, 297 - FISH_SVG_CENTER_Y);

                    // Upper tail fork - deformed
                    ctx.bezierCurveTo(
                        250 - FISH_SVG_CENTER_X, 279 - FISH_SVG_CENTER_Y + tailDeform * 0.3,
                        146 - FISH_SVG_CENTER_X, 100 - FISH_SVG_CENTER_Y + tailDeform * 0.6,
                        112 - FISH_SVG_CENTER_X, 128 - FISH_SVG_CENTER_Y + tailDeform * 0.8
                    );
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(112 - FISH_SVG_CENTER_X, 128 - FISH_SVG_CENTER_Y + tailDeform * 0.8);
                    // Tail middle curve
                    ctx.bezierCurveTo(
                        96 - FISH_SVG_CENTER_X, 141 - FISH_SVG_CENTER_Y + tailDeform * 0.7,
                        189 - FISH_SVG_CENTER_X, 248 - FISH_SVG_CENTER_Y + tailDeform * 0.5,
                        189 - FISH_SVG_CENTER_X, 335 - FISH_SVG_CENTER_Y + tailDeform * 0.3
                    );
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(189 - FISH_SVG_CENTER_X, 335 - FISH_SVG_CENTER_Y + tailDeform * 0.3);
                    // Lower tail fork - deformed opposite direction for natural tail spread
                    ctx.bezierCurveTo(
                        189 - FISH_SVG_CENTER_X, 413 - FISH_SVG_CENTER_Y + tailDeform * 0.2,
                        81 - FISH_SVG_CENTER_X, 502 - FISH_SVG_CENTER_Y - tailDeform * 0.3,
                        118 - FISH_SVG_CENTER_X, 518 - FISH_SVG_CENTER_Y - tailDeform * 0.5
                    );
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(118 - FISH_SVG_CENTER_X, 518 - FISH_SVG_CENTER_Y - tailDeform * 0.5);
                    // Back to body
                    ctx.bezierCurveTo(
                        155 - FISH_SVG_CENTER_X, 535 - FISH_SVG_CENTER_Y - tailDeform * 0.3,
                        189 - FISH_SVG_CENTER_X, 403 - FISH_SVG_CENTER_Y,
                        285 - FISH_SVG_CENTER_X, 385 - FISH_SVG_CENTER_Y
                    );
                    ctx.stroke();

                    // Inner midline — static elegant arc (lateral line), no animation
                    // Tail wag is handled by tailDeform on the tail strokes; this stays clean
                    const sf2 = f.scaleFactor || 0.1;
                    ctx.globalAlpha = 0.5;
                    ctx.lineWidth = (1.5 * strokePulse) / sf2;
                    ctx.strokeStyle = color;

                    ctx.beginPath();
                    ctx.moveTo(750 - FISH_SVG_CENTER_X, 335 - FISH_SVG_CENTER_Y);
                    ctx.bezierCurveTo(
                        580 - FISH_SVG_CENTER_X, 300 - FISH_SVG_CENTER_Y,  // bow upward mid-body
                        430 - FISH_SVG_CENTER_X, 290 - FISH_SVG_CENTER_Y,
                        316 - FISH_SVG_CENTER_X, 297 - FISH_SVG_CENTER_Y   // anchor at tail root
                    );
                    ctx.stroke();

                } else {
                    // Fallback: simple procedural fish
                    ctx.scale(scaleX, scaleY);

                    const bodyPts = f.bodyPoints || pts;
                    const throughPts = f.throughLine;
                    const bodyWidth = f.bodyWidth || 20;

                    // VISUAL CATEGORY based on bodyWidth (matches behavior thresholds)
                    // Small fish (< 35) always use simple closed shape
                    // Medium fish (35-60) use through-line if available
                    const isVisuallySmall = bodyWidth < SMALL_THRESHOLD;
                    const useThoughLine = !isVisuallySmall && throughPts && throughPts.length > 1;

                    if (useThoughLine) {
                        // Fish with body + through-line
                        // Draw body outline (no bend on body - stays in bounds)
                        ctx.globalAlpha = 0.9;
                        ctx.beginPath();
                        ctx.moveTo(bodyPts[0].x, bodyPts[0].y);
                        for (let i = 1; i < bodyPts.length; i++) {
                            const p0 = bodyPts[i - 1];
                            const p1 = bodyPts[i];
                            ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
                        }
                        ctx.closePath();
                        ctx.stroke();

                        // Fill body - half opacity
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = color;
                        ctx.fill();

                        // Draw through-line with wiggle + TAIL-ONLY bend
                        ctx.globalAlpha = 0.85;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(throughPts[0].x, throughPts[0].y);
                        for (let i = 1; i < throughPts.length; i++) {
                            const t = i / throughPts.length;
                            const wg = wiggle * Math.sin(t * Math.PI * 1.5);
                            // Only bend the back 50% (tail area)
                            const tailFactor = Math.max(0, (t - 0.5) * 2); // 0 at front, 1 at back
                            const bendOffset = bendAmount * 12 * tailFactor;
                            const p0 = throughPts[i - 1];
                            const p1 = throughPts[i];
                            ctx.quadraticCurveTo(
                                p0.x, p0.y + wg + bendOffset,
                                (p0.x + p1.x) / 2, (p0.y + p1.y) / 2 + wg + bendOffset
                            );
                        }
                        ctx.stroke();
                    } else {
                        // Simple fish (small) - clean shape, NO deformation to prevent self-intersection
                        ctx.globalAlpha = 0.9;
                        ctx.beginPath();

                        // Small fish use point array that wraps around
                        // NO wiggle or bend on closed shapes - causes self-intersection and weird deformation
                        // Instead, swimming animation is conveyed through subtle position wobble

                        // Generate simple fish shape if no points exist (SVG fish forced to small)
                        let fishPts = pts;
                        if (!fishPts || fishPts.length < 3) {
                            // Generate procedural small fish shape based on bodyWidth
                            const bw = bodyWidth || 20;
                            const bh = (f.bodyHeight || bw * 0.4);
                            const bodyLen = bw * 1.5;
                            const bodyH = bh;
                            const tailLen = bodyLen * 0.5;
                            const tailSpread = bodyH * 0.8;
                            const bodyCenter = bodyLen * 0.1;

                            fishPts = [
                                { x: bodyLen - bodyCenter, y: 0 }, // Nose
                                { x: bodyLen * 0.7 - bodyCenter, y: -bodyH * 0.5 },
                                { x: bodyLen * 0.3 - bodyCenter, y: -bodyH * 0.8 },
                                { x: -bodyLen * 0.2 - bodyCenter, y: -bodyH * 0.6 },
                                { x: -bodyLen * 0.5 - bodyCenter, y: -bodyH * 0.3 },
                                { x: -bodyLen * 0.5 - tailLen - bodyCenter, y: -tailSpread }, // Tail top
                                { x: -bodyLen * 0.5 - tailLen * 0.5 - bodyCenter, y: 0 }, // Tail notch
                                { x: -bodyLen * 0.5 - tailLen - bodyCenter, y: tailSpread }, // Tail bottom
                                { x: -bodyLen * 0.5 - bodyCenter, y: bodyH * 0.3 },
                                { x: -bodyLen * 0.2 - bodyCenter, y: bodyH * 0.6 },
                                { x: bodyLen * 0.3 - bodyCenter, y: bodyH * 0.8 },
                                { x: bodyLen * 0.7 - bodyCenter, y: bodyH * 0.5 },
                                { x: bodyLen - bodyCenter, y: 0 } // Back to nose
                            ];
                        }

                        const numPts = fishPts.length;
                        ctx.moveTo(fishPts[0].x, fishPts[0].y);

                        for (let i = 1; i < numPts; i++) {
                            const p0 = fishPts[i - 1];
                            const p1 = fishPts[i];
                            // Smooth curves, no deformation
                            ctx.quadraticCurveTo(
                                p0.x, p0.y,
                                (p0.x + p1.x) / 2, (p0.y + p1.y) / 2
                            );
                        }
                        ctx.closePath();
                        ctx.stroke();

                        // Fill body - half opacity
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = color;
                        ctx.fill();
                    }
                }

                ctx.globalAlpha = 1;
                ctx.restore();
            });

            // Remove fish caught by jellyfish tentacles this frame
            if (jellyfishCaughtFish.size > 0) {
                fish = fish.filter(f => !jellyfishCaughtFish.has(f.id));
            }
        }

        function drawCoralEntities() {
            const now = Date.now();
            const canvasW = canvas.width / (window.devicePixelRatio || 1);
            const canvasH = canvas.height / (window.devicePixelRatio || 1);

            coral.forEach((c, ci) => {
                if (!c.shape) return;

                const shape = c.shape;
                const color = aquaColors.coral[c.id % aquaColors.coral.length];
                const altColor = aquaColors.coral[(c.id + 1) % aquaColors.coral.length];

                // Sink to bottom with space-filling behavior
                if (!c.settled) {
                    const targetY = canvasH - 5;
                    c.y += 1.8; // Sink speed

                    // Space-filling: push away from other coral while sinking
                    coral.forEach((other, oi) => {
                        if (oi === ci) return;
                        const dx = c.x - other.x;
                        const dist = Math.abs(dx);
                        const minDist = (shape.width + (other.shape?.width || 50)) * 0.5 + 20;

                        if (dist < minDist) {
                            // Push apart horizontally
                            const push = (minDist - dist) * 0.05 * (dx > 0 ? 1 : -1);
                            c.x += push;
                        }
                    });

                    // Keep in horizontal bounds
                    const margin = shape.width * 0.5 + 20;
                    if (c.x < margin) c.x = margin;
                    if (c.x > canvasW - margin) c.x = canvasW - margin;

                    // Gentle drift while sinking
                    c.x += Math.sin(now / 1500 + c.id) * 0.15;

                    if (c.y >= targetY) {
                        c.y = targetY;
                        c.settled = true;
                    }
                }

                // Gentle sway - each stalk sways slightly different
                const baseSway = Math.sin(now / 3500 + shape.swayOffset) * (c.settled ? 2.5 : 0.5);

                ctx.save();
                ctx.translate(c.x + baseSway, c.y);

                // Draw each stalk with branches
                shape.stalks.forEach((stalk, si) => {
                    const stalkSway = Math.sin(now / 2800 + si * 0.7 + shape.swayOffset) * 1.8;
                    const stalkX = stalk.x + stalkSway;

                    // Alternate colors between stalks with variation
                    const stalkColor = si % 3 === 0 ? color : (si % 3 === 1 ? altColor : color);

                    ctx.strokeStyle = stalkColor;
                    // Thicker stalks based on stalk.width property
                    ctx.lineWidth = stalk.width || 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.globalAlpha = 0.85;

                    // Draw main stalk (growing upward, so negative Y)
                    ctx.beginPath();
                    ctx.moveTo(stalkX, 0);

                    // Curved stalk with more character
                    const curveMid = -stalk.height * 0.5;
                    const curveAmt = stalkSway * 1.2 + (si % 2 === 0 ? 3 : -3);
                    ctx.quadraticCurveTo(
                        stalkX + curveAmt, curveMid,
                        stalkX + stalkSway * 0.4, -stalk.height
                    );
                    ctx.stroke();

                    // Draw tip bulb (larger, more visible)
                    ctx.globalAlpha = 0.7;
                    const tipSize = 4 + (stalk.width || 2);
                    ctx.beginPath();
                    ctx.arc(stalkX + stalkSway * 0.4, -stalk.height - tipSize * 0.5, tipSize, 0, Math.PI * 2);
                    ctx.fillStyle = stalkColor;
                    ctx.fill();

                    // Draw branches with sub-branches
                    ctx.globalAlpha = 0.8;
                    stalk.branches.forEach((branch, bi) => {
                        const branchSway = Math.sin(now / 2200 + bi * 1.1 + shape.swayOffset) * 1.2;
                        ctx.lineWidth = branch.width || 2;

                        // Branch starts from stalk at given Y position
                        const branchStartY = -branch.y;
                        const branchStartX = stalkX + (branchStartY / -stalk.height) * stalkSway * 0.4;

                        // Branch end position
                        const branchEndX = branchStartX + Math.sin(branch.angle) * branch.length + branchSway;
                        const branchEndY = branchStartY - Math.cos(branch.angle) * branch.length * 0.85;

                        ctx.beginPath();
                        ctx.moveTo(branchStartX, branchStartY);
                        ctx.lineTo(branchEndX, branchEndY);
                        ctx.stroke();

                        // Branch tip
                        if (branch.hasTip) {
                            ctx.globalAlpha = 0.6;
                            const tipSize = 3 + (branch.width || 2) * 0.5;
                            ctx.beginPath();
                            ctx.arc(branchEndX, branchEndY - tipSize * 0.3, tipSize, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 0.8;
                        }
                    });
                });

                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }

        function drawJellyfishEntities() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            jellyfish.forEach(j => {
                if (!j.shape) return;

                const color = aquaColors.jellyfish[j.id % aquaColors.jellyfish.length];
                const shape = j.shape;

                // Gentle figure-8 drift pattern
                j.orbitAngle += j.orbitSpeed * 0.4;

                const phaseOffset = j.id * 2.5;
                const currentAngle = j.orbitAngle + phaseOffset;

                // Drift path
                const centerX = w * 0.5;
                const centerY = h * 0.45;
                const radiusX = w * 0.28;
                const radiusY = h * 0.18;

                const targetX = centerX + Math.sin(currentAngle) * radiusX;
                const targetY = centerY + Math.sin(currentAngle * 2) * radiusY;

                // Very gentle, capped attraction - no erratic movement
                const dx = targetX - j.x;
                const dy = targetY - j.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Constant gentle force, capped acceleration
                const maxAccel = 0.008;
                if (dist > 10) {
                    const accel = Math.min(maxAccel, dist * 0.00008);
                    j.vx += (dx / dist) * accel;
                    j.vy += (dy / dist) * accel;
                }

                // Strong damping for smooth movement
                j.vx *= 0.96;
                j.vy *= 0.96;

                // Cap max velocity
                const maxSpeed = 0.8;
                const speed = Math.sqrt(j.vx * j.vx + j.vy * j.vy);
                if (speed > maxSpeed) {
                    j.vx = (j.vx / speed) * maxSpeed;
                    j.vy = (j.vy / speed) * maxSpeed;
                }

                // Gentle minimum drift
                const minSpeed = 0.1;
                if (speed < minSpeed && speed > 0) {
                    j.vx = (j.vx / speed) * minSpeed;
                    j.vy = (j.vy / speed) * minSpeed;
                } else if (speed === 0) {
                    // Kick-start if completely stopped
                    const kickAngle = currentAngle;
                    j.vx = Math.cos(kickAngle) * minSpeed;
                    j.vy = Math.sin(kickAngle) * minSpeed;
                }

                // Avoid other jellyfish
                jellyfish.forEach(other => {
                    if (other.id === j.id || !other.shape) return;
                    const dx = j.x - other.x;
                    const dy = j.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = shape.bellRadius + other.shape.bellRadius + 40;
                    if (dist < minDist && dist > 0) {
                        const pushForce = 0.02 * (minDist - dist) / minDist;
                        j.vx += (dx / dist) * pushForce;
                        j.vy += (dy / dist) * pushForce;
                    }
                });

                // Avoid fish
                fish.forEach(f => {
                    const dx = j.x - f.x;
                    const dy = j.y - f.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = shape.bellRadius + f.size * 0.5 + 30;
                    if (dist < minDist && dist > 0) {
                        const pushForce = 0.015 * (minDist - dist) / minDist;
                        j.vx += (dx / dist) * pushForce;
                        j.vy += (dy / dist) * pushForce;
                    }
                });

                // Pumping propulsion - slower, gentler pulse
                const pulsePhase = (now * 0.0015 + j.pulsePhase) % (Math.PI * 2); // Slower pulse
                const isPulsing = pulsePhase < 0.5;
                if (isPulsing && pulsePhase > 0.1) {
                    j.vy -= 0.008; // Gentler upward thrust
                }

                j.x += j.vx;
                j.y += j.vy;

                // Strong edge avoidance - bounce off walls
                const margin = 50;
                const bounceForce = 0.08;
                if (j.x < margin) { j.vx += bounceForce; j.x = margin; }
                if (j.x > w - margin) { j.vx -= bounceForce; j.x = w - margin; }
                if (j.y < margin) { j.vy += bounceForce; j.y = margin; }
                if (j.y > h - margin - 30) { j.vy -= bounceForce * 1.5; j.y = h - margin - 30; }

                // Pulse animation for bell
                const pulse = Math.sin(pulsePhase);
                const bellSquash = 1 - pulse * 0.15;
                const bellStretch = 1 + pulse * 0.1;

                // Render jellyfish
                ctx.save();
                ctx.translate(j.x, j.y);

                const r = shape.bellRadius;
                const bellH = shape.bellHeight;

                // Draw bell (dome shape)
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                const isFlashing = j.flashUntil && now < j.flashUntil;
                ctx.globalAlpha = isFlashing ? 1.0 : 0.85;

                ctx.beginPath();
                ctx.ellipse(0, 0, r * bellSquash, bellH * bellStretch, 0, Math.PI, 0);
                ctx.stroke();

                // Bell fill
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = color;
                ctx.fill();

                // Inner bell detail
                ctx.globalAlpha = 0.35;
                ctx.beginPath();
                ctx.ellipse(0, bellH * 0.1, r * 0.5 * bellSquash, bellH * 0.4 * bellStretch, 0, Math.PI, 0);
                ctx.stroke();

                // Draw trailing tentacles
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.65;

                const tentacleTime = now * 0.002 + shape.wobbleOffset;
                for (let t = 0; t < shape.numTentacles; t++) {
                    const tx = -r * 0.8 + (t / (shape.numTentacles - 1)) * r * 1.6;

                    ctx.beginPath();
                    ctx.moveTo(tx * bellSquash, bellH * 0.05);

                    // Draw wavy tentacle trailing down
                    for (let s = 1; s <= shape.tentacleLength; s++) {
                        const segY = bellH * 0.05 + s * (r * 0.4);
                        const wave = Math.sin(tentacleTime + t * 0.7 + s * 0.5) * (8 + s * 2);
                        const drift = Math.sin(tentacleTime * 0.5 + t) * 3;
                        ctx.lineTo(tx * bellSquash + wave + drift, segY);
                    }
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }

        function drawBubbleEntities() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);

            // Helper to trigger pop — fires particles and marks bubble for ring animation
            function popBubble(b) {
                if (b.popping) return; // already popping
                b.popping = true;
                b.popStart = now;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    particles.push({
                        x: b.x, y: b.y,
                        vx: Math.cos(angle) * 1.5,
                        vy: Math.sin(angle) * 1.5 - 0.8,
                        life: 1, createdAt: now
                    });
                }
            }

            bubbles = bubbles.filter((b, bi) => {
                // Initialize variety properties if not set
                if (b.wobbleSpeed === undefined) {
                    b.wobbleSpeed = 300 + Math.random() * 400;
                    b.wobbleAmt = 0.2 + Math.random() * 0.4;
                    // Size-based rise: larger bubbles rise slower
                    b.riseSpeed = Math.max(0.2, 0.75 - (b.radius / 150));
                    b.hueOffset = Math.random() * 30 - 15;
                }

                // Pop ring animation — plays for 220ms after pop, then removes bubble
                if (b.popping) {
                    const progress = (now - b.popStart) / 220;
                    if (progress >= 1) return false;
                    const hue = 195 + b.hueOffset;
                    const ringR = b.radius * (1 + progress * 0.9);
                    ctx.save();
                    ctx.globalAlpha = 0.5 * (1 - progress);
                    ctx.strokeStyle = `hsla(${hue}, 75%, 80%, 1)`;
                    ctx.lineWidth = Math.max(0.5, 1.5 * (1 - progress));
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, ringR, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                    return true;
                }

                // Bubble-bubble avoidance
                let avoidX = 0;
                bubbles.forEach((other, oi) => {
                    if (oi === bi) return;
                    const dx = b.x - other.x;
                    const dy = b.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = b.radius + other.radius + 10;
                    if (dist < minDist && dist > 0) {
                        avoidX += (dx / dist) * (minDist - dist) * 0.1;
                    }
                });
                b.x += avoidX;

                // Rise upward with wobble
                b.y -= b.riseSpeed;
                b.x += Math.sin(now / b.wobbleSpeed + b.id) * b.wobbleAmt;

                // Slight horizontal drift
                b.x += Math.sin(now / 2000 + b.id * 0.3) * 0.15;

                // Keep in bounds horizontally
                if (b.x < b.radius + 10) b.x = b.radius + 10;
                if (b.x > w - b.radius - 10) b.x = w - b.radius - 10;

                // Pop when reaching top
                if (b.y + b.radius < -10) {
                    popBubble(b);
                    return true; // keep for ring animation
                }

                // Check collision with fish
                for (const f of fish) {
                    const dx = b.x - f.x;
                    const dy = b.y - f.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < b.radius + f.size * 0.4) {
                        popBubble(b);
                        return true; // keep for ring animation
                    }
                }

                // Check collision with jellyfish
                for (const j of jellyfish) {
                    if (!j.shape) continue;
                    const dx = b.x - j.x;
                    const dy = b.y - j.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < b.radius + j.shape.bellRadius * 1.5) {
                        popBubble(b);
                        return true; // keep for ring animation
                    }
                }

                // Draw bubble
                const hue = 195 + b.hueOffset;
                const bubbleColor = `hsla(${hue}, 70%, 65%, 0.6)`;

                // Subtle squash/stretch as it rises
                const squash = 1 + 0.05 * Math.sin(now / 300 + b.id);

                ctx.save();

                // Inner radial gradient — refraction/lens look
                ctx.beginPath();
                ctx.ellipse(b.x, b.y, b.radius * squash, b.radius / squash, 0, 0, Math.PI * 2);
                const grad = ctx.createRadialGradient(
                    b.x - b.radius * 0.3, b.y - b.radius * 0.35, b.radius * 0.05,
                    b.x, b.y, b.radius
                );
                grad.addColorStop(0, `hsla(${hue}, 85%, 92%, 0.18)`);
                grad.addColorStop(0.6, `hsla(${hue}, 70%, 65%, 0.06)`);
                grad.addColorStop(1, `hsla(${hue}, 60%, 45%, 0.02)`);
                ctx.fillStyle = grad;
                ctx.globalAlpha = 0.9;
                ctx.fill();

                // Rim stroke
                ctx.globalAlpha = 0.5;
                ctx.strokeStyle = bubbleColor;
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Shine highlight
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.ellipse(
                    b.x - b.radius * 0.25,
                    b.y - b.radius * 0.28,
                    b.radius * 0.2,
                    b.radius * 0.13,
                    -0.4,
                    0, Math.PI * 2
                );
                ctx.fill();

                ctx.globalAlpha = 1;
                ctx.restore();
                return true;
            });

            // ---- PERFORMANCE: Update inBubble flag on food after bubbles have moved ----
            // Avoids calling isFoodInBubble() per-fish per-food inside the hot fish loop
            food.forEach(fd => {
                fd.inBubble = false;
                for (let i = 0; i < bubbles.length; i++) {
                    const b = bubbles[i];
                    const dx = fd.x - b.x;
                    const dy = fd.y - b.y;
                    if (dx * dx + dy * dy < b.radius * b.radius) {
                        fd.inBubble = true;
                        break;
                    }
                }
            });
        }

        function drawFoodEntities() {
            const now = Date.now();
            food = food.filter(f => {
                const age = now - f.createdAt;
                if (age > FOOD_LIFETIME) return false;

                // Fade out in last 3 seconds
                let opacity = 1;
                if (age > FOOD_LIFETIME - 3000) {
                    opacity = (FOOD_LIFETIME - age) / 3000;
                }

                ctx.save();
                ctx.shadowColor = aquaColors.food;
                ctx.shadowBlur = 8 * opacity;
                ctx.globalAlpha = opacity;

                // Pulsing dot
                const pulse = 1 + 0.2 * Math.sin(now / 400 + f.id);
                const radius = 4 * pulse;

                ctx.fillStyle = aquaColors.food;
                ctx.beginPath();
                ctx.arc(f.x, f.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Outer glow ring
                ctx.globalAlpha = opacity * 0.3;
                ctx.strokeStyle = aquaColors.food;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(f.x, f.y, radius + 4, 0, Math.PI * 2);
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                ctx.restore();
                return true;
            });
        }

        function drawTempLineEntities() {
            const now = Date.now();
            tempLines = tempLines.filter(ln => {
                const age = now - ln.createdAt;
                if (age > LINE_DURATION) return false;

                const opacity = 1 - (age / LINE_DURATION);
                const pts = ln.points;
                if (pts.length < 2) return true;

                // Line-to-bubble popping: check each segment against bubbles
                const step = Math.max(1, Math.floor(pts.length / 20));
                for (let i = step; i < pts.length; i += step) {
                    const p1 = pts[i - step];
                    const p2 = pts[i];
                    for (let bi = bubbles.length - 1; bi >= 0; bi--) {
                        const b = bubbles[bi];
                        if (segmentIntersectsCircle(p1, p2, b.x, b.y, b.radius)) {
                            for (let j = 0; j < 6; j++) {
                                const a = (j / 6) * Math.PI * 2;
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: Math.cos(a) * 1.2,
                                    vy: Math.sin(a) * 0.5 - 0.5,
                                    life: 1, createdAt: now
                                });
                            }
                            bubbles.splice(bi, 1);
                        }
                    }
                }

                ctx.save();
                ctx.strokeStyle = `rgba(77, 201, 246, ${0.6 * opacity})`;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                for (let i = 1; i < pts.length; i++) {
                    const p0 = pts[i - 1];
                    const p1 = pts[i];
                    ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
                }
                ctx.stroke();
                ctx.restore();
                return true;
            });
        }

        // Cursor with glow
        let cursorPos = { x: -100, y: -100 };
        let cursorVisible = false;
        
        function drawCursor() {
            if (!cursorVisible) return;
            
            const x = cursorPos.x;
            const y = cursorPos.y;
            const size = isDrawing ? 14 : 10;
            
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
            gradient.addColorStop(0, isDrawing ? 'rgba(251, 146, 60, 0.25)' : 'rgba(59, 130, 246, 0.2)');
            gradient.addColorStop(0.5, isDrawing ? 'rgba(251, 146, 60, 0.08)' : 'rgba(59, 130, 246, 0.05)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, 60, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = isDrawing ? colors.cursor : 'rgba(147, 197, 253, 0.7)';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = isDrawing ? colors.cursor : colors.glow;
            ctx.shadowBlur = 8;
            
            ctx.beginPath();
            ctx.moveTo(x - size, y); ctx.lineTo(x - 4, y);
            ctx.moveTo(x + 4, y); ctx.lineTo(x + size, y);
            ctx.moveTo(x, y - size); ctx.lineTo(x, y - 4);
            ctx.moveTo(x, y + 4); ctx.lineTo(x, y + size);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            if (isDrawing) {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = colors.cursor;
                ctx.fill();
            }
        }
        
        // Draw ripple effects (for tap/dot feedback)
        function drawRipples() {
            const now = Date.now();
            const rippleDuration = 600;
            
            ripples = ripples.filter(ripple => {
                const age = now - ripple.createdAt;
                if (age > rippleDuration) return false;
                
                const progress = age / rippleDuration;
                const eased = 1 - Math.pow(1 - progress, 3); // ease out cubic
                const radius = ripple.maxRadius * eased;
                const opacity = 1 - progress;
                
                ctx.strokeStyle = `rgba(96, 165, 250, ${0.6 * opacity})`;
                ctx.lineWidth = 2 * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Second ring
                if (progress > 0.15) {
                    const innerProgress = (progress - 0.15) / 0.85;
                    const innerRadius = ripple.maxRadius * 0.6 * innerProgress;
                    ctx.strokeStyle = `rgba(147, 197, 253, ${0.4 * (1 - innerProgress)})`;
                    ctx.lineWidth = 1.5 * (1 - innerProgress * 0.5);
                    ctx.beginPath();
                    ctx.arc(ripple.x, ripple.y, innerRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                return true;
            });
        }
        
        // Draw particle burst (for shape recognition feedback)
        function drawParticles() {
            const now = Date.now();
            const particleDuration = 800;
            
            particles = particles.filter(p => {
                const age = now - p.createdAt;
                if (age > particleDuration) return false;
                
                const progress = age / particleDuration;
                const opacity = 1 - progress;
                
                // Update position with slight gravity
                p.x += p.vx;
                p.y += p.vy + progress * 0.5;
                p.vx *= 0.97;
                p.vy *= 0.97;
                
                // Draw crystalline particle - hexagonal shard
                const size = 4 * (1 - progress * 0.5);

                // Gradient from cyan to purple (bioluminescent crystallization)
                const hue = 180 + progress * 100; // cyan to purple transition
                const r = Math.round(0 + progress * 199);
                const g = Math.round(217 - progress * 92);
                const b = 255;

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.createdAt * 0.002); // Subtle rotation based on creation time

                // Hexagonal crystal shard
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.9 * opacity})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const x = Math.cos(angle) * size;
                    const y = Math.sin(angle) * size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();

                ctx.restore();
                
                return true;
            });
        }
        
        // Draw ambient floating particles
        function initAmbientParticles() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            for (let i = 0; i < 15; i++) {
                ambientParticles.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    size: 1 + Math.random() * 2,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }
        initAmbientParticles();

        // Spawn a starter jellyfish to invite interaction
        (function spawnStarterJellyfish() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            const cx = w * 0.35 + Math.random() * w * 0.3;
            const cy = h * 0.35 + Math.random() * h * 0.3;
            const size = 50;

            // Use the new shape structure
            const shape = generateJellyfishShape(size);
            const orbitAngle = Math.random() * Math.PI * 2;

            jellyfish.push({
                id: entityIdCounter++,
                shape: shape,
                x: cx, y: cy,
                size: size,
                vx: 0,
                vy: 0,
                orbitAngle: orbitAngle,
                orbitRadius: 80 + Math.random() * 60,
                orbitSpeed: 0.0003 + Math.random() * 0.0002,
                orbitCenterX: w / 2,
                orbitCenterY: h * 0.4,
                pulsePhase: Math.random() * Math.PI * 2,
                createdAt: Date.now()
            });
        })();

        function drawAmbientParticles() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            ambientParticles.forEach(p => {
                // Drift movement
                p.x += p.vx;
                p.y += p.vy;
                
                // Wrap around edges
                if (p.x < 0) p.x = w;
                if (p.x > w) p.x = 0;
                if (p.y < 0) p.y = h;
                if (p.y > h) p.y = 0;
                
                // Pulsing opacity
                const pulse = 0.15 + 0.1 * Math.sin(now / 2000 + p.phase);

                ctx.fillStyle = `rgba(147, 197, 253, ${pulse})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ============================================
        // Debug Visualization
        // ============================================
        function drawDebug() {
            if (!debugMode) return;

            ctx.save();

            // Draw food hitboxes
            food.forEach(fd => {
                // Food detection range (just a small marker)
                ctx.strokeStyle = 'rgba(122, 229, 130, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(fd.x, fd.y, 8, 0, Math.PI * 2);
                ctx.stroke();

                // Label
                ctx.setLineDash([]);
                ctx.font = '9px JetBrains Mono';
                ctx.fillStyle = 'rgba(122, 229, 130, 0.7)';
                ctx.fillText('food', fd.x + 10, fd.y + 3);
            });

            // Draw fish debug info
            fish.forEach(f => {
                const bodyWidth = f.bodyWidth || 20;
                const bodyHeight = f.bodyHeight || bodyWidth * 0.4;
                const scaleX = f.scaleX || 1;

                // Mouth position (78% toward nose from center, matching AI code)
                const rawNoseOffset = f.useSvgPath
                    ? (f.noseOffset || bodyWidth)
                    : (f.noseOffset || bodyWidth) * scaleX;
                const mouthOffset = rawNoseOffset * 0.78;

                // Collision oval — MUST match physics formula in drawFishEntities() exactly:
                //   fWidthH = bodyWidth + noseOffset * 0.5
                //   fHeightH = bodyHeight * 1.4
                // The oval is drawn shifted forward by half the nose overhang so it
                // visually wraps the actual fish shape rather than centering on f.x/f.y.
                const debugNoseOff = rawNoseOffset; // same as AI code uses for noseOffset
                const collisionW = bodyWidth + debugNoseOff * 0.5;
                const collisionH = bodyHeight * 1.4;
                // Shift center forward: nose sticks out noseOffset, tail ~bodyWidth behind center.
                // The visual midpoint is (noseOffset - bodyWidth) / 2 ahead of f.x/f.y.
                const ovalCenterShift = (debugNoseOff - bodyWidth) * 0.5;

                // Draw OVAL collision bounds (rotated to fish heading, shifted to match physics)
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.6)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.heading);
                ctx.ellipse(ovalCenterShift, 0, collisionW, collisionH, 0, 0, Math.PI * 2);
                ctx.restore();
                ctx.stroke();

                // Fish body bounds (full visual size, also shifted forward)
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.2)';
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.heading);
                ctx.ellipse(ovalCenterShift, 0, bodyWidth, bodyHeight, 0, 0, Math.PI * 2);
                ctx.restore();
                ctx.stroke();

                // Mouth position - must match the AI code exactly (78% of noseOffset)
                const mouthX = f.x + Math.cos(f.heading) * mouthOffset;
                const mouthY = f.y + Math.sin(f.heading) * mouthOffset;

                // Mouth marker (crosshair)
                ctx.setLineDash([]);
                ctx.strokeStyle = 'rgba(0, 255, 150, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(mouthX - 5, mouthY);
                ctx.lineTo(mouthX + 5, mouthY);
                ctx.moveTo(mouthX, mouthY - 5);
                ctx.lineTo(mouthX, mouthY + 5);
                ctx.stroke();

                // Eating range circle around mouth (must match AI sizeEatRange exactly)
                const sizeCategory = f.sizeCategory || 'medium';
                const BASE_EAT = 35;
                const debugEatRange = sizeCategory === 'large' ? BASE_EAT :
                                      (sizeCategory === 'medium' ? BASE_EAT * 0.5 : BASE_EAT * 0.25);
                ctx.strokeStyle = 'rgba(0, 255, 150, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(mouthX, mouthY, debugEatRange, 0, Math.PI * 2);
                ctx.stroke();

                // Heading direction arrow (current)
                ctx.setLineDash([]);
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.7)';
                ctx.lineWidth = 2;
                const arrowLen = 30;
                const arrowX = f.x + Math.cos(f.heading) * arrowLen;
                const arrowY = f.y + Math.sin(f.heading) * arrowLen;
                ctx.beginPath();
                ctx.moveTo(f.x, f.y);
                ctx.lineTo(arrowX, arrowY);
                ctx.stroke();

                // Arrowhead
                const headLen = 6;
                const headAngle = 0.5;
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(
                    arrowX - Math.cos(f.heading - headAngle) * headLen,
                    arrowY - Math.sin(f.heading - headAngle) * headLen
                );
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(
                    arrowX - Math.cos(f.heading + headAngle) * headLen,
                    arrowY - Math.sin(f.heading + headAngle) * headLen
                );
                ctx.stroke();

                // Target heading (where fish wants to go) - YELLOW dashed
                // This is the accumulated steering force direction
                if (f.targetHeading !== undefined) {
                    // Color based on force magnitude
                    const delta = f.debugTargetDelta || 0;
                    const deltaMag = Math.abs(delta);
                    // Green = little force, Yellow = moderate, Red = heavy steering
                    let targetColor;
                    if (deltaMag < 0.03) targetColor = 'rgba(100, 255, 100, 0.5)';
                    else if (deltaMag < 0.08) targetColor = 'rgba(255, 255, 100, 0.5)';
                    else targetColor = 'rgba(255, 150, 100, 0.6)';

                    ctx.strokeStyle = targetColor;
                    ctx.setLineDash([3, 3]);
                    const targetArrowLen = 22;
                    const targetX = f.x + Math.cos(f.targetHeading) * targetArrowLen;
                    const targetY = f.y + Math.sin(f.targetHeading) * targetArrowLen;
                    ctx.beginPath();
                    ctx.moveTo(f.x, f.y);
                    ctx.lineTo(targetX, targetY);
                    ctx.stroke();

                    // Small label showing force delta
                    if (deltaMag > 0.02) {
                        ctx.font = '7px JetBrains Mono';
                        ctx.fillStyle = targetColor;
                        ctx.fillText((delta * 57.3).toFixed(0) + '°', targetX + 3, targetY);
                    }
                }

                // Center marker
                ctx.setLineDash([]);
                ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
                ctx.beginPath();
                ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw wander target if exists
                if (f.wanderTarget) {
                    ctx.strokeStyle = 'rgba(100, 255, 200, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 4]);
                    ctx.beginPath();
                    ctx.moveTo(f.x, f.y);
                    ctx.lineTo(f.wanderTarget.x, f.wanderTarget.y);
                    ctx.stroke();
                    // Wander target marker
                    ctx.fillStyle = 'rgba(100, 255, 200, 0.4)';
                    ctx.beginPath();
                    ctx.arc(f.wanderTarget.x, f.wanderTarget.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw hunt target line if hunting
                if (f.state === 'hunting' && f.huntTarget !== null) {
                    const prey = fish.find(p => p.id === f.huntTarget);
                    if (prey) {
                        ctx.strokeStyle = 'rgba(255, 50, 50, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([4, 4]);
                        ctx.beginPath();
                        ctx.moveTo(f.x, f.y);
                        ctx.lineTo(prey.x, prey.y);
                        ctx.stroke();
                    }
                }

                // Labels
                ctx.setLineDash([]);
                ctx.font = '9px JetBrains Mono';
                const labelX = f.x + collisionW + 10;

                // Size category label (SMALL/MEDIUM/LARGE) - sizeCategory already defined above
                let sizeColor;
                if (sizeCategory === 'small') sizeColor = 'rgba(150, 220, 150, 0.9)';
                else if (sizeCategory === 'medium') sizeColor = 'rgba(220, 200, 100, 0.9)';
                else sizeColor = 'rgba(150, 150, 220, 0.9)';
                ctx.fillStyle = sizeColor;
                ctx.fillText(sizeCategory.toUpperCase(), labelX, f.y - 14);

                // State label (with hunting indicator)
                let stateColor;
                let stateText = f.state || 'idle';
                if (f.state === 'fleeing') stateColor = 'rgba(255, 100, 100, 1)';
                else if (f.state === 'hunting') { stateColor = 'rgba(255, 50, 50, 0.9)'; stateText = '🎯 hunting'; }
                else if (f.state === 'seeking') stateColor = 'rgba(255, 200, 0, 0.9)';
                else stateColor = 'rgba(100, 200, 255, 0.6)';
                ctx.fillStyle = stateColor;
                ctx.fillText(stateText, labelX, f.y);

                // Personality bar (E/C/N = energy/curiosity/nervousness)
                const e = f.energy || 0.5;
                const c = f.curiosity || 0.4;
                const n = f.nervousness || 0.4;
                ctx.fillStyle = 'rgba(150, 150, 150, 0.4)';
                ctx.fillText(`E${(e*10).toFixed(0)} C${(c*10).toFixed(0)} N${(n*10).toFixed(0)}`, labelX, f.y + 14);

                // Dimensions
                ctx.fillStyle = 'rgba(120, 120, 120, 0.4)';
                ctx.fillText(`${Math.round(bodyWidth)}×${Math.round(bodyHeight)}`, labelX, f.y + 26);

                // ---- NEW DEBUG VISUALIZATIONS ----

                // 1. PREDICTED POSITION (look-ahead) - yellow dotted line
                if (f.debugFutureX !== undefined) {
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)';
                    ctx.setLineDash([3, 3]);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(f.x, f.y);
                    ctx.lineTo(f.debugFutureX, f.debugFutureY);
                    ctx.stroke();
                    // Future position marker
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(f.debugFutureX, f.debugFutureY, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // 2. EDGE AVOIDANCE VECTOR - red/orange when active
                if (f.debugEdgeAvoid && (f.debugEdgeAvoid.x !== 0 || f.debugEdgeAvoid.y !== 0)) {
                    const ea = f.debugEdgeAvoid;
                    const eaLen = Math.sqrt(ea.x * ea.x + ea.y * ea.y) * 20;
                    const eaAngle = Math.atan2(ea.y, ea.x);
                    const eaEndX = f.x + Math.cos(eaAngle) * eaLen;
                    const eaEndY = f.y + Math.sin(eaAngle) * eaLen;

                    ctx.setLineDash([]);
                    ctx.lineWidth = 3;
                    if (ea.emergency) {
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.9)'; // Red = emergency
                    } else if (ea.anticipating) {
                        ctx.strokeStyle = 'rgba(255, 200, 0, 0.6)'; // Orange = anticipating
                    } else {
                        ctx.strokeStyle = 'rgba(255, 100, 50, 0.7)'; // Red-orange = reactive
                    }
                    ctx.beginPath();
                    ctx.moveTo(f.x, f.y);
                    ctx.lineTo(eaEndX, eaEndY);
                    ctx.stroke();

                    // Label
                    ctx.font = '8px JetBrains Mono';
                    ctx.fillStyle = ctx.strokeStyle;
                    const eaLabel = ea.emergency ? 'EMERGENCY' : (ea.anticipating ? 'anticipate' : 'avoid');
                    ctx.fillText(eaLabel, f.x - 20, f.y - collisionH - 5);
                }

                // 3. REVERSAL PRESSURE indicator - orange bar
                if (f.debugReversalPressure > 0) {
                    const barWidth = 30;
                    const barHeight = 4;
                    const filled = Math.min(1, f.debugReversalPressure / 0.5) * barWidth;
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                    ctx.fillRect(f.x - barWidth/2, f.y + collisionH + 5, barWidth, barHeight);
                    ctx.fillStyle = 'rgba(255, 150, 0, 0.8)';
                    ctx.fillRect(f.x - barWidth/2, f.y + collisionH + 5, filled, barHeight);
                    ctx.font = '7px JetBrains Mono';
                    ctx.fillStyle = 'rgba(255, 150, 0, 0.6)';
                    ctx.fillText('flip', f.x - barWidth/2 - 15, f.y + collisionH + 10);
                }

                // 4. FORMATION SLOT for medium fish
                if (f.debugFormationTarget && sizeCategory === 'medium') {
                    const ft = f.debugFormationTarget;
                    // Line to formation target
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                    ctx.setLineDash([2, 2]);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(f.x, f.y);
                    ctx.lineTo(ft.x, ft.y);
                    ctx.stroke();
                    // Slot marker
                    ctx.setLineDash([]);
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(ft.x, ft.y, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    // Slot number
                    ctx.font = '10px JetBrains Mono';
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                    ctx.fillText(ft.slot.toString(), ft.x - 3, ft.y + 4);
                }

                // 5. FOOD TARGET - yellow/gold line when seeking food
                if (f.debugFoodTarget && f.state === 'seeking') {
                    const ft = f.debugFoodTarget;
                    // Line to food target
                    ctx.strokeStyle = 'rgba(255, 200, 50, 0.6)';
                    ctx.setLineDash([3, 3]);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(f.x, f.y);
                    ctx.lineTo(ft.x, ft.y);
                    ctx.stroke();
                    // Food target marker
                    ctx.setLineDash([]);
                    ctx.strokeStyle = 'rgba(255, 200, 50, 0.8)';
                    ctx.fillStyle = 'rgba(255, 200, 50, 0.3)';
                    ctx.beginPath();
                    ctx.arc(ft.x, ft.y, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fill();
                    // Label
                    ctx.font = '8px JetBrains Mono';
                    ctx.fillStyle = 'rgba(255, 200, 50, 0.9)';
                    ctx.fillText('🍕', ft.x - 5, ft.y + 4);
                }

                // 6. BEHAVIOR LOCK for small fish
                if (f.debugBehavior && sizeCategory === 'small') {
                    let behaviorColor;
                    switch(f.debugBehavior) {
                        case 'coral_deep': behaviorColor = 'rgba(0, 200, 100, 0.8)'; break;
                        case 'coral_edge': behaviorColor = 'rgba(200, 200, 0, 0.8)'; break;
                        case 'exploring': behaviorColor = 'rgba(200, 100, 255, 0.8)'; break;
                        case 'returning': behaviorColor = 'rgba(255, 100, 100, 0.8)'; break;
                        default: behaviorColor = 'rgba(150, 150, 150, 0.8)';
                    }
                    ctx.font = '8px JetBrains Mono';
                    ctx.fillStyle = behaviorColor;
                    ctx.fillText(f.debugBehavior, labelX, f.y + 38);

                    // Lock timer bar
                    if (f.behaviorLockTimer > 0) {
                        const lockBarW = 25;
                        const lockFill = Math.min(1, f.behaviorLockTimer / 4000) * lockBarW;
                        ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                        ctx.fillRect(labelX, f.y + 42, lockBarW, 3);
                        ctx.fillStyle = behaviorColor;
                        ctx.fillRect(labelX, f.y + 42, lockFill, 3);
                    }
                }

                // 7. COLLISION VECTORS - pink lines to colliding fish
                if (f.debugCollisions && f.debugCollisions.length > 0) {
                    ctx.strokeStyle = 'rgba(255, 100, 200, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    f.debugCollisions.forEach(col => {
                        ctx.beginPath();
                        ctx.moveTo(f.x, f.y);
                        ctx.lineTo(col.ox, col.oy);
                        ctx.stroke();
                        // Overlap amount
                        const midX = (f.x + col.ox) / 2;
                        const midY = (f.y + col.oy) / 2;
                        ctx.font = '8px JetBrains Mono';
                        ctx.fillStyle = 'rgba(255, 100, 200, 0.8)';
                        ctx.fillText(col.overlap.toFixed(0), midX, midY);
                    });
                }

                // 7. COMMITTED HEADING - green dashed arrow
                if (f.committedHeading !== undefined) {
                    ctx.strokeStyle = 'rgba(100, 255, 100, 0.4)';
                    ctx.setLineDash([2, 2]);
                    ctx.lineWidth = 1;
                    const chLen = 18;
                    const chX = f.x + Math.cos(f.committedHeading) * chLen;
                    const chY = f.y + Math.sin(f.committedHeading) * chLen;
                    ctx.beginPath();
                    ctx.moveTo(f.x, f.y);
                    ctx.lineTo(chX, chY);
                    ctx.stroke();
                }
            });

            // ---- GLOBAL DEBUG: Edge zones and school target ----
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            // Draw edge zones
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;

            // Anticipation zone (180px) - yellow
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.2)';
            ctx.strokeRect(180, 180, w - 360, h - 360);

            // Buffer zone (100px) - orange
            ctx.strokeStyle = 'rgba(255, 150, 0, 0.3)';
            ctx.strokeRect(100, 100, w - 200, h - 200);

            // Hard edge (30px) - red
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.strokeRect(30, 30, w - 60, h - 60);

            // Emergency edge (15px) - bright red
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
            ctx.strokeRect(15, 15, w - 30, h - 30);

            // School target for medium fish (stored globally by drawFishEntities)
            if (window.debugSchoolTarget) {
                const st = window.debugSchoolTarget;
                const reason = window.debugSchoolReason || 'patrol';

                // Color based on reason
                let schoolColor;
                if (reason === 'fleeing') schoolColor = 'rgba(255, 100, 100, 0.8)';
                else if (reason === 'food') schoolColor = 'rgba(100, 255, 100, 0.8)';
                else schoolColor = 'rgba(0, 255, 255, 0.6)';

                ctx.setLineDash([]);
                ctx.strokeStyle = schoolColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(st.x - 12, st.y);
                ctx.lineTo(st.x + 12, st.y);
                ctx.moveTo(st.x, st.y - 12);
                ctx.lineTo(st.x, st.y + 12);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(st.x, st.y, 20, 0, Math.PI * 2);
                ctx.stroke();

                // Label with reason
                ctx.font = '10px JetBrains Mono';
                ctx.fillStyle = schoolColor;
                const reasonLabel = reason === 'fleeing' ? 'SCHOOL:FLEE' :
                                    reason === 'food' ? 'SCHOOL:FOOD' : 'SCHOOL:PATROL';
                ctx.fillText(reasonLabel, st.x - 35, st.y - 25);

                // School heading arrow
                if (window.debugSchoolHeading !== undefined) {
                    const shLen = 35;
                    const shX = st.x + Math.cos(window.debugSchoolHeading) * shLen;
                    const shY = st.y + Math.sin(window.debugSchoolHeading) * shLen;
                    ctx.strokeStyle = schoolColor.replace('0.8', '0.4').replace('0.6', '0.4');
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(st.x, st.y);
                    ctx.lineTo(shX, shY);
                    ctx.stroke();
                }
            }

            // Draw jellyfish bounds
            jellyfish.forEach(j => {
                if (!j.shape) return;
                ctx.strokeStyle = 'rgba(199, 125, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(j.x, j.y, j.shape.bellRadius * 1.5, 0, Math.PI * 2);
                ctx.stroke();
            });

            ctx.setLineDash([]);
            ctx.restore();
        }

        // Animation loop - smart pausing when idle
        let animationFrameId = null;
        let isAnimating = false;

        function hasActiveAnimation() {
            return isDrawing ||
                   debugMode ||
                   particles.length > 0 ||
                   ripples.length > 0 ||
                   strokes.length > 0 ||
                   jellyfish.length > 0 ||
                   fish.length > 0 ||
                   coral.length > 0 ||
                   bubbles.length > 0 ||
                   food.length > 0 ||
                   tempLines.length > 0 ||
                   currentStroke !== null;
        }

        function animate() {
            drawGrid();
            drawAmbientParticles();
            drawCoralEntities();
            drawFoodEntities();
            drawFishEntities();
            drawJellyfishEntities();
            drawBubbleEntities();
            drawTempLineEntities();
            drawRawStrokes();
            drawRipples();
            drawParticles();
            drawCursor();
            drawDebug();

            // Only continue animation if there's something active
            if (hasActiveAnimation()) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                isAnimating = false;
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (!isAnimating) {
                isAnimating = true;
                animate();
            }
        }

        // Start initial animation
        startAnimation();

        // ============================================
        // Spawn one small fish at launch (random color)
        // ============================================
        (function spawnLaunchFish() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            // Small fish: bodyWidth < 35 (bw = bodyLen * 1.05)
            // bodyLen 18–28 → bw ≈ 19–29 (safely small)
            const bodyLen = 18 + Math.random() * 10;   // 18–28
            const bodyH   = bodyLen * 0.55;
            const tailLen = bodyLen * 0.6;
            const tailSpread = bodyH * 0.9;
            const bodyCenter = bodyLen * 0.1;

            const pts = [];
            pts.push({ x:  bodyLen - bodyCenter,                     y:  0 });
            pts.push({ x:  bodyLen * 0.7 - bodyCenter,               y: -bodyH * 0.5 });
            pts.push({ x:  bodyLen * 0.3 - bodyCenter,               y: -bodyH * 0.8 });
            pts.push({ x: -bodyLen * 0.2 - bodyCenter,               y: -bodyH * 0.6 });
            pts.push({ x: -bodyLen * 0.5 - bodyCenter,               y: -bodyH * 0.3 });
            pts.push({ x: -bodyLen * 0.5 - tailLen - bodyCenter,     y: -tailSpread });
            pts.push({ x: -bodyLen * 0.5 - tailLen * 0.5 - bodyCenter, y: 0 });
            pts.push({ x: -bodyLen * 0.5 - tailLen - bodyCenter,     y:  tailSpread });
            pts.push({ x: -bodyLen * 0.5 - bodyCenter,               y:  bodyH * 0.3 });
            pts.push({ x: -bodyLen * 0.2 - bodyCenter,               y:  bodyH * 0.6 });
            pts.push({ x:  bodyLen * 0.3 - bodyCenter,               y:  bodyH * 0.8 });
            pts.push({ x:  bodyLen * 0.7 - bodyCenter,               y:  bodyH * 0.5 });
            pts.push({ x:  bodyLen - bodyCenter,                     y:  0 });

            // Bounds → bodyWidth (half-width) → confirms small range
            const xs = pts.map(p => p.x);
            const actualW = Math.max(...xs) - Math.min(...xs);
            const bw = actualW / 2;  // half-width ≈ 19–29 (small: < 35)

            const heading = Math.random() < 0.5 ? 0 : Math.PI;
            const hueShift = Math.floor(Math.random() * 360);  // full random color

            fish.push({
                id: entityIdCounter++,
                points: pts,
                bodyWidth: bw,
                bodyHeight: bodyH,
                noseOffset: bodyLen - bodyCenter,
                isStrokeBased: false,
                percRanges: {
                    separation: bw * 2.5,
                    alignment:  bw * 5,
                    cohesion:   bw * 7
                },
                x: w * (0.3 + Math.random() * 0.4),   // Middle 40% horizontally
                y: h * (0.35 + Math.random() * 0.3),   // Middle zone vertically
                size: bw * 2,
                vx: Math.cos(heading) * 0.4,
                vy: Math.sin(heading) * 0.4,
                heading: heading,
                targetHeading: heading,
                cruiseAngle: heading,
                cruiseTimer: 5000 + Math.random() * 3000,
                state: 'idle',
                hueShift: hueShift,
                scaleX: 0.9 + Math.random() * 0.2,
                scaleY: 0.9 + Math.random() * 0.2,
                energy:      0.3 + Math.random() * 0.7,
                curiosity:   0.2 + Math.random() * 0.6,
                nervousness: 0.2 + Math.random() * 0.6,
                wanderTarget: null,
                wanderTimer: 0,
                restTimer: 0,
                currentSpeed: 0.4,
                huntTarget: null,
                lastAteAt: 0,
                createdAt: Date.now()
            });

            startAnimation();  // Ensure loop is running with the new fish
        })();

        // ============================================
        // Event Handlers
        // ============================================
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function startDraw(e) {
            e.preventDefault();
            isDrawing = true;
            hero.classList.add('drawing');
            startAnimation(); // Ensure animation loop is running

            const pos = getPos(e);
            currentStroke = {
                points: [pos],
                startTime: Date.now(),
                fadeStart: TIMING.strokeHold
            };
            strokes.push(currentStroke);
        }
        
        function draw(e) {
            const pos = getPos(e);
            cursorPos = pos;
            cursorVisible = true;
            
            if (!isDrawing || !currentStroke) return;
            e.preventDefault();
            currentStroke.points.push(pos);
        }
        
        function endDraw() {
            if (!currentStroke) {
                isDrawing = false;
                return;
            }

            const points = [...currentStroke.points];
            const classified = classifyStroke(points);

            if (classified) {
                const id = entityIdCounter++;
                const now = Date.now();

                if (classified.type === 'food') {
                    // FIFO: remove oldest if at limit
                    if (food.length >= MAX_FOOD) food.shift();
                    food.push({
                        id,
                        x: classified.center.x,
                        y: classified.center.y,
                        createdAt: now,
                        inBubble: false // Updated each frame in drawBubbleEntities()
                    });

                    // Ripple feedback
                    ripples.push({
                        x: classified.center.x,
                        y: classified.center.y,
                        createdAt: now,
                        maxRadius: 30
                    });

                } else if (classified.type === 'bubble') {
                    if (bubbles.length >= MAX_BUBBLES) bubbles.shift();
                    bubbles.push({
                        id,
                        x: classified.center.x,
                        y: classified.center.y,
                        radius: classified.radius,
                        vy: 0.3 + Math.random() * 0.4,
                        createdAt: now
                    });

                } else if (classified.type === 'coral') {
                    if (coral.length >= MAX_CORAL) coral.shift();
                    coral.push({
                        id,
                        shape: classified.shape,
                        x: classified.center.x,
                        y: classified.center.y,
                        size: classified.size,
                        settled: false,
                        createdAt: now
                    });

                } else if (classified.type === 'fish') {
                    const fishShape = classified.fishShape;
                    const newBodyWidth = fishShape.bodyWidth || 20;

                    // ---- SIZE-SPECIFIC CAPS to prevent chaos ----
                    const SMALL_THRESHOLD = 35;
                    const MEDIUM_THRESHOLD = 60;
                    const isNewLarge = newBodyWidth >= MEDIUM_THRESHOLD;
                    const isNewMedium = newBodyWidth >= SMALL_THRESHOLD && newBodyWidth < MEDIUM_THRESHOLD;
                    const isNewSmall = newBodyWidth < SMALL_THRESHOLD;

                    // Count existing fish by size
                    let largeCount = 0, mediumCount = 0, smallCount = 0;
                    fish.forEach(f => {
                        const bw = f.bodyWidth || 20;
                        if (bw >= MEDIUM_THRESHOLD) largeCount++;
                        else if (bw >= SMALL_THRESHOLD) mediumCount++;
                        else smallCount++;
                    });

                    // ---- SIZE-SPECIFIC CAPS: Remove oldest of same type (not block spawn) ----
                    // This prevents drawing glitch where user draws but nothing appears
                    if (isNewLarge && largeCount >= MAX_LARGE_FISH) {
                        // Find and remove oldest large fish
                        const oldestIdx = fish.findIndex(f => (f.bodyWidth || 20) >= MEDIUM_THRESHOLD);
                        if (oldestIdx !== -1) fish.splice(oldestIdx, 1);
                    }
                    if (isNewMedium && mediumCount >= MAX_MEDIUM_FISH) {
                        // Find and remove oldest medium fish
                        const oldestIdx = fish.findIndex(f => {
                            const bw = f.bodyWidth || 20;
                            return bw >= SMALL_THRESHOLD && bw < MEDIUM_THRESHOLD;
                        });
                        if (oldestIdx !== -1) fish.splice(oldestIdx, 1);
                    }
                    if (isNewSmall && smallCount >= MAX_SMALL_FISH) {
                        // Find and remove oldest small fish
                        const oldestIdx = fish.findIndex(f => (f.bodyWidth || 20) < SMALL_THRESHOLD);
                        if (oldestIdx !== -1) fish.splice(oldestIdx, 1);
                    }

                    // Overall cap - remove oldest if still over limit
                    if (fish.length >= MAX_FISH) fish.shift();

                    const heading = fishShape.initialHeading;
                    const hueShift = (id * 47) % 360;

                    // Personality traits (0-1 scale)
                    const energy = 0.3 + Math.random() * 0.7;      // Lazy to hyperactive
                    const curiosity = 0.2 + Math.random() * 0.6;   // Stick to area vs explore
                    const nervousness = 0.2 + Math.random() * 0.6; // Calm vs easily startled

                    // For large fish, randomize initial heading to prevent clustering
                    const isLargeFish = newBodyWidth >= MEDIUM_THRESHOLD;
                    let initialHeading = heading;
                    if (isLargeFish) {
                        // Random horizontal direction for large fish
                        initialHeading = Math.random() < 0.5 ? 0 : Math.PI;
                        initialHeading += (Math.random() - 0.5) * 0.6;
                    }

                    // ---- SPAWN POSITION VALIDATION ----
                    // Adjust spawn position if too close to edges
                    const w = canvas.width / (window.devicePixelRatio || 1);
                    const h = canvas.height / (window.devicePixelRatio || 1);
                    const SPAWN_MARGIN = 80;
                    let spawnX = classified.center.x;
                    let spawnY = classified.center.y;

                    // Clamp to safe zone
                    spawnX = Math.max(SPAWN_MARGIN, Math.min(w - SPAWN_MARGIN, spawnX));
                    spawnY = Math.max(SPAWN_MARGIN, Math.min(h - SPAWN_MARGIN, spawnY));

                    // Large fish: push toward upper area (their territory)
                    if (isLargeFish && spawnY > h * 0.5) {
                        spawnY = h * 0.35 + Math.random() * h * 0.15;
                    }

                    // Adjust heading to point away from nearest edge
                    if (spawnX < w * 0.2) initialHeading = 0 + (Math.random() - 0.5) * 0.5;
                    else if (spawnX > w * 0.8) initialHeading = Math.PI + (Math.random() - 0.5) * 0.5;
                    if (spawnY < h * 0.15) initialHeading = Math.PI * 0.5 + (Math.random() - 0.5) * 0.5;
                    else if (spawnY > h * 0.85) initialHeading = -Math.PI * 0.5 + (Math.random() - 0.5) * 0.5;

                    const spawnBw = fishShape.bodyWidth || 20;
                    fish.push({
                        id,
                        points: fishShape.points,
                        bodyPoints: fishShape.bodyPoints,
                        throughLine: fishShape.throughLine,
                        bodyWidth: spawnBw,
                        bodyHeight: fishShape.bodyHeight,
                        noseOffset: fishShape.noseOffset,
                        isStrokeBased: fishShape.isStrokeBased,
                        useSvgPath: fishShape.useSvgPath,
                        scaleFactor: fishShape.scaleFactor,
                        // Cache perception ranges at spawn - bodyWidth never changes
                        percRanges: {
                            separation: spawnBw * 2.5,
                            alignment: spawnBw * 5,
                            cohesion: spawnBw * 7
                        },
                        x: spawnX,  // Use validated spawn position
                        y: spawnY,  // Use validated spawn position
                        size: classified.size,
                        vx: Math.cos(initialHeading) * 0.4,
                        vy: Math.sin(initialHeading) * 0.4,
                        heading: initialHeading,
                        targetHeading: initialHeading,
                        cruiseAngle: initialHeading, // Initialize cruise angle
                        cruiseTimer: 5000 + Math.random() * 3000, // Stagger cruise timer
                        state: 'idle',
                        hueShift: hueShift,
                        scaleX: 0.9 + Math.random() * 0.2,
                        scaleY: 0.9 + Math.random() * 0.2,
                        // Personality
                        energy: energy,
                        curiosity: curiosity,
                        nervousness: nervousness,
                        // Wander system
                        wanderTarget: null,
                        wanderTimer: 0,
                        restTimer: 0,
                        currentSpeed: 0.4,
                        // Hunting (for large fish)
                        huntTarget: null,
                        lastAteAt: 0,
                        createdAt: now
                    });

                } else if (classified.type === 'jellyfish') {
                    if (jellyfish.length >= MAX_JELLYFISH) jellyfish.shift();
                    const w = canvas.width / (window.devicePixelRatio || 1);
                    const h = canvas.height / (window.devicePixelRatio || 1);
                    // Initialize orbit around center of tank
                    const orbitAngle = Math.random() * Math.PI * 2;
                    jellyfish.push({
                        id,
                        shape: classified.shape,
                        x: classified.center.x,
                        y: classified.center.y,
                        size: classified.size,
                        vx: 0,
                        vy: 0,
                        orbitAngle: orbitAngle,
                        orbitRadius: 80 + Math.random() * 60,
                        orbitSpeed: 0.0003 + Math.random() * 0.0002,
                        orbitCenterX: w / 2,
                        orbitCenterY: h * 0.4,
                        pulsePhase: Math.random() * Math.PI * 2,
                        createdAt: now
                    });

                } else if (classified.type === 'line') {
                    tempLines.push({
                        id,
                        points: classified.points,
                        createdAt: now
                    });
                }

                // Particle burst feedback — only for confident recognitions
                // Borderline matches (low score, small loop) get no burst
                if (classified.type !== 'line' && classified.confident) {
                    const burstCount = classified.type === 'food' ? 4 : 8;
                    for (let i = 0; i < burstCount; i++) {
                        const angle = (i / burstCount) * Math.PI * 2;
                        particles.push({
                            x: classified.center.x,
                            y: classified.center.y,
                            vx: Math.cos(angle) * (1 + Math.random()),
                            vy: Math.sin(angle) * (1 + Math.random()),
                            life: 1,
                            createdAt: Date.now()
                        });
                    }
                }

                // Hide raw stroke quickly since entity is now rendered
                currentStroke.fadeStart = 0;
                startAnimation();
            }

            isDrawing = false;
            currentStroke = null;
            setTimeout(() => {
                if (!isDrawing) hero.classList.remove('drawing');
            }, 500);
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseleave', () => { endDraw(); cursorVisible = false; });
        canvas.addEventListener('mouseenter', () => { cursorVisible = true; });
        
        canvas.addEventListener('touchstart', startDraw, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', endDraw);
        canvas.addEventListener('touchcancel', endDraw);

        // Debug toggle
        const debugToggle = document.getElementById('toggleDebug');
        if (debugToggle) {
            debugToggle.addEventListener('change', (e) => {
                debugMode = e.target.checked;
                startAnimation();
            });
        }

        // Draw hint — fades after 5 completed strokes, persists via localStorage
        // Counts on pointerup (completed draw) not mousedown, so hint stays visible while drawing
        const heroDrawHint = document.getElementById('heroDrawHint');
        if (heroDrawHint) {
            const HINT_KEY = 'drawHintCount_v2';
            const HINT_THRESHOLD = 5;
            let drawHintCount = parseInt(localStorage.getItem(HINT_KEY) || '0', 10);

            function bumpDrawHint() {
                if (drawHintCount >= HINT_THRESHOLD) return;
                drawHintCount++;
                localStorage.setItem(HINT_KEY, drawHintCount);
                if (drawHintCount >= HINT_THRESHOLD) {
                    heroDrawHint.classList.add('hidden');
                }
            }

            // Already seen enough times — hide immediately (no display:none so layout stays stable)
            if (drawHintCount >= HINT_THRESHOLD) {
                heroDrawHint.classList.add('hidden');
            }

            // Count on completed strokes (pointerup), not on press — keeps hint visible while drawing
            canvas.addEventListener('pointerup', bumpDrawHint);
        }

        // Click to scare fish - check if click hit a fish
        function scareFishAtPoint(x, y) {
            const SCARE_RADIUS = 60; // How close click needs to be
            let scared = false;

            fish.forEach(f => {
                const dx = x - f.x;
                const dy = y - f.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Check if click is within fish's general area
                const hitRadius = Math.max(f.bodyWidth || 30, f.bodyHeight || 20) + SCARE_RADIUS;

                if (dist < hitRadius) {
                    // Scare this fish! Flee away from click point
                    f.state = 'fleeing';
                    f.stateChangeCooldown = 1000;  // Commit to fleeing
                    f.fleeTimer = 800 + Math.random() * 400; // Flee for 0.8-1.2 seconds
                    const fleeAngle = Math.atan2(f.y - y, f.x - x); // Away from click
                    f.targetHeading = fleeAngle;
                    f.committedHeading = fleeAngle;  // Commit to this direction
                    f.reversalPressure = 0;  // Allow quick turn
                    // Don't set f.heading directly - let smoothing handle it
                    scared = true;

                    // Burst of particles at fish location
                    for (let i = 0; i < 4; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        particles.push({
                            x: f.x, y: f.y,
                            vx: Math.cos(angle) * 2,
                            vy: Math.sin(angle) * 2,
                            life: 1, createdAt: Date.now()
                        });
                    }
                }
            });

            return scared;
        }

        // Add click listener for scaring fish
        canvas.addEventListener('click', (e) => {
            const pos = getPos(e);
            if (scareFishAtPoint(pos.x, pos.y)) {
                startAnimation();
            }
        });

        // ============================================
        // Cursor Spotlight Effect
        // ============================================
        const spotlight = document.getElementById('cursorSpotlight');
        let spotlightX = window.innerWidth / 2;
        let spotlightY = window.innerHeight / 2;
        let isSpotlightActive = false;

        function updateSpotlight(x, y) {
            spotlightX = x;
            spotlightY = y;
            const xPercent = (x / window.innerWidth) * 100;
            const yPercent = (y / window.innerHeight) * 100;
            spotlight.style.background = `radial-gradient(600px circle at ${xPercent}% ${yPercent}%, rgba(77, 201, 246, 0.12), rgba(212, 175, 55, 0.06) 40%, transparent 70%)`;
        }

        // Mouse events
        document.addEventListener('mousemove', (e) => {
            if (!isSpotlightActive) {
                spotlight.classList.add('active');
                isSpotlightActive = true;
            }
            updateSpotlight(e.clientX, e.clientY);
        });

        document.addEventListener('mouseleave', () => {
            spotlight.classList.remove('active');
            isSpotlightActive = false;
        });

        // Touch events
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 0) {
                spotlight.classList.add('active');
                isSpotlightActive = true;
                updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            // Keep spotlight visible for a moment after touch ends
            setTimeout(() => {
                if (!isSpotlightActive) {
                    spotlight.classList.remove('active');
                }
            }, 2000);
        });

        // ============================================
        // Demo Canvas - Interactive Fish Animation
        // ============================================
    </script>
</body>
</html>
