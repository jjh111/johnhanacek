<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>John Hanacek - Portfolio</title>
    <meta name="description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems. LLMs, XR, robotics.">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="./Assets/favicon-jhsigfrmpaper.png">

    <!-- Open Graph / Social Share -->
    <meta property="og:title" content="John Hanacek - Portfolio">
    <meta property="og:description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems.">
    <meta property="og:image" content="https://www.johnhanacek.com/Assets/socialgraph-jhcom.png">
    <meta property="og:url" content="https://www.johnhanacek.com/">
    <meta property="og:type" content="website">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="John Hanacek - Portfolio">
    <meta name="twitter:description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems.">
    <meta name="twitter:image" content="https://www.johnhanacek.com/Assets/socialgraph-jhcom.png">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Raleway:wght@100;200;300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles/shared.css">

    <!-- Structured Data for AI/Search -->
    <link rel="alternate" type="application/json" href="./john-hanacek.json" title="Structured data">
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "ProfilePage",
        "mainEntity": {
            "@type": "Person",
            "name": "John Hanacek",
            "url": "https://www.johnhanacek.com",
            "image": "https://www.johnhanacek.com/Assets/socialgraph-jhcom.png",
            "jobTitle": ["Founding Designer", "Design Engineer", "Product Designer"],
            "description": "Founding Designer & Design Engineer building at the intersection of AI, spatial computing, and human-computer symbiosis.",
            "email": "hi@johnhanacek.com",
            "sameAs": [
                "https://www.linkedin.com/in/johnhanacek/",
                "https://bsky.app/profile/johnhanacek.bsky.social",
                "https://x.com/johnhanacek"
            ],
            "knowsAbout": ["AI-native product design", "Agentic systems", "LLM integration", "XR/Spatial interface design", "Design engineering", "MetaMedium", "Robotics"],
            "worksFor": {
                "@type": "Organization",
                "name": "JH Design LLC"
            }
        }
    }
    </script>

    <style>
        /* Debug toggle for fish minigame */
        .canvas-controls {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 1rem;
            z-index: 100;
            opacity: 0.6;
            transition: opacity 0.2s ease;
        }
        .canvas-controls:hover {
            opacity: 1;
        }
        .canvas-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(125, 216, 247, 0.5);
            cursor: pointer;
        }
        .canvas-toggle input {
            display: none;
        }
        .toggle-switch {
            width: 28px;
            height: 14px;
            background: rgba(10, 22, 40, 0.6);
            border: 1px solid rgba(77, 201, 246, 0.2);
            border-radius: 7px;
            position: relative;
            transition: all 0.2s ease;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 8px;
            height: 8px;
            background: rgba(125, 216, 247, 0.4);
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        .canvas-toggle input:checked + .toggle-switch {
            background: rgba(77, 201, 246, 0.15);
            border-color: rgba(77, 201, 246, 0.4);
        }
        .canvas-toggle input:checked + .toggle-switch::after {
            left: 16px;
            background: rgba(125, 216, 247, 0.9);
            box-shadow: 0 0 6px rgba(77, 201, 246, 0.5);
        }
        .canvas-toggle:hover {
            color: rgba(125, 216, 247, 0.7);
        }
    </style>
</head>
<body>
    <!-- Interactive Cursor Spotlight -->
    <div id="cursorSpotlight"></div>

    <a href="#about" class="skip-link">Skip to main content</a>

    <nav id="nav" role="navigation" aria-label="Main navigation">
        <div class="nav-inner">
            <div class="nav-left">
                <a href="index.html" class="shape-link active" aria-label="Home" aria-current="page">
                    <svg class="shape triangle" viewBox="0 0 40 40"><polygon points="20,8 34,32 6,32"/></svg>
                    <img class="shape-label shape-label-img" src="./Assets/footer-JHsig.png" alt="JH">
                </a>
                <a href="design.html" class="shape-link" aria-label="Design">
                    <svg class="shape rounded-square" viewBox="0 0 40 40"><rect x="6" y="6" width="28" height="28" rx="6"/></svg>
                    <span class="shape-label">DESIGN</span>
                </a>
                <a href="art.html" class="shape-link" aria-label="Art">
                    <svg class="shape circle" viewBox="0 0 40 40"><circle cx="20" cy="20" r="14"/></svg>
                    <span class="shape-label">ART</span>
                </a>
                <a href="index.html" class="nav-title">John Hanacek</a>
                <a href="about.html" class="shape-link secondary" aria-label="About">
                    <svg class="shape diamond" viewBox="0 0 40 40"><polygon points="20,6 34,20 20,34 6,20"/></svg>
                    <span class="shape-label">ABOUT</span>
                </a>
                <a href="services.html" class="shape-link secondary" aria-label="Services">
                    <svg class="shape star" viewBox="0 0 40 40"><polygon points="20,6 23,16 34,16 25,22 28,34 20,26 12,34 15,22 6,16 17,16"/></svg>
                    <span class="shape-label">SERVICES</span>
                </a>
            </div>
            <button class="nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-right">
                <li><a href="#about">About</a></li>
                <li><a href="#believe">I Believe</a></li>
                <li><a href="#highlights">Highlights</a></li>
                <li><a href="#endorsements">Endorsements</a></li>
                <li><a href="#explore">Explore</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </div>
    </nav>

    <header class="hero" id="top">
        <!-- Shape Navigation (hero) -->
        <nav class="shape-nav" aria-label="Page navigation">
            <a href="index.html" class="shape-link active" aria-label="Home" aria-current="page">
                <svg class="shape triangle" viewBox="0 0 40 40"><polygon points="20,8 34,32 6,32"/></svg>
                <img class="shape-label shape-label-img" src="./Assets/footer-JHsig.png" alt="JH">
            </a>
            <a href="design.html" class="shape-link" aria-label="Design">
                <svg class="shape rounded-square" viewBox="0 0 40 40"><rect x="6" y="6" width="28" height="28" rx="6"/></svg>
                <span class="shape-label">DESIGN</span>
            </a>
            <a href="art.html" class="shape-link" aria-label="Art">
                <svg class="shape circle" viewBox="0 0 40 40"><circle cx="20" cy="20" r="14"/></svg>
                <span class="shape-label">ART</span>
            </a>
        </nav>

        <!-- Interactive Blueprint Canvas -->
        <canvas id="heroCanvas"></canvas>
        <div class="hero-hint">
            <span class="hint-icon">✎</span>
            <span class="hint-text">draw</span>
        </div>

        <!-- Debug Controls -->
        <div class="canvas-controls">
            <label class="canvas-toggle">
                <input type="checkbox" id="toggleDebug">
                <span class="toggle-switch"></span>
                Debug
            </label>
        </div>

        <div class="hero-content">
            <h1>John <span class="meta">Hanacek</span></h1>
            <p class="tagline">DESIGN ENGINEER · PRODUCT DESIGNER · ARTIST</p>
            <p class="byline"> <span class="role">Sounds like · (Hana-check)</span></p>
            <img class="hero-sig-inline" src="./Assets/footer-JHsig.png" alt="John Hanacek signature">
        </div>
        <a href="#about" class="scroll-indicator" aria-label="Scroll to content">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                <path d="M7 13l5 5 5-5M7 6l5 5 5-5"/>
            </svg>
            <span class="scroll-text">goto content</span>
        </a>
    </header>

    <main>
        <!-- ABOUT -->
        <section id="about">
            <h2>About</h2>

            <div class="content-card about">
                <p><strong>Founding Designer </strong>& <strong>Design Engineer</strong> building at the intersection of AI, spatial computing, and human-computer symbiosis.</p>
                <p>I design and develop <strong>agentic systems</strong>, XR interfaces, and AI-augmented tools. Currently exploring <strong>MetaMedium</strong> concepts, dynamic design systems that blur the line between tool and medium, and a self improving automated research framework <strong>Earth Star </strong>using OpenClaw.</p>
            </div>
        </section>

        <!-- I BELIEVE -->
        <section id="believe">
            <h2>I Believe</h2>

            <div class="content-card">
                <p>Imagination is within reality.</p>
                <p>Infinite Games are more powerful than Finite Games.</p>
                <p>Technology can augment human intelligence & collaboration.</p>
                <p>Optimism and pessimism are self-fulfilling prophecies.</p>
                <p>We can choose better prophecies...</p>
            </div>
        </section>

        <!-- HIGHLIGHTS -->
        <section id="highlights">
            <h2>Highlights</h2>

            <div class="card-grid cols-3">
                <div class="content-card" data-num="01">
                    <h4>Georgetown MA 2016</h4>
                    <p>Awarded <strong>"Most Meta"</strong> by peers in Communication, Culture & Technology</p>
                </div>

                <div class="content-card" data-num="02">
                    <h4>Founder Institute 2020</h4>
                    <p>Graduate as CEO of <strong><a href="https://www.avatarmedic.com" target="_blank" rel="noopener">AvatarMEDIC</a></strong></p>
                </div>

                <div class="content-card" data-num="03">
                    <h4>Aerospace Medical Association 2022</h4>
                    <p><strong>R&D Innovation Award</strong> for XR Digital Twin robotics control</p>
                </div>
            </div>
        </section>



        <!-- ENDORSEMENTS -->
        <section id="endorsements">
            <h2>Featured Endorsements</h2>

            <div class="grid-2">
                <div class="content-card endorsement">
                    <p>"My choice for the most plausible vision of a future I desire goes to John Hanacek's scenario. I think I'd like to live there, and I think it is plausible in 100 years. My $100 goes to him."</p>
                    <cite><strong><a href="https://kk.org/thetechnium/a-desirable-future-haiku/" target="_blank" rel="noopener">Kevin Kelly</a></strong>, Futurist, Founder of Wired Magazine</cite>
                </div>

                <div class="content-card endorsement short">
                    <p>"Talented and very experienced designer!"</p>
                    <cite><strong><a href="https://www.linkedin.com/in/ipetryaevskaya/" target="_blank" rel="noopener">Inga Petryaevskaya</a></strong>, CEO <a href="https://www.shapesxr.com" target="_blank" rel="noopener">ShapesXR</a></cite>
                </div>
            </div>
        </section>

        <!-- EXPLORE & CONTACT - side by side on widescreen -->
        <div class="widescreen-split">
            <section id="explore">
                <h2>Explore</h2>

                <div class="content-card">
                    <h4><a href="design.html">Design Portfolio</a></h4>
                    <p>Professional work, case studies, and XR projects</p>
                </div>

                <div class="content-card">
                    <h4><a href="art.html">Art & Creative</a></h4>
                    <p>Visual art, photography, and creative experiments</p>
                </div>

                <div class="content-card">
                    <h4><a href="about.html">About & Experience</a></h4>
                    <p>Full bio, work history, and expertise</p>
                </div>

                <div class="content-card">
                    <h4><a href="services.html">Services & Consulting</a></h4>
                    <p>Founding designer, design engineering, and AI product services</p>
                </div>
            </section>

            <section id="contact">
                <h2>Contact</h2>

                <div class="content-card">
                    <h4>Email</h4>
                    <p><a href="mailto:hi@johnhanacek.com">hi@johnhanacek.com</a></p>

                    <h4>Writing</h4>
                    <ul>
                        <li><a href="https://spatialandimmersivedesign.substack.com/" target="_blank" rel="noopener">Spatial & Immersive Design Blog</a></li>
                        <li><a href="https://johnhanacek.substack.com" target="_blank" rel="noopener">Personal Blog (Tech, Strategy & Research)</a></li>
                    </ul>

                    <h4>Social</h4>
                    <ul>
                        <li><a href="https://bsky.app/profile/johnhanacek.bsky.social" target="_blank" rel="noopener">Bluesky</a></li>
                        <li><a href="https://x.com/johnhanacek" target="_blank" rel="noopener">X (Twitter)</a></li>
                        <li><a href="https://www.linkedin.com/in/johnhanacek/" target="_blank" rel="noopener">LinkedIn</a></li>
                    </ul>
                </div>
            </section>
        </div>

    </main>

    <footer>
        <p class="footer-title">John Hanacek</p>
        <p class="footer-subtitle">Founding Designer · Design Engineer · Product Designer</p>
        <p class="footer-copyright">© 2026 John Hanacek · JHDesign LLC </p>
        <p class="footer-signature"><img src="./Assets/footer-JHsig.png" alt="John Hanacek signature" loading="lazy"></p>
        <p class="version">Portfolio v1.0 · Updated January 2026 · Made with Claude Code</p>
    </footer>

    <script>
        // Navigation scroll visibility - show after scrolling past hero
        const nav = document.getElementById('nav');
        const hero = document.querySelector('.hero');

        function updateNavVisibility() {
            const heroBottom = hero.offsetTop + hero.offsetHeight - 60;
            if (window.scrollY > heroBottom) {
                nav.classList.add('visible');
            } else {
                nav.classList.remove('visible');
            }
        }

        window.addEventListener('scroll', updateNavVisibility);
        window.addEventListener('resize', updateNavVisibility);
        updateNavVisibility();

        // Mobile navigation toggle
        const navToggle = document.querySelector('.nav-toggle');
        const navMenu = document.querySelector('nav ul');

        navToggle.addEventListener('click', function() {
            const isExpanded = this.getAttribute('aria-expanded') === 'true';
            this.setAttribute('aria-expanded', !isExpanded);
            this.classList.toggle('active');
            navMenu.classList.toggle('open');
        });

        // Close menu when clicking a link
        navMenu.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', () => {
                navToggle.setAttribute('aria-expanded', 'false');
                navToggle.classList.remove('active');
                navMenu.classList.remove('open');
            });
        });
    </script>

    <!-- Hero Canvas Drawing Interaction -->
    <script>
        const canvas = document.getElementById('heroCanvas');
        const ctx = canvas.getContext('2d');
        
        // ============================================
        // Unified Timing Constants (in ms)
        // ============================================
        const TIMING = {
            strokeHold: 1500,       // Time before stroke starts fading
            strokeFade: 2000,       // Fade duration for strokes
        };
        TIMING.strokeTotal = TIMING.strokeHold + TIMING.strokeFade;
        
        let isDrawing = false;
        let strokes = [];           // Raw strokes (fade out)
        let currentStroke = null;
        let ripples = [];           // Tap ripple effects
        let particles = [];         // Recognition particle bursts
        let ambientParticles = [];  // Floating ambient particles

        // ============================================
        // Entity State (Fish Minigame)
        // ============================================
        let jellyfish = [];
        let fish = [];
        let coral = [];
        let bubbles = [];
        let food = [];
        let tempLines = [];
        let entityIdCounter = 0;

        const MAX_JELLYFISH = 3;
        const MAX_FISH = 10;
        const MAX_CORAL = 6;
        const MAX_BUBBLES = 20;
        const MAX_FOOD = 12;
        const FOOD_LIFETIME = 15000;
        const LINE_DURATION = 1500;

        // Debug mode - toggle with UI
        let debugMode = false;

        const aquaColors = {
            jellyfish: ['#c77dff', '#a78bfa', '#e879f9'],
            fish: ['#00d9ff', '#4dc9f6', '#38bdf8'],
            coral: ['#ff6ec7', '#f472b6', '#fb7185'],
            bubble: 'rgba(77, 201, 246, 0.3)',
            food: '#7ae582',
            line: 'rgba(77, 201, 246, 0.5)'
        };

        // Deep Sea Terminal color palette
        const colors = {
            bg: '#020a12',
            stroke: 'rgba(77, 201, 246, 0.85)',
            cursor: 'rgba(212, 175, 55, 0.85)',
            glow: 'rgba(77, 201, 246, 0.4)',
        };

        // ============================================
        // Helper Functions
        // ============================================
        function getBounds(points) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            points.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            return { minX, minY, maxX, maxY };
        }

        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        // Shortest angular difference (returns value in [-PI, PI])
        function angleDiff(target, current) {
            let d = target - current;
            while (d > Math.PI) d -= Math.PI * 2;
            while (d < -Math.PI) d += Math.PI * 2;
            return d;
        }

        // Check if food position is inside any bubble (hidden from fish)
        function isFoodInBubble(fx, fy) {
            for (let i = 0; i < bubbles.length; i++) {
                const b = bubbles[i];
                const dx = fx - b.x;
                const dy = fy - b.y;
                if (dx * dx + dy * dy < b.radius * b.radius) return true;
            }
            return false;
        }

        // Check if line segment intersects a circle
        function segmentIntersectsCircle(p1, p2, cx, cy, r) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const fx = p1.x - cx;
            const fy = p1.y - cy;
            const a = dx * dx + dy * dy;
            const b2 = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - r * r;
            let disc = b2 * b2 - 4 * a * c;
            if (disc < 0) return false;
            disc = Math.sqrt(disc);
            const t1 = (-b2 - disc) / (2 * a);
            const t2 = (-b2 + disc) / (2 * a);
            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
        }

        function getCircleScore(points, center, radius) {
            let totalError = 0;
            points.forEach(p => {
                const dist = distance(p, center);
                totalError += Math.abs(dist - radius) / radius;
            });
            return Math.max(0, 1 - (totalError / points.length));
        }

        // Exact scoring functions from design.html
        function getRectScore(points, bounds) {
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            let cornerCount = 0;
            const corners = [
                { x: bounds.minX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.maxY },
                { x: bounds.minX, y: bounds.maxY }
            ];
            const threshold = Math.max(width, height) * 0.15;
            corners.forEach(corner => {
                if (points.some(p => distance(p, corner) < threshold)) cornerCount++;
            });
            return cornerCount / 4;
        }

        function getTriangleScore(points, bounds) {
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;

            // Check for roughly 3 direction changes (corners)
            let turns = 0;
            const step = Math.max(1, Math.floor(points.length / 20));
            for (let i = step; i < points.length - step; i += step) {
                const prev = points[i - step];
                const curr = points[i];
                const next = points[Math.min(i + step, points.length - 1)];
                const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                let diff = Math.abs(angle2 - angle1);
                if (diff > Math.PI) diff = 2 * Math.PI - diff;
                if (diff > 0.4 && diff < 2.8) turns++;
            }

            // Aspect ratio check - triangles shouldn't be too thin
            const aspect = Math.min(width, height) / Math.max(width, height);
            const aspectOk = aspect > 0.3;

            if (turns >= 2 && turns <= 6 && aspectOk) {
                return 0.65;
            }
            return 0.25;
        }

        function getLineScore(points) {
            if (points.length < 3) return 0;
            const start = points[0];
            const end = points[points.length - 1];
            const lineLen = distance(start, end);
            if (lineLen < 30) return 0;

            let totalDev = 0;
            points.forEach(p => {
                const t = Math.max(0, Math.min(1,
                    ((p.x - start.x) * (end.x - start.x) + (p.y - start.y) * (end.y - start.y)) / (lineLen * lineLen)
                ));
                const proj = { x: start.x + t * (end.x - start.x), y: start.y + t * (end.y - start.y) };
                totalDev += distance(p, proj);
            });
            return Math.max(0, 1 - (totalDev / points.length) / (lineLen * 0.1));
        }

        function detectArrowHead(points) {
            if (points.length < 10) return false;
            const last10 = points.slice(-10);
            const end = points[points.length - 1];
            const beforeEnd = points[Math.max(0, points.length - 8)];
            const mainDir = Math.atan2(end.y - beforeEnd.y, end.x - beforeEnd.x);

            // Check for splaying at end
            let hasSplay = false;
            for (let i = 1; i < last10.length - 1; i++) {
                const dir = Math.atan2(last10[i].y - end.y, last10[i].x - end.x);
                const diff = Math.abs(dir - mainDir);
                if (diff > 0.4 && diff < 2.7) hasSplay = true;
            }
            return hasSplay;
        }

        // ============================================
        // Shape Detection
        // ============================================
        function detectShape(points) {
            if (points.length < 5) return null;

            const bounds = getBounds(points);
            const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const size = Math.max(width, height);

            if (size < 20) return null; // Too small

            // Check if closed (start near end)
            const start = points[0];
            const end = points[points.length - 1];
            const closedThreshold = size * 0.25;
            const isClosed = distance(start, end) < closedThreshold;

            if (isClosed) {
                // Analyze closed shape
                const circleScore = getCircleScore(points, center, size / 2);
                const rectScore = getRectScore(points, bounds);
                const triScore = getTriangleScore(points, bounds);

                if (circleScore > 0.7 && circleScore > rectScore && circleScore > triScore) {
                    return { type: 'circle', center, radius: size / 2, confidence: circleScore };
                }
                if (rectScore > 0.6 && rectScore > triScore) {
                    return { type: 'rectangle', bounds, center, confidence: rectScore };
                }
                if (triScore > 0.5) {
                    return { type: 'triangle', bounds, center, confidence: triScore };
                }
            } else {
                // Open shape - line or arrow
                const lineScore = getLineScore(points);
                if (lineScore > 0.7) {
                    const hasArrow = detectArrowHead(points);
                    return {
                        type: hasArrow ? 'arrow' : 'line',
                        start, end, center,
                        confidence: lineScore
                    };
                }
            }

            return null;
        }

        // ============================================
        // Stroke → Entity Classification
        // ============================================

        // Check if two line segments intersect, return intersection point
        function segmentsIntersect(p1, p2, p3, p4, returnPoint = false) {
            const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (Math.abs(d) < 0.001) return returnPoint ? null : false;
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / d;
            if (t > 0 && t < 1 && u > 0 && u < 1) {
                if (returnPoint) {
                    return {
                        x: p1.x + t * (p2.x - p1.x),
                        y: p1.y + t * (p2.y - p1.y)
                    };
                }
                return true;
            }
            return returnPoint ? null : false;
        }

        // Detect self-intersection and find loop center (fish body pivot)
        // Returns { loopCenter, loopStart, loopEnd, intersectionPoint } or null
        function findSelfIntersectionLoop(points) {
            if (points.length < 15) return null;

            const step = Math.max(1, Math.floor(points.length / 50));

            for (let i = 0; i < points.length - step * 4; i += step) {
                const a1 = points[i];
                const a2 = points[Math.min(i + step, points.length - 1)];

                for (let j = i + step * 3; j < points.length - step; j += step) {
                    const b1 = points[j];
                    const b2 = points[Math.min(j + step, points.length - 1)];

                    const intersection = segmentsIntersect(a1, a2, b1, b2, true);
                    if (intersection) {
                        // Found intersection - extract the loop (points between i and j)
                        const loopPoints = points.slice(i, j + 1);

                        // Check loop is curved (not sharp angular)
                        // Measure curvature by checking angle changes
                        let totalAngleChange = 0;
                        const sampleStep = Math.max(1, Math.floor(loopPoints.length / 10));
                        for (let k = sampleStep; k < loopPoints.length - sampleStep; k += sampleStep) {
                            const prev = loopPoints[k - sampleStep];
                            const curr = loopPoints[k];
                            const next = loopPoints[Math.min(k + sampleStep, loopPoints.length - 1)];
                            const a1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                            const a2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                            let diff = Math.abs(a2 - a1);
                            if (diff > Math.PI) diff = 2 * Math.PI - diff;
                            totalAngleChange += diff;
                        }

                        // Reject if too angular (sharp corners)
                        const avgAngleChange = totalAngleChange / (loopPoints.length / sampleStep);
                        if (avgAngleChange > 0.8) continue; // Too sharp, not a curved loop

                        // Calculate loop centroid (fish body center)
                        let cx = 0, cy = 0;
                        loopPoints.forEach(p => { cx += p.x; cy += p.y; });
                        cx /= loopPoints.length;
                        cy /= loopPoints.length;

                        // Check loop has decent size
                        const loopBounds = getBounds(loopPoints);
                        const loopSize = Math.max(loopBounds.maxX - loopBounds.minX, loopBounds.maxY - loopBounds.minY);
                        if (loopSize < 25) continue; // Loop too small

                        return {
                            loopCenter: { x: cx, y: cy },
                            loopStart: i,
                            loopEnd: j,
                            intersectionPoint: intersection,
                            loopSize: loopSize
                        };
                    }
                }
            }
            return null;
        }

        // Simple boolean check for backwards compatibility
        function hasSelfIntersection(points) {
            return findSelfIntersectionLoop(points) !== null;
        }

        // Generate jellyfish replacement art (bell + flowing tentacles)
        // Generate jellyfish with bell and separate tentacle data for animation
        function generateJellyfishShape(size) {
            const r = size * 0.35;
            const numTentacles = 5 + Math.floor(Math.random() * 3);
            const tentacleLength = 4 + Math.floor(Math.random() * 3);

            return {
                bellRadius: r,
                bellHeight: r * 0.6,
                numTentacles: numTentacles,
                tentacleLength: tentacleLength,
                // Random variation per jellyfish
                tentacleSpacing: 0.7 + Math.random() * 0.3,
                wobbleOffset: Math.random() * Math.PI * 2,
                pulseOffset: Math.random() * Math.PI * 2
            };
        }

        // Generate coral - simplified for performance
        function generateCoralShape(size, bounds) {
            const width = bounds ? (bounds.maxX - bounds.minX) : size;
            const height = bounds ? (bounds.maxY - bounds.minY) : size * 0.8;

            // Fewer stalks for better performance
            const numStalks = Math.max(2, Math.min(6, Math.floor(width / 25)));
            const stalks = [];

            for (let s = 0; s < numStalks; s++) {
                const xPos = -width / 2 + (s + 0.5) * (width / numStalks);
                const stalkHeight = height * (0.5 + Math.random() * 0.4);

                // 2-3 branches per stalk
                const numBranches = 2 + Math.floor(Math.random() * 2);

                stalks.push({
                    x: xPos + (Math.random() - 0.5) * 6,
                    height: stalkHeight,
                    branches: []
                });

                for (let b = 0; b < numBranches; b++) {
                    const branchY = stalkHeight * (0.3 + (b / numBranches) * 0.5);
                    const branchDir = (b % 2 === 0) ? -1 : 1;
                    const branchLen = 8 + Math.random() * 15;
                    const branchAngle = (0.3 + Math.random() * 0.4) * branchDir;

                    stalks[s].branches.push({
                        y: branchY,
                        angle: branchAngle,
                        length: branchLen,
                        hasTip: Math.random() > 0.3
                    });
                }
            }

            return {
                width: width,
                height: height,
                stalks: stalks,
                swayOffset: Math.random() * Math.PI * 2
            };
        }

        // Generate SIMPLE fish shape for small fish - procedural outline
        function generateSimpleFishShape(loopInfo, originalPoints, size) {
            const loopPoints = originalPoints.slice(loopInfo.loopStart, loopInfo.loopEnd + 1);
            const loopBounds = getBounds(loopPoints);
            const loopWidth = loopBounds.maxX - loopBounds.minX;
            const loopHeight = loopBounds.maxY - loopBounds.minY;

            // Fish dimensions based on drawn loop
            const bodyLen = Math.max(loopWidth, loopHeight) * 0.45;
            const bodyH = Math.min(loopWidth, loopHeight) * 0.35;
            const tailLen = bodyLen * 0.6;
            const tailSpread = bodyH * 0.9;

            // Head direction from intersection point
            const headDir = Math.atan2(
                loopInfo.intersectionPoint.y - loopInfo.loopCenter.y,
                loopInfo.intersectionPoint.x - loopInfo.loopCenter.x
            );

            // Create fish outline centered at body center (not geometric center)
            // Offset so body center is at origin, nose at +X
            const bodyCenter = bodyLen * 0.1; // Body center offset from geometric center
            const pts = [];

            pts.push({ x: bodyLen - bodyCenter, y: 0 }); // Nose
            pts.push({ x: bodyLen * 0.7 - bodyCenter, y: -bodyH * 0.5 });
            pts.push({ x: bodyLen * 0.3 - bodyCenter, y: -bodyH * 0.8 });
            pts.push({ x: -bodyLen * 0.2 - bodyCenter, y: -bodyH * 0.6 });
            pts.push({ x: -bodyLen * 0.5 - bodyCenter, y: -bodyH * 0.3 });
            pts.push({ x: -bodyLen * 0.5 - tailLen - bodyCenter, y: -tailSpread }); // Tail top
            pts.push({ x: -bodyLen * 0.5 - tailLen * 0.5 - bodyCenter, y: 0 }); // Tail notch
            pts.push({ x: -bodyLen * 0.5 - tailLen - bodyCenter, y: tailSpread }); // Tail bottom
            pts.push({ x: -bodyLen * 0.5 - bodyCenter, y: bodyH * 0.3 });
            pts.push({ x: -bodyLen * 0.2 - bodyCenter, y: bodyH * 0.6 });
            pts.push({ x: bodyLen * 0.3 - bodyCenter, y: bodyH * 0.8 });
            pts.push({ x: bodyLen * 0.7 - bodyCenter, y: bodyH * 0.5 });
            pts.push({ x: bodyLen - bodyCenter, y: 0 }); // Back to nose

            // Calculate actual bounds for collision
            const shapeBounds = getBounds(pts);
            const actualWidth = shapeBounds.maxX - shapeBounds.minX;
            const actualHeight = shapeBounds.maxY - shapeBounds.minY;

            return {
                points: pts,
                initialHeading: headDir,
                bodyWidth: actualWidth / 2,  // Half-width for radius
                bodyHeight: actualHeight / 2,
                noseOffset: bodyLen - bodyCenter,  // Distance from center to nose
                isStrokeBased: false
            };
        }

        // SVG fish template path - from Assets/fish-large-template.svg
        // This is a single continuous stroke: body loop + through-line + tail
        const FISH_SVG_PATH = "M1069 305.184C1002.34 474.878 823 512 717 512C326.131 512 316.472 334.531 316.472 297.439M316.472 297.439C326.5 177.5 512.371 120 723.55 120C883.704 120 1093.74 215.974 1065.61 256.375C1057.99 267.316 971.358 328.708 749.191 334.531C506.537 340.891 388.979 316.987 316.472 297.439ZM316.472 297.439C249.891 279.489 145.743 99.6744 111.909 127.568C95.6466 140.975 188.625 248.318 188.626 334.531C188.626 413.321 80.6552 501.811 118 518.5C155.345 535.189 189.091 402.659 284.5 384.5";

        // SVG dimensions for scaling - measured from the actual path
        // Body spans roughly x=316 to x=1069, y=120 to y=512
        // Tail extends to x≈80
        const FISH_SVG_BODY_WIDTH = 753;   // 1069 - 316 (body only, not tail)
        const FISH_SVG_BODY_HEIGHT = 392;  // 512 - 120
        const FISH_SVG_CENTER_X = 690;     // Center of body: (316 + 1069) / 2 ≈ 690
        const FISH_SVG_CENTER_Y = 316;     // Center Y: (120 + 512) / 2
        const FISH_SVG_NOSE_X = 1069;      // Nose position (rightmost point)

        // Create the Path2D object once
        let fishPath2D = null;
        try {
            fishPath2D = new Path2D(FISH_SVG_PATH);
        } catch (e) {
            console.warn('Path2D not supported, falling back to simple fish');
        }

        // Generate STROKE-BASED fish shape for big fish - uses SVG template
        function generateStrokeFishShape(loopInfo, originalPoints, size) {
            const loopPoints = originalPoints.slice(loopInfo.loopStart, loopInfo.loopEnd + 1);
            const loopBounds = getBounds(loopPoints);
            const loopWidth = loopBounds.maxX - loopBounds.minX;
            const loopHeight = loopBounds.maxY - loopBounds.minY;

            // Calculate centroid for position
            let cx = 0, cy = 0;
            loopPoints.forEach(p => { cx += p.x; cy += p.y; });
            cx /= loopPoints.length;
            cy /= loopPoints.length;

            // Head direction from loop shape - nose points away from intersection
            const headDir = Math.atan2(
                cy - loopInfo.intersectionPoint.y,
                cx - loopInfo.intersectionPoint.x
            );

            // Scale factor based on drawn size vs SVG body size
            const drawnSize = Math.max(loopWidth, loopHeight);
            const scaleFactor = drawnSize / FISH_SVG_BODY_WIDTH;

            // Calculate actual dimensions after scaling
            const scaledBodyWidth = FISH_SVG_BODY_WIDTH * scaleFactor;
            const scaledBodyHeight = FISH_SVG_BODY_HEIGHT * scaleFactor;
            const noseOffset = (FISH_SVG_NOSE_X - FISH_SVG_CENTER_X) * scaleFactor;

            return {
                useSvgPath: true,
                scaleFactor: scaleFactor,
                initialHeading: headDir,
                bodyWidth: scaledBodyWidth / 2,
                bodyHeight: scaledBodyHeight / 2,
                noseOffset: noseOffset,
                isStrokeBased: true
            };
        }

        // Main fish shape generator - chooses style based on size
        function generateFishShape(loopInfo, originalPoints, size) {
            // Big fish (loop size > 60) get stroke-based shape
            // Small fish get simple procedural shape
            if (loopInfo.loopSize > 60) {
                return generateStrokeFishShape(loopInfo, originalPoints, size);
            } else {
                return generateSimpleFishShape(loopInfo, originalPoints, size);
            }
        }

        // Shape classification - matches design.html detectShape() exactly, plus fish
        function classifyStroke(points) {
            if (!points || points.length === 0) return null;

            // Tiny tap/dot → food (before other checks)
            if (points.length < 8) {
                const bounds = getBounds(points);
                const size = Math.max(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
                if (size < 25) {
                    const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
                    return { type: 'food', center, size, points };
                }
            }

            if (points.length < 5) return null;

            const bounds = getBounds(points);
            const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const size = Math.max(width, height);

            if (size < 20) return null; // Too small

            // Check if closed (start near end) - exact design.html logic
            const start = points[0];
            const end = points[points.length - 1];
            const closedThreshold = size * 0.25;
            const isClosed = distance(start, end) < closedThreshold;

            if (isClosed) {
                // Analyze closed shape - exact design.html scoring and comparison
                const circleScore = getCircleScore(points, center, size / 2);
                const rectScore = getRectScore(points, bounds);
                const triScore = getTriangleScore(points, bounds);

                // Circle → bubble (must beat both others)
                if (circleScore > 0.7 && circleScore > rectScore && circleScore > triScore) {
                    return { type: 'bubble', center, radius: size / 2, size, points };
                }
                // Rectangle → coral (must beat triangle)
                if (rectScore > 0.6 && rectScore > triScore) {
                    const coralShape = generateCoralShape(size, bounds);
                    return { type: 'coral', center, size, bounds, shape: coralShape };
                }
                // Triangle → jellyfish
                if (triScore > 0.5) {
                    const jellyShape = generateJellyfishShape(size);
                    return { type: 'jellyfish', center, size, bounds, shape: jellyShape };
                }
                // Unrecognized closed shape → no entity
                return null;
            }

            // OPEN STROKES - check for self-intersecting fish shape (ichthys)
            // This is the ONE new shape type we add to design.html's logic
            const loopInfo = findSelfIntersectionLoop(points);
            if (loopInfo && loopInfo.loopSize > 25) {
                const fishShape = generateFishShape(loopInfo, points, size);
                return {
                    type: 'fish',
                    center: loopInfo.loopCenter,
                    size: loopInfo.loopSize,
                    fishShape: fishShape,  // Contains points, initialHeading, bodyWidth, bodyHeight
                    loopInfo: loopInfo
                };
            }

            // Open stroke → temporary line (for bubble-popping)
            return { type: 'line', center, size, points, start, end };
        }

        // ============================================
        // Canvas Setup
        // ============================================
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ============================================
        // Drawing Functions
        // ============================================
        function drawGrid() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, w, h);
        }
        
        
        function drawRawStrokes() {
            const now = Date.now();
            
            strokes = strokes.filter(stroke => {
                const age = now - stroke.startTime;
                if (age > stroke.fadeStart + TIMING.strokeFade) return false;
                
                let opacity = 1;
                if (age > stroke.fadeStart) {
                    opacity = 1 - ((age - stroke.fadeStart) / TIMING.strokeFade);
                }
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                if (stroke.points.length < 2) return true;
                
                ctx.shadowColor = colors.glow;
                ctx.shadowBlur = 12 * easedOpacity;
                ctx.strokeStyle = `rgba(147, 197, 253, ${0.85 * easedOpacity})`;
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    const p0 = stroke.points[i - 1];
                    const p1 = stroke.points[i];
                    ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                return true;
            });
        }

        // ============================================
        // Entity Rendering
        // ============================================
        function drawFishEntities() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            // Physics constants - tuned for smooth movement
            const DETECT_RANGE = 400;
            const EAT_RANGE = 35;  // Distance from mouth to eat (larger for better pickup)
            const SEEK_SPEED = 1.2;
            const IDLE_SPEED = 0.5;
            const FLEE_SPEED = 3.5;         // Fast escape when scared
            const TURN_RATE = 0.04;         // Turning speed
            const MAX_TURN_PER_FRAME = 0.1; // Cap heading change per frame
            const EDGE_MARGIN = 50;
            const EDGE_FORCE = 0.1;

            // Boids - separation is critical to prevent overlap
            const BOID_SEP_RANGE = 100;
            const BOID_ALIGN_RANGE = 200;
            const BOID_COHESION_RANGE = 300;

            // Size categories (based on bodyWidth)
            const SMALL_THRESHOLD = 35;     // Below = small
            const MEDIUM_THRESHOLD = 60;    // Below = medium, above = large

            // Coral repulsion for medium/large fish
            const CORAL_REPEL_RANGE = 100;
            const CORAL_REPEL_FORCE = 0.15;

            // ---- SHARED SCHOOL TARGET for medium fish ----
            // Calculate school center and pick a shared wander target
            let schoolCenterX = 0, schoolCenterY = 0, mediumCount = 0;
            fish.forEach(f => {
                const bw = f.bodyWidth || 20;
                if (bw >= SMALL_THRESHOLD && bw < MEDIUM_THRESHOLD) {
                    schoolCenterX += f.x;
                    schoolCenterY += f.y;
                    mediumCount++;
                }
            });
            if (mediumCount > 0) {
                schoolCenterX /= mediumCount;
                schoolCenterY /= mediumCount;
            }

            // Update shared school target occasionally (every ~8 seconds)
            if (!this.schoolTarget || !this.schoolTargetTimer || this.schoolTargetTimer <= 0) {
                this.schoolTargetTimer = 8000 + Math.random() * 4000;
                // Pick a new shared target in middle area, offset from current school center
                const offsetX = (Math.random() - 0.5) * w * 0.4;
                const offsetY = (Math.random() - 0.5) * h * 0.25;
                this.schoolTarget = {
                    x: Math.max(80, Math.min(w - 80, (mediumCount > 0 ? schoolCenterX : w * 0.5) + offsetX)),
                    y: Math.max(h * 0.25, Math.min(h * 0.65, (mediumCount > 0 ? schoolCenterY : h * 0.45) + offsetY))
                };
            } else {
                this.schoolTargetTimer -= 16;
            }

            fish.forEach((f, fi) => {
                const pts = f.points;
                // SVG fish don't have points array, skip this check for them
                if (!f.useSvgPath && (!pts || pts.length < 2)) return;

                // Per-fish unique color using hue shift
                const baseColor = aquaColors.fish[f.id % aquaColors.fish.length];
                const hueShift = f.hueShift || 0;
                // Apply hue shift by rotating through color spectrum
                const hsl = `hsl(${(180 + hueShift) % 360}, 80%, 65%)`;
                const color = hueShift ? hsl : baseColor;

                // Per-fish randomness offset (consistent per fish)
                const fishRand = (f.id * 0.618) % 1;

                // ---- Fish AI: seek visible food (not inside bubbles) ----
                // Calculate mouth position - moved closer to body center (60% of nose offset)
                const rawNoseOffset = f.useSvgPath
                    ? (f.noseOffset || f.bodyWidth || 20)
                    : (f.noseOffset || f.bodyWidth || 20) * (f.scaleX || 1);
                const mouthOffset = rawNoseOffset * 0.6; // Mouth is 60% toward nose from center
                const mouthX = f.x + Math.cos(f.heading) * mouthOffset;
                const mouthY = f.y + Math.sin(f.heading) * mouthOffset;

                let nearestFood = null;
                let nearestDist = Infinity;
                let nearestMouthDist = Infinity;
                food.forEach(fd => {
                    if (isFoodInBubble(fd.x, fd.y)) return;
                    // Use center distance for detection/seeking
                    const d = Math.sqrt((f.x - fd.x) ** 2 + (f.y - fd.y) ** 2);
                    if (d < nearestDist) {
                        nearestDist = d;
                        nearestFood = fd;
                        // Calculate mouth-to-food distance for eating
                        nearestMouthDist = Math.sqrt((mouthX - fd.x) ** 2 + (mouthY - fd.y) ** 2);
                    }
                });

                // Get personality (with defaults for old fish)
                const energy = f.energy || 0.5;
                const curiosity = f.curiosity || 0.4;
                const nervousness = f.nervousness || 0.4;

                // Determine size category
                const bw = f.bodyWidth || 20;
                const isSmall = bw < SMALL_THRESHOLD;
                const isLarge = bw >= MEDIUM_THRESHOLD;
                const isMedium = !isSmall && !isLarge;

                // Initialize state timers if missing
                if (f.huntTimer === undefined) f.huntTimer = 0;
                if (f.fleeTimer === undefined) f.fleeTimer = 0;

                // ---- DECREMENT STATE TIMERS ----
                f.huntTimer = Math.max(0, (f.huntTimer || 0) - 16);
                f.fleeTimer = Math.max(0, (f.fleeTimer || 0) - 16);

                // ---- FOOD SEEKING (highest priority for all fish) ----
                // Eat range varies by size: large=35, medium=17 (50%), small=9 (25%)
                const sizeEatRange = isLarge ? EAT_RANGE : (isMedium ? EAT_RANGE * 0.5 : EAT_RANGE * 0.25);

                if (nearestFood && nearestDist < DETECT_RANGE && f.state !== 'fleeing') {
                    f.state = 'seeking';
                    f.targetHeading = Math.atan2(nearestFood.y - f.y, nearestFood.x - f.x);
                    f.targetHeading += (fishRand - 0.5) * 0.3;

                    if (nearestMouthDist < sizeEatRange) {
                        const idx = food.indexOf(nearestFood);
                        if (idx !== -1) {
                            food.splice(idx, 1);
                            for (let i = 0; i < 5; i++) {
                                const a = (i / 5) * Math.PI * 2;
                                particles.push({
                                    x: nearestFood.x, y: nearestFood.y,
                                    vx: Math.cos(a) * 0.8, vy: Math.sin(a) * 0.8,
                                    life: 1, createdAt: now
                                });
                            }
                        }
                        f.state = 'idle';
                    }
                }
                // ---- FLEEING STATE (persists until timer expires) ----
                else if (f.state === 'fleeing' && f.fleeTimer > 0) {
                    // Stay fleeing, keep current heading
                }
                // ---- HUNTING STATE (persists until timer expires or prey eaten/lost) ----
                else if (f.state === 'hunting' && f.huntTimer > 0 && isLarge) {
                    const prey = fish.find(p => p.id === f.huntTarget);
                    if (prey) {
                        const preyDist = Math.sqrt((prey.x - f.x) ** 2 + (prey.y - f.y) ** 2);
                        const huntAngle = Math.atan2(prey.y - f.y, prey.x - f.x);
                        f.targetHeading = huntAngle;

                        // Check if close enough to eat
                        const EAT_PREY_RANGE = 30;
                        if (preyDist < EAT_PREY_RANGE) {
                            const preyIdx = fish.findIndex(p => p.id === prey.id);
                            if (preyIdx !== -1) {
                                fish.splice(preyIdx, 1);
                                f.lastAteAt = now;
                                for (let i = 0; i < 8; i++) {
                                    const a = (i / 8) * Math.PI * 2;
                                    particles.push({
                                        x: prey.x, y: prey.y,
                                        vx: Math.cos(a) * 1.5, vy: Math.sin(a) * 1.5,
                                        life: 1, createdAt: now
                                    });
                                }
                            }
                            f.state = 'idle';
                            f.huntTarget = null;
                            f.huntTimer = 0;
                        }
                    } else {
                        // Prey gone, stop hunting
                        f.state = 'idle';
                        f.huntTarget = null;
                        f.huntTimer = 0;
                    }
                }
                // ---- IDLE STATE: Check for threats and behaviors ----
                else {
                    f.state = 'idle';

                    // ---- LARGE FISH: Start hunting if prey nearby ----
                    if (isLarge) {
                        let prey = null;
                        let preyDist = Infinity;
                        const HUNT_RANGE = 250;

                        fish.forEach(other => {
                            if (other.id === f.id) return;
                            const otherBw = other.bodyWidth || 20;
                            if (otherBw >= SMALL_THRESHOLD) return;

                            const dx = other.x - f.x;
                            const dy = other.y - f.y;
                            const d = Math.sqrt(dx * dx + dy * dy);
                            if (d < HUNT_RANGE && d < preyDist) {
                                prey = other;
                                preyDist = d;
                            }
                        });

                        if (prey) {
                            // Start hunting - no random chance, commit to the hunt
                            f.state = 'hunting';
                            f.huntTarget = prey.id;
                            f.huntTimer = 3000 + energy * 2000; // Hunt for 3-5 seconds
                            const huntAngle = Math.atan2(prey.y - f.y, prey.x - f.x);
                            f.targetHeading = huntAngle;
                        }
                    }

                    // ---- SMALL FISH: Flee from predators TOWARD CORAL ----
                    if (isSmall && f.state === 'idle') {
                        let predator = null;
                        let predatorDist = Infinity;
                        const DANGER_RANGE = 180;

                        fish.forEach(other => {
                            if (other.id === f.id) return;
                            const otherBw = other.bodyWidth || 20;
                            if (otherBw < MEDIUM_THRESHOLD) return;

                            const dx = other.x - f.x;
                            const dy = other.y - f.y;
                            const d = Math.sqrt(dx * dx + dy * dy);
                            if (d < DANGER_RANGE && d < predatorDist) {
                                predator = other;
                                predatorDist = d;
                            }
                        });

                        if (predator) {
                            f.state = 'fleeing';
                            f.fleeTimer = 1500 + nervousness * 1000;

                            // Find nearest coral and flee TOWARD it (safe haven)
                            let nearestCoral = null;
                            let nearestCoralDist = Infinity;
                            coral.forEach(c => {
                                if (!c.settled) return;
                                const d = Math.sqrt((c.x - f.x) ** 2 + (c.y - f.y) ** 2);
                                if (d < nearestCoralDist) {
                                    nearestCoralDist = d;
                                    nearestCoral = c;
                                }
                            });

                            if (nearestCoral && nearestCoralDist < 400) {
                                // Flee toward coral (safety)
                                const coralH = nearestCoral.shape?.height || 60;
                                const safeY = nearestCoral.y - coralH * 0.5; // Aim for middle of coral
                                const fleeAngle = Math.atan2(safeY - f.y, nearestCoral.x - f.x);
                                f.targetHeading = fleeAngle + (Math.random() - 0.5) * 0.2;
                            } else {
                                // No coral nearby, flee away from predator and down
                                const fleeAngle = Math.atan2(f.y - predator.y, f.x - predator.x);
                                // Bias toward bottom of screen where coral usually is
                                const biasedAngle = fleeAngle * 0.6 + (Math.PI * 0.5) * 0.4;
                                f.targetHeading = biasedAngle + (Math.random() - 0.5) * 0.3;
                            }
                        }
                    }

                    // ---- MEDIUM FISH: Scatter from large fish ----
                    if (isMedium && f.state === 'idle') {
                        let threat = null;
                        let threatDist = Infinity;
                        const SCATTER_RANGE = 140;

                        fish.forEach(other => {
                            if (other.id === f.id) return;
                            const otherBw = other.bodyWidth || 20;
                            if (otherBw < MEDIUM_THRESHOLD) return;

                            const dx = other.x - f.x;
                            const dy = other.y - f.y;
                            const d = Math.sqrt(dx * dx + dy * dy);
                            if (d < SCATTER_RANGE && d < threatDist) {
                                threat = other;
                                threatDist = d;
                            }
                        });

                        if (threat) {
                            f.state = 'fleeing';
                            f.fleeTimer = 800 + nervousness * 600; // Scatter for 0.8-1.4 seconds
                            const scatterAngle = Math.atan2(f.y - threat.y, f.x - threat.x);
                            f.targetHeading = scatterAngle + (Math.random() - 0.5) * 0.6;
                        }
                    }

                    // ---- WANDER SYSTEM (only if still idle) ----
                    if (f.state === 'idle') {
                        f.wanderTimer = (f.wanderTimer || 0) - 16;
                        f.restTimer = (f.restTimer || 0) - 16;

                        // Rest behavior
                        if (f.restTimer > 0) {
                            f.currentSpeed = IDLE_SPEED * 0.2;
                            f.targetHeading += (Math.random() - 0.5) * 0.015;
                        } else {
                            if (Math.random() < 0.0005 * (1 - energy)) {
                                f.restTimer = 2000 + Math.random() * 3000;
                            }
                            f.currentSpeed = IDLE_SPEED * (0.7 + energy * 0.6);
                        }

                        // Pick new wander target - MUCH SLOWER timing
                        if (!f.wanderTarget || f.wanderTimer <= 0) {
                            // 6-12 seconds between wander target changes
                            f.wanderTimer = 6000 + Math.random() * 6000 * (1 - curiosity * 0.5);

                            if (isSmall) {
                                let targetX, targetY;
                                // Find nearest coral - small fish STRONGLY prefer coral
                                let bestCoral = null;
                                let bestCoralDist = Infinity;
                                coral.forEach(c => {
                                    if (!c.settled) return;
                                    const d = Math.sqrt((c.x - f.x) ** 2 + (c.y - f.y) ** 2);
                                    if (d < bestCoralDist) {
                                        bestCoralDist = d;
                                        bestCoral = c;
                                    }
                                });

                                if (bestCoral && Math.random() < 0.95) {
                                    // Hang out within coral's full height range
                                    const coralW = (bestCoral.shape?.width || 50) * 0.5;
                                    const coralH = bestCoral.shape?.height || 60;
                                    // Wander within coral area - full height
                                    const xOffset = (Math.random() - 0.5) * coralW * 1.5;
                                    const yOffset = Math.random() * coralH; // 0 to full height
                                    targetX = bestCoral.x + xOffset;
                                    targetY = bestCoral.y - yOffset; // Coral grows upward
                                } else if (coral.length > 0) {
                                    // Occasionally venture to another coral
                                    const randomCoral = coral[Math.floor(Math.random() * coral.length)];
                                    if (randomCoral && randomCoral.settled) {
                                        const coralH = randomCoral.shape?.height || 60;
                                        targetX = randomCoral.x + (Math.random() - 0.5) * 40;
                                        targetY = randomCoral.y - Math.random() * coralH;
                                    } else {
                                        targetX = w * 0.2 + Math.random() * w * 0.6;
                                        targetY = h * 0.65 + Math.random() * h * 0.25;
                                    }
                                } else {
                                    // No coral exists, wander in lower area
                                    targetX = w * 0.2 + Math.random() * w * 0.6;
                                    targetY = h * 0.65 + Math.random() * h * 0.25;
                                }
                                f.wanderTarget = { x: targetX, y: targetY };

                            } else if (isMedium) {
                                // Medium fish: USE SHARED SCHOOL TARGET with slight offset
                                if (this.schoolTarget) {
                                    const offsetX = (Math.random() - 0.5) * 60;
                                    const offsetY = (Math.random() - 0.5) * 40;
                                    f.wanderTarget = {
                                        x: this.schoolTarget.x + offsetX,
                                        y: this.schoolTarget.y + offsetY
                                    };
                                } else {
                                    f.wanderTarget = { x: w * 0.5, y: h * 0.45 };
                                }

                            } else {
                                // Large fish: wander anywhere, solitary
                                const targetX = w * 0.1 + Math.random() * w * 0.8;
                                const targetY = h * 0.15 + Math.random() * h * 0.55;
                                f.wanderTarget = { x: targetX, y: targetY };
                            }
                        }

                        // Swim toward wander target
                        if (f.wanderTarget) {
                            const dx = f.wanderTarget.x - f.x;
                            const dy = f.wanderTarget.y - f.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < 40) {
                                // Near target, slow down and linger
                                f.wanderTimer = Math.min(f.wanderTimer, 2000);
                            } else {
                                const wanderAngle = Math.atan2(dy, dx);
                                const turnRate = 0.015 + energy * 0.015;
                                f.targetHeading += angleDiff(wanderAngle, f.heading) * turnRate;
                            }
                        }

                        // Subtle wobble
                        f.targetHeading += (Math.random() - 0.5) * 0.02 * energy;
                    }
                }

                // ---- Store size category for debug ----
                let sizeCategory;
                if (isSmall) sizeCategory = 'small';
                else if (isMedium) sizeCategory = 'medium';
                else sizeCategory = 'large';
                f.sizeCategory = sizeCategory;

                // ---- Fish collision and separation based on OVAL body shape ----
                // Oval dimensions (half-widths) - 30% larger than body for collision buffer
                const fWidthH = (f.bodyWidth || 20) * 1.3;  // Length along heading
                const fHeightH = (f.bodyHeight || f.bodyWidth * 0.4 || 8) * 1.3; // Perpendicular

                // Helper: get oval radius in a given direction (relative to fish heading)
                function getOvalRadius(widthH, heightH, heading, dirAngle) {
                    const relAngle = dirAngle - heading;
                    const cos = Math.cos(relAngle);
                    const sin = Math.sin(relAngle);
                    return (widthH * heightH) / Math.sqrt((heightH * cos) ** 2 + (widthH * sin) ** 2);
                }

                let sepX = 0, sepY = 0;
                let alignVx = 0, alignVy = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohCount = 0;

                fish.forEach((other, oi) => {
                    if (oi === fi) return;
                    const dx = f.x - other.x;
                    const dy = f.y - other.y;
                    const d = Math.sqrt(dx * dx + dy * dy);
                    if (d === 0) return;

                    const dirAngle = Math.atan2(dy, dx);

                    // Get oval radii in the direction between fish (30% larger buffer)
                    const fRadius = getOvalRadius(fWidthH, fHeightH, f.heading, dirAngle);
                    const otherWidthH = (other.bodyWidth || 20) * 1.3;
                    const otherHeightH = (other.bodyHeight || other.bodyWidth * 0.4 || 8) * 1.3;
                    const otherRadius = getOvalRadius(otherWidthH, otherHeightH, other.heading, dirAngle + Math.PI);

                    const minDist = fRadius + otherRadius;
                    const comfortDist = minDist * 1.4;

                    // Hard collision - physically push apart if overlapping
                    if (d < minDist) {
                        const overlap = minDist - d;
                        const pushX = (dx / d) * overlap * 0.5;
                        const pushY = (dy / d) * overlap * 0.5;
                        f.x += pushX;
                        f.y += pushY;
                        f.vx += pushX * 0.2;
                        f.vy += pushY * 0.2;
                        f.targetHeading += angleDiff(dirAngle, f.heading) * 0.1;
                    }

                    // Soft separation - gentle steering when in comfort zone
                    if (d < comfortDist) {
                        const strength = 1 - (d / comfortDist);
                        sepX += (dx / d) * strength;
                        sepY += (dy / d) * strength;
                    }

                    // Get other fish's size category
                    const otherBw = other.bodyWidth || 20;
                    let otherSize;
                    if (otherBw < SMALL_THRESHOLD) otherSize = 'small';
                    else if (otherBw < MEDIUM_THRESHOLD) otherSize = 'medium';
                    else otherSize = 'large';

                    // Alignment and cohesion - school with SAME SIZE fish
                    if (otherSize === sizeCategory) {
                        if (d < BOID_ALIGN_RANGE && d > comfortDist) {
                            alignVx += other.vx;
                            alignVy += other.vy;
                            alignCount++;
                        }
                        if (d < BOID_COHESION_RANGE && d > comfortDist) {
                            cohX += other.x;
                            cohY += other.y;
                            cohCount++;
                        }
                    }
                });

                // Apply soft separation as heading adjustment
                if (sepX !== 0 || sepY !== 0) {
                    const sepAngle = Math.atan2(sepY, sepX);
                    const sepMag = Math.sqrt(sepX * sepX + sepY * sepY);
                    f.targetHeading += angleDiff(sepAngle, f.heading) * Math.min(0.12, sepMag * 0.06);
                }

                // Apply alignment (school with same size)
                if (alignCount > 0) {
                    const avgAngle = Math.atan2(alignVy / alignCount, alignVx / alignCount);
                    f.targetHeading += angleDiff(avgAngle, f.heading) * 0.025;
                }

                // Apply cohesion (pull toward school center of same size)
                if (cohCount > 0) {
                    const centerX = cohX / cohCount;
                    const centerY = cohY / cohCount;
                    const cohAngle = Math.atan2(centerY - f.y, centerX - f.x);
                    f.targetHeading += angleDiff(cohAngle, f.heading) * 0.015;
                }

                // ---- Size-based area preference ----
                if (sizeCategory === 'small') {
                    // Small fish: prefer lower area near coral
                    const preferredY = h * 0.75;
                    if (f.y < preferredY - 80) {
                        f.targetHeading += angleDiff(Math.PI * 0.5, f.heading) * 0.025;
                    }
                } else if (sizeCategory === 'medium') {
                    // Medium fish: prefer middle area
                    const preferredY = h * 0.5;
                    if (f.y < preferredY - 100) {
                        f.targetHeading += angleDiff(Math.PI * 0.5, f.heading) * 0.015;
                    } else if (f.y > preferredY + 100) {
                        f.targetHeading += angleDiff(-Math.PI * 0.5, f.heading) * 0.015;
                    }
                } else {
                    // Large fish: prefer upper area
                    const preferredY = h * 0.3;
                    if (f.y > preferredY + 120) {
                        f.targetHeading += angleDiff(-Math.PI * 0.5, f.heading) * 0.02;
                    }
                }

                // ---- Jellyfish avoidance ----
                const JELLY_AVOID_RANGE = 80;
                const JELLY_AVOID_FORCE = 0.2;
                jellyfish.forEach(j => {
                    if (!j.shape) return;
                    const dx = f.x - j.x;
                    const dy = f.y - j.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = JELLY_AVOID_RANGE + j.shape.bellRadius;
                    if (dist < minDist && dist > 0) {
                        const avoidAngle = Math.atan2(dy, dx);
                        const strength = (minDist - dist) / minDist;
                        f.targetHeading += angleDiff(avoidAngle, f.heading) * JELLY_AVOID_FORCE * strength;
                    }
                });

                // ---- Coral interaction based on fish size ----
                // Large fish: stay buffer away from coral (can't get close)
                // Medium fish: can approach coral edge but not enter
                // Small fish: attracted to coral (handled in wander/flee)
                coral.forEach(c => {
                    if (!c.settled || !c.shape) return;
                    const coralW = (c.shape.width || 50) * 0.5;
                    const coralH = c.shape.height || 60;
                    const coralTop = c.y - coralH; // Top of coral (grows upward from base)

                    const dx = f.x - c.x;
                    const dy = f.y - c.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (sizeCategory === 'large') {
                        // Large fish: stay FAR from coral - buffer of coral height + 150px
                        const largeBuffer = coralH + 150;
                        const keepOutRadius = coralW + largeBuffer;
                        if (dist < keepOutRadius && dist > 0) {
                            const avoidAngle = Math.atan2(dy, dx);
                            const strength = (keepOutRadius - dist) / keepOutRadius;
                            f.targetHeading += angleDiff(avoidAngle, f.heading) * 0.35 * strength;
                            // Strong upward push if anywhere near coral vertical zone
                            if (f.y > coralTop - 80) {
                                f.targetHeading += angleDiff(-Math.PI * 0.5, f.heading) * 0.2;
                            }
                        }
                        // Hard boundary - physically push away if too close
                        const hardLimit = coralW + coralH + 60;
                        if (dist < hardLimit) {
                            const pushStrength = (hardLimit - dist) * 0.02;
                            f.x += (dx / dist) * pushStrength;
                            f.y += (dy / dist) * pushStrength;
                        }
                    } else if (sizeCategory === 'medium') {
                        // Medium fish: can go right up to edge but NOT inside coral
                        // Check if fish is inside coral zone (within width and below top)
                        const insideCoral = Math.abs(dx) < coralW && f.y > coralTop;
                        if (insideCoral) {
                            // Push out - find shortest exit
                            const exitLeft = -(coralW + 5) - dx;
                            const exitRight = (coralW + 5) - dx;
                            const exitUp = coralTop - 5 - f.y;
                            // Choose closest exit
                            if (Math.abs(exitUp) < Math.min(Math.abs(exitLeft), Math.abs(exitRight))) {
                                f.y += exitUp * 0.3;
                                f.targetHeading = -Math.PI * 0.5; // Point up
                            } else if (Math.abs(exitLeft) < Math.abs(exitRight)) {
                                f.x += exitLeft * 0.3;
                                f.targetHeading = Math.PI; // Point left
                            } else {
                                f.x += exitRight * 0.3;
                                f.targetHeading = 0; // Point right
                            }
                        }
                    }
                });

                // ---- Soft edge avoidance ----
                let avoidX = 0, avoidY = 0;
                if (f.x < EDGE_MARGIN) avoidX = (EDGE_MARGIN - f.x) / EDGE_MARGIN;
                if (f.x > w - EDGE_MARGIN) avoidX = -(f.x - (w - EDGE_MARGIN)) / EDGE_MARGIN;
                if (f.y < EDGE_MARGIN) avoidY = (EDGE_MARGIN - f.y) / EDGE_MARGIN;
                if (f.y > h - EDGE_MARGIN) avoidY = -(f.y - (h - EDGE_MARGIN)) / EDGE_MARGIN;

                if (avoidX !== 0 || avoidY !== 0) {
                    const avoidAngle = Math.atan2(avoidY, avoidX);
                    f.targetHeading += angleDiff(avoidAngle, f.heading) * EDGE_FORCE;
                }

                // ---- Smooth heading interpolation with capped turn rate ----
                let headingDelta = angleDiff(f.targetHeading, f.heading) * TURN_RATE;
                // Cap maximum turn per frame to prevent jittery oscillation
                headingDelta = Math.max(-MAX_TURN_PER_FRAME, Math.min(MAX_TURN_PER_FRAME, headingDelta));
                f.heading += headingDelta;

                // ---- Apply velocity with per-fish speed variation ----
                const speedMult = 0.85 + fishRand * 0.3;
                let speed;
                if (f.state === 'fleeing') {
                    speed = FLEE_SPEED * speedMult;
                } else if (f.state === 'hunting') {
                    speed = SEEK_SPEED * 1.3 * speedMult; // Hunting is faster than seeking
                } else if (f.state === 'seeking') {
                    speed = SEEK_SPEED * speedMult;
                } else {
                    speed = IDLE_SPEED * speedMult;
                }
                f.vx = Math.cos(f.heading) * speed;
                f.vy = Math.sin(f.heading) * speed;
                f.x += f.vx;
                f.y += f.vy;

                // Strong edge bounce - prevent getting stuck
                const hardMargin = 30;
                const bounceStrength = 0.25;
                if (f.x < hardMargin) {
                    f.vx += bounceStrength;
                    f.x = hardMargin;
                    f.targetHeading = Math.PI * 0.1 * (Math.random() - 0.5); // Bounce right
                }
                if (f.x > w - hardMargin) {
                    f.vx -= bounceStrength;
                    f.x = w - hardMargin;
                    f.targetHeading = Math.PI + Math.PI * 0.1 * (Math.random() - 0.5); // Bounce left
                }
                if (f.y < hardMargin) {
                    f.vy += bounceStrength;
                    f.y = hardMargin;
                    f.targetHeading = Math.PI * 0.5 + Math.PI * 0.1 * (Math.random() - 0.5); // Bounce down
                }
                if (f.y > h - hardMargin - 20) {
                    f.vy -= bounceStrength * 1.5; // Extra strong floor bounce
                    f.y = h - hardMargin - 20;
                    f.targetHeading = -Math.PI * 0.5 + Math.PI * 0.1 * (Math.random() - 0.5); // Bounce up
                }

                // ---- Render ----
                // Wiggle parameters based on state
                let wiggleSpeed, wiggleAmt;
                if (f.state === 'fleeing') {
                    wiggleSpeed = 60;  // Fast panic wiggle
                    wiggleAmt = 10;
                } else if (f.state === 'seeking') {
                    wiggleSpeed = 100;
                    wiggleAmt = 7;
                } else {
                    wiggleSpeed = 180;
                    wiggleAmt = 4;
                }
                const wiggle = Math.sin(now / wiggleSpeed + f.id) * wiggleAmt;

                // Stroke animation - subtle pulse
                const strokePulse = 1 + 0.15 * Math.sin(now / 800 + f.id * 2);
                const baseLineWidth = f.state === 'fleeing' ? 3 : 2.5;

                const scaleX = f.scaleX || 1;
                const scaleY = f.scaleY || 1;

                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.heading);

                ctx.strokeStyle = color;
                ctx.lineWidth = baseLineWidth * strokePulse;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Check if this fish uses the SVG path template
                if (f.useSvgPath && fishPath2D) {
                    const sf = f.scaleFactor || 0.1;

                    // Scale line width inversely, with pulse
                    ctx.lineWidth = (3 * strokePulse) / sf;

                    ctx.scale(sf, sf);
                    ctx.translate(-FISH_SVG_CENTER_X, -FISH_SVG_CENTER_Y);

                    // Add wiggle via skew - more dramatic when fleeing
                    const skewMult = f.state === 'fleeing' ? 0.004 : 0.002;
                    const skew = wiggle * skewMult;
                    ctx.transform(1, 0, skew, 1, 0, 0);

                    // Fleeing fish flash brighter
                    ctx.globalAlpha = f.state === 'fleeing' ? 1 : 0.9;
                    ctx.stroke(fishPath2D);

                } else {
                    // Fallback: simple procedural fish
                    ctx.scale(scaleX, scaleY);

                    const bodyPts = f.bodyPoints || pts;
                    const throughPts = f.throughLine;

                    if (throughPts && throughPts.length > 1) {
                        // Fish with body + through-line: draw body static, through-line wiggles
                        // Draw body outline
                        ctx.globalAlpha = 0.9;
                        ctx.beginPath();
                        ctx.moveTo(bodyPts[0].x, bodyPts[0].y);
                        for (let i = 1; i < bodyPts.length; i++) {
                            const p0 = bodyPts[i - 1];
                            const p1 = bodyPts[i];
                            ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
                        }
                        ctx.closePath();
                        ctx.stroke();

                        // Fill body
                        ctx.globalAlpha = 0.15;
                        ctx.fillStyle = color;
                        ctx.fill();

                        // Draw through-line with wiggle
                        ctx.globalAlpha = 0.85;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(throughPts[0].x, throughPts[0].y);
                        for (let i = 1; i < throughPts.length; i++) {
                            const t = i / throughPts.length;
                            const wg = wiggle * Math.sin(t * Math.PI * 1.5);
                            const p0 = throughPts[i - 1];
                            const p1 = throughPts[i];
                            ctx.quadraticCurveTo(
                                p0.x, p0.y + wg,
                                (p0.x + p1.x) / 2, (p0.y + p1.y) / 2 + wg
                            );
                        }
                        ctx.stroke();
                    } else {
                        // Simple fish - draw body with wiggle (no throughline)
                        ctx.globalAlpha = 0.9;
                        ctx.beginPath();
                        ctx.moveTo(pts[0].x, pts[0].y);
                        for (let i = 1; i < pts.length; i++) {
                            const t = i / pts.length;
                            const wg = wiggle * Math.sin(t * Math.PI);
                            const p0 = pts[i - 1];
                            const p1 = pts[i];
                            ctx.quadraticCurveTo(
                                p0.x + wg, p0.y,
                                (p0.x + p1.x) / 2 + wg, (p0.y + p1.y) / 2
                            );
                        }
                        ctx.closePath();
                        ctx.stroke();

                        // Fill body
                        ctx.globalAlpha = 0.15;
                        ctx.fillStyle = color;
                        ctx.fill();
                    }
                }

                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }

        function drawCoralEntities() {
            const now = Date.now();
            const canvasW = canvas.width / (window.devicePixelRatio || 1);
            const canvasH = canvas.height / (window.devicePixelRatio || 1);

            coral.forEach((c, ci) => {
                if (!c.shape) return;

                const shape = c.shape;
                const color = aquaColors.coral[c.id % aquaColors.coral.length];
                const altColor = aquaColors.coral[(c.id + 1) % aquaColors.coral.length];

                // Sink to bottom with space-filling behavior
                if (!c.settled) {
                    const targetY = canvasH - 5;
                    c.y += 1.8; // Sink speed

                    // Space-filling: push away from other coral while sinking
                    coral.forEach((other, oi) => {
                        if (oi === ci) return;
                        const dx = c.x - other.x;
                        const dist = Math.abs(dx);
                        const minDist = (shape.width + (other.shape?.width || 50)) * 0.5 + 20;

                        if (dist < minDist) {
                            // Push apart horizontally
                            const push = (minDist - dist) * 0.05 * (dx > 0 ? 1 : -1);
                            c.x += push;
                        }
                    });

                    // Keep in horizontal bounds
                    const margin = shape.width * 0.5 + 20;
                    if (c.x < margin) c.x = margin;
                    if (c.x > canvasW - margin) c.x = canvasW - margin;

                    // Gentle drift while sinking
                    c.x += Math.sin(now / 1500 + c.id) * 0.15;

                    if (c.y >= targetY) {
                        c.y = targetY;
                        c.settled = true;
                    }
                }

                // Gentle sway - each stalk sways slightly different
                const baseSway = Math.sin(now / 3500 + shape.swayOffset) * (c.settled ? 2.5 : 0.5);

                ctx.save();
                ctx.translate(c.x + baseSway, c.y);

                // Draw each stalk with branches
                shape.stalks.forEach((stalk, si) => {
                    const stalkSway = Math.sin(now / 2800 + si * 0.7 + shape.swayOffset) * 1.8;
                    const stalkX = stalk.x + stalkSway;

                    // Alternate colors between stalks with variation
                    const stalkColor = si % 3 === 0 ? color : (si % 3 === 1 ? altColor : color);

                    ctx.strokeStyle = stalkColor;
                    // Thicker stalks based on stalk.width property
                    ctx.lineWidth = stalk.width || 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.globalAlpha = 0.85;

                    // Draw main stalk (growing upward, so negative Y)
                    ctx.beginPath();
                    ctx.moveTo(stalkX, 0);

                    // Curved stalk with more character
                    const curveMid = -stalk.height * 0.5;
                    const curveAmt = stalkSway * 1.2 + (si % 2 === 0 ? 3 : -3);
                    ctx.quadraticCurveTo(
                        stalkX + curveAmt, curveMid,
                        stalkX + stalkSway * 0.4, -stalk.height
                    );
                    ctx.stroke();

                    // Draw tip bulb (larger, more visible)
                    ctx.globalAlpha = 0.7;
                    const tipSize = 4 + (stalk.width || 2);
                    ctx.beginPath();
                    ctx.arc(stalkX + stalkSway * 0.4, -stalk.height - tipSize * 0.5, tipSize, 0, Math.PI * 2);
                    ctx.fillStyle = stalkColor;
                    ctx.fill();

                    // Draw branches with sub-branches
                    ctx.globalAlpha = 0.8;
                    stalk.branches.forEach((branch, bi) => {
                        const branchSway = Math.sin(now / 2200 + bi * 1.1 + shape.swayOffset) * 1.2;
                        ctx.lineWidth = branch.width || 2;

                        // Branch starts from stalk at given Y position
                        const branchStartY = -branch.y;
                        const branchStartX = stalkX + (branchStartY / -stalk.height) * stalkSway * 0.4;

                        // Branch end position
                        const branchEndX = branchStartX + Math.sin(branch.angle) * branch.length + branchSway;
                        const branchEndY = branchStartY - Math.cos(branch.angle) * branch.length * 0.85;

                        ctx.beginPath();
                        ctx.moveTo(branchStartX, branchStartY);
                        ctx.lineTo(branchEndX, branchEndY);
                        ctx.stroke();

                        // Branch tip
                        if (branch.hasTip) {
                            ctx.globalAlpha = 0.6;
                            const tipSize = 3 + (branch.width || 2) * 0.5;
                            ctx.beginPath();
                            ctx.arc(branchEndX, branchEndY - tipSize * 0.3, tipSize, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 0.8;
                        }
                    });
                });

                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }

        function drawJellyfishEntities() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            jellyfish.forEach(j => {
                if (!j.shape) return;

                const color = aquaColors.jellyfish[j.id % aquaColors.jellyfish.length];
                const shape = j.shape;

                // Gentle figure-8 drift pattern
                j.orbitAngle += j.orbitSpeed * 0.4;

                const phaseOffset = j.id * 2.5;
                const currentAngle = j.orbitAngle + phaseOffset;

                // Drift path
                const centerX = w * 0.5;
                const centerY = h * 0.45;
                const radiusX = w * 0.28;
                const radiusY = h * 0.18;

                const targetX = centerX + Math.sin(currentAngle) * radiusX;
                const targetY = centerY + Math.sin(currentAngle * 2) * radiusY;

                // Very gentle, capped attraction - no erratic movement
                const dx = targetX - j.x;
                const dy = targetY - j.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Constant gentle force, capped acceleration
                const maxAccel = 0.008;
                if (dist > 10) {
                    const accel = Math.min(maxAccel, dist * 0.00008);
                    j.vx += (dx / dist) * accel;
                    j.vy += (dy / dist) * accel;
                }

                // Strong damping for smooth movement
                j.vx *= 0.96;
                j.vy *= 0.96;

                // Cap max velocity
                const maxSpeed = 0.8;
                const speed = Math.sqrt(j.vx * j.vx + j.vy * j.vy);
                if (speed > maxSpeed) {
                    j.vx = (j.vx / speed) * maxSpeed;
                    j.vy = (j.vy / speed) * maxSpeed;
                }

                // Gentle minimum drift
                const minSpeed = 0.1;
                if (speed < minSpeed && speed > 0) {
                    j.vx = (j.vx / speed) * minSpeed;
                    j.vy = (j.vy / speed) * minSpeed;
                } else if (speed === 0) {
                    // Kick-start if completely stopped
                    const kickAngle = currentAngle;
                    j.vx = Math.cos(kickAngle) * minSpeed;
                    j.vy = Math.sin(kickAngle) * minSpeed;
                }

                // Avoid other jellyfish
                jellyfish.forEach(other => {
                    if (other.id === j.id || !other.shape) return;
                    const dx = j.x - other.x;
                    const dy = j.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = shape.bellRadius + other.shape.bellRadius + 40;
                    if (dist < minDist && dist > 0) {
                        const pushForce = 0.02 * (minDist - dist) / minDist;
                        j.vx += (dx / dist) * pushForce;
                        j.vy += (dy / dist) * pushForce;
                    }
                });

                // Avoid fish
                fish.forEach(f => {
                    const dx = j.x - f.x;
                    const dy = j.y - f.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = shape.bellRadius + f.size * 0.5 + 30;
                    if (dist < minDist && dist > 0) {
                        const pushForce = 0.015 * (minDist - dist) / minDist;
                        j.vx += (dx / dist) * pushForce;
                        j.vy += (dy / dist) * pushForce;
                    }
                });

                // Pumping propulsion - slower, gentler pulse
                const pulsePhase = (now * 0.0015 + j.pulsePhase) % (Math.PI * 2); // Slower pulse
                const isPulsing = pulsePhase < 0.5;
                if (isPulsing && pulsePhase > 0.1) {
                    j.vy -= 0.008; // Gentler upward thrust
                }

                j.x += j.vx;
                j.y += j.vy;

                // Strong edge avoidance - bounce off walls
                const margin = 50;
                const bounceForce = 0.08;
                if (j.x < margin) { j.vx += bounceForce; j.x = margin; }
                if (j.x > w - margin) { j.vx -= bounceForce; j.x = w - margin; }
                if (j.y < margin) { j.vy += bounceForce; j.y = margin; }
                if (j.y > h - margin - 30) { j.vy -= bounceForce * 1.5; j.y = h - margin - 30; }

                // Pulse animation for bell
                const pulse = Math.sin(pulsePhase);
                const bellSquash = 1 - pulse * 0.15;
                const bellStretch = 1 + pulse * 0.1;

                // Render jellyfish
                ctx.save();
                ctx.translate(j.x, j.y);

                const r = shape.bellRadius;
                const bellH = shape.bellHeight;

                // Draw bell (dome shape)
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.85;

                ctx.beginPath();
                ctx.ellipse(0, 0, r * bellSquash, bellH * bellStretch, 0, Math.PI, 0);
                ctx.stroke();

                // Bell fill
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = color;
                ctx.fill();

                // Inner bell detail
                ctx.globalAlpha = 0.35;
                ctx.beginPath();
                ctx.ellipse(0, bellH * 0.1, r * 0.5 * bellSquash, bellH * 0.4 * bellStretch, 0, Math.PI, 0);
                ctx.stroke();

                // Draw trailing tentacles
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.65;

                const tentacleTime = now * 0.002 + shape.wobbleOffset;
                for (let t = 0; t < shape.numTentacles; t++) {
                    const tx = -r * 0.8 + (t / (shape.numTentacles - 1)) * r * 1.6;

                    ctx.beginPath();
                    ctx.moveTo(tx * bellSquash, bellH * 0.05);

                    // Draw wavy tentacle trailing down
                    for (let s = 1; s <= shape.tentacleLength; s++) {
                        const segY = bellH * 0.05 + s * (r * 0.4);
                        const wave = Math.sin(tentacleTime + t * 0.7 + s * 0.5) * (8 + s * 2);
                        const drift = Math.sin(tentacleTime * 0.5 + t) * 3;
                        ctx.lineTo(tx * bellSquash + wave + drift, segY);
                    }
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }

        function drawBubbleEntities() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);

            // Helper to spawn pop particles
            function popBubble(b) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    particles.push({
                        x: b.x, y: b.y,
                        vx: Math.cos(angle) * 1.5,
                        vy: Math.sin(angle) * 1.5 - 0.8,
                        life: 1, createdAt: now
                    });
                }
            }

            bubbles = bubbles.filter((b, bi) => {
                // Initialize variety properties if not set
                if (b.wobbleSpeed === undefined) {
                    b.wobbleSpeed = 300 + Math.random() * 400;
                    b.wobbleAmt = 0.2 + Math.random() * 0.4;
                    b.riseSpeed = b.vy || (0.4 + Math.random() * 0.4);
                    b.hueOffset = Math.random() * 30 - 15;
                }

                // Bubble-bubble avoidance
                let avoidX = 0;
                bubbles.forEach((other, oi) => {
                    if (oi === bi) return;
                    const dx = b.x - other.x;
                    const dy = b.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = b.radius + other.radius + 10;
                    if (dist < minDist && dist > 0) {
                        avoidX += (dx / dist) * (minDist - dist) * 0.1;
                    }
                });
                b.x += avoidX;

                // Rise upward with wobble
                b.y -= b.riseSpeed;
                b.x += Math.sin(now / b.wobbleSpeed + b.id) * b.wobbleAmt;

                // Slight horizontal drift
                b.x += Math.sin(now / 2000 + b.id * 0.3) * 0.15;

                // Keep in bounds horizontally
                if (b.x < b.radius + 10) b.x = b.radius + 10;
                if (b.x > w - b.radius - 10) b.x = w - b.radius - 10;

                // Pop when reaching top
                if (b.y + b.radius < -10) {
                    popBubble(b);
                    return false;
                }

                // Check collision with fish
                for (const f of fish) {
                    const dx = b.x - f.x;
                    const dy = b.y - f.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < b.radius + f.size * 0.4) {
                        popBubble(b);
                        return false;
                    }
                }

                // Check collision with jellyfish
                for (const j of jellyfish) {
                    if (!j.shape) continue;
                    const dx = b.x - j.x;
                    const dy = b.y - j.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < b.radius + j.shape.bellRadius * 1.5) {
                        popBubble(b);
                        return false;
                    }
                }

                // Draw bubble with variety
                const hue = 195 + b.hueOffset;
                const bubbleColor = `hsla(${hue}, 70%, 65%, 0.6)`;
                const glowColor = `hsla(${hue}, 70%, 65%, 0.4)`;

                // Subtle squash/stretch as it rises
                const squash = 1 + 0.05 * Math.sin(now / 300 + b.id);

                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.strokeStyle = bubbleColor;
                ctx.lineWidth = 1.5;

                ctx.beginPath();
                ctx.ellipse(b.x, b.y, b.radius * squash, b.radius / squash, 0, 0, Math.PI * 2);
                ctx.stroke();

                // Shine highlight
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.ellipse(
                    b.x - b.radius * 0.25,
                    b.y - b.radius * 0.25,
                    b.radius * 0.2,
                    b.radius * 0.15,
                    -0.4,
                    0, Math.PI * 2
                );
                ctx.fill();

                ctx.globalAlpha = 1;
                ctx.restore();
                return true;
            });
        }

        function drawFoodEntities() {
            const now = Date.now();
            food = food.filter(f => {
                const age = now - f.createdAt;
                if (age > FOOD_LIFETIME) return false;

                // Fade out in last 3 seconds
                let opacity = 1;
                if (age > FOOD_LIFETIME - 3000) {
                    opacity = (FOOD_LIFETIME - age) / 3000;
                }

                ctx.save();
                ctx.shadowColor = aquaColors.food;
                ctx.shadowBlur = 8 * opacity;
                ctx.globalAlpha = opacity;

                // Pulsing dot
                const pulse = 1 + 0.2 * Math.sin(now / 400 + f.id);
                const radius = 4 * pulse;

                ctx.fillStyle = aquaColors.food;
                ctx.beginPath();
                ctx.arc(f.x, f.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Outer glow ring
                ctx.globalAlpha = opacity * 0.3;
                ctx.strokeStyle = aquaColors.food;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(f.x, f.y, radius + 4, 0, Math.PI * 2);
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                ctx.restore();
                return true;
            });
        }

        function drawTempLineEntities() {
            const now = Date.now();
            tempLines = tempLines.filter(ln => {
                const age = now - ln.createdAt;
                if (age > LINE_DURATION) return false;

                const opacity = 1 - (age / LINE_DURATION);
                const pts = ln.points;
                if (pts.length < 2) return true;

                // Line-to-bubble popping: check each segment against bubbles
                const step = Math.max(1, Math.floor(pts.length / 20));
                for (let i = step; i < pts.length; i += step) {
                    const p1 = pts[i - step];
                    const p2 = pts[i];
                    for (let bi = bubbles.length - 1; bi >= 0; bi--) {
                        const b = bubbles[bi];
                        if (segmentIntersectsCircle(p1, p2, b.x, b.y, b.radius)) {
                            for (let j = 0; j < 6; j++) {
                                const a = (j / 6) * Math.PI * 2;
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: Math.cos(a) * 1.2,
                                    vy: Math.sin(a) * 0.5 - 0.5,
                                    life: 1, createdAt: now
                                });
                            }
                            bubbles.splice(bi, 1);
                        }
                    }
                }

                ctx.save();
                ctx.strokeStyle = `rgba(77, 201, 246, ${0.6 * opacity})`;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                for (let i = 1; i < pts.length; i++) {
                    const p0 = pts[i - 1];
                    const p1 = pts[i];
                    ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
                }
                ctx.stroke();
                ctx.restore();
                return true;
            });
        }

        // Cursor with glow
        let cursorPos = { x: -100, y: -100 };
        let cursorVisible = false;
        
        function drawCursor() {
            if (!cursorVisible) return;
            
            const x = cursorPos.x;
            const y = cursorPos.y;
            const size = isDrawing ? 14 : 10;
            
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
            gradient.addColorStop(0, isDrawing ? 'rgba(251, 146, 60, 0.25)' : 'rgba(59, 130, 246, 0.2)');
            gradient.addColorStop(0.5, isDrawing ? 'rgba(251, 146, 60, 0.08)' : 'rgba(59, 130, 246, 0.05)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, 60, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = isDrawing ? colors.cursor : 'rgba(147, 197, 253, 0.7)';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = isDrawing ? colors.cursor : colors.glow;
            ctx.shadowBlur = 8;
            
            ctx.beginPath();
            ctx.moveTo(x - size, y); ctx.lineTo(x - 4, y);
            ctx.moveTo(x + 4, y); ctx.lineTo(x + size, y);
            ctx.moveTo(x, y - size); ctx.lineTo(x, y - 4);
            ctx.moveTo(x, y + 4); ctx.lineTo(x, y + size);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            if (isDrawing) {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = colors.cursor;
                ctx.fill();
            }
        }
        
        // Draw ripple effects (for tap/dot feedback)
        function drawRipples() {
            const now = Date.now();
            const rippleDuration = 600;
            
            ripples = ripples.filter(ripple => {
                const age = now - ripple.createdAt;
                if (age > rippleDuration) return false;
                
                const progress = age / rippleDuration;
                const eased = 1 - Math.pow(1 - progress, 3); // ease out cubic
                const radius = ripple.maxRadius * eased;
                const opacity = 1 - progress;
                
                ctx.strokeStyle = `rgba(96, 165, 250, ${0.6 * opacity})`;
                ctx.lineWidth = 2 * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Second ring
                if (progress > 0.15) {
                    const innerProgress = (progress - 0.15) / 0.85;
                    const innerRadius = ripple.maxRadius * 0.6 * innerProgress;
                    ctx.strokeStyle = `rgba(147, 197, 253, ${0.4 * (1 - innerProgress)})`;
                    ctx.lineWidth = 1.5 * (1 - innerProgress * 0.5);
                    ctx.beginPath();
                    ctx.arc(ripple.x, ripple.y, innerRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                return true;
            });
        }
        
        // Draw particle burst (for shape recognition feedback)
        function drawParticles() {
            const now = Date.now();
            const particleDuration = 800;
            
            particles = particles.filter(p => {
                const age = now - p.createdAt;
                if (age > particleDuration) return false;
                
                const progress = age / particleDuration;
                const opacity = 1 - progress;
                
                // Update position with slight gravity
                p.x += p.vx;
                p.y += p.vy + progress * 0.5;
                p.vx *= 0.97;
                p.vy *= 0.97;
                
                // Draw crystalline particle - hexagonal shard
                const size = 4 * (1 - progress * 0.5);

                // Gradient from cyan to purple (bioluminescent crystallization)
                const hue = 180 + progress * 100; // cyan to purple transition
                const r = Math.round(0 + progress * 199);
                const g = Math.round(217 - progress * 92);
                const b = 255;

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.createdAt * 0.002); // Subtle rotation based on creation time

                // Hexagonal crystal shard
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.9 * opacity})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const x = Math.cos(angle) * size;
                    const y = Math.sin(angle) * size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();

                ctx.restore();
                
                return true;
            });
        }
        
        // Draw ambient floating particles
        function initAmbientParticles() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            for (let i = 0; i < 15; i++) {
                ambientParticles.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    size: 1 + Math.random() * 2,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }
        initAmbientParticles();

        // Spawn a starter jellyfish to invite interaction
        (function spawnStarterJellyfish() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            const cx = w * 0.35 + Math.random() * w * 0.3;
            const cy = h * 0.35 + Math.random() * h * 0.3;
            const size = 50;

            // Use the new shape structure
            const shape = generateJellyfishShape(size);
            const orbitAngle = Math.random() * Math.PI * 2;

            jellyfish.push({
                id: entityIdCounter++,
                shape: shape,
                x: cx, y: cy,
                size: size,
                vx: 0,
                vy: 0,
                orbitAngle: orbitAngle,
                orbitRadius: 80 + Math.random() * 60,
                orbitSpeed: 0.0003 + Math.random() * 0.0002,
                orbitCenterX: w / 2,
                orbitCenterY: h * 0.4,
                pulsePhase: Math.random() * Math.PI * 2,
                createdAt: Date.now()
            });
        })();

        function drawAmbientParticles() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            ambientParticles.forEach(p => {
                // Drift movement
                p.x += p.vx;
                p.y += p.vy;
                
                // Wrap around edges
                if (p.x < 0) p.x = w;
                if (p.x > w) p.x = 0;
                if (p.y < 0) p.y = h;
                if (p.y > h) p.y = 0;
                
                // Pulsing opacity
                const pulse = 0.15 + 0.1 * Math.sin(now / 2000 + p.phase);

                ctx.fillStyle = `rgba(147, 197, 253, ${pulse})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ============================================
        // Debug Visualization
        // ============================================
        function drawDebug() {
            if (!debugMode) return;

            ctx.save();

            // Draw food hitboxes
            food.forEach(fd => {
                // Food detection range (just a small marker)
                ctx.strokeStyle = 'rgba(122, 229, 130, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(fd.x, fd.y, 8, 0, Math.PI * 2);
                ctx.stroke();

                // Label
                ctx.setLineDash([]);
                ctx.font = '9px JetBrains Mono';
                ctx.fillStyle = 'rgba(122, 229, 130, 0.7)';
                ctx.fillText('food', fd.x + 10, fd.y + 3);
            });

            // Draw fish debug info
            fish.forEach(f => {
                const bodyWidth = f.bodyWidth || 20;
                const bodyHeight = f.bodyHeight || bodyWidth * 0.4;
                const scaleX = f.scaleX || 1;

                // Mouth position (60% toward nose from center, matching AI code)
                const rawNoseOffset = f.useSvgPath
                    ? (f.noseOffset || bodyWidth)
                    : (f.noseOffset || bodyWidth) * scaleX;
                const mouthOffset = rawNoseOffset * 0.6;

                // Oval collision dimensions (30% buffer, matching collision code)
                const collisionW = bodyWidth * 1.3;
                const collisionH = bodyHeight * 1.3;

                // Draw OVAL collision bounds (rotated to fish heading)
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.heading);
                ctx.ellipse(0, 0, collisionW, collisionH, 0, 0, Math.PI * 2);
                ctx.restore();
                ctx.stroke();

                // Fish body bounds (full visual size)
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.2)';
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.heading);
                ctx.ellipse(0, 0, bodyWidth, bodyHeight, 0, 0, Math.PI * 2);
                ctx.restore();
                ctx.stroke();

                // Mouth position (closer to center now)
                const mouthX = f.x + Math.cos(f.heading) * mouthOffset;
                const mouthY = f.y + Math.sin(f.heading) * mouthOffset;

                // Mouth marker (crosshair)
                ctx.setLineDash([]);
                ctx.strokeStyle = 'rgba(0, 255, 150, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(mouthX - 5, mouthY);
                ctx.lineTo(mouthX + 5, mouthY);
                ctx.moveTo(mouthX, mouthY - 5);
                ctx.lineTo(mouthX, mouthY + 5);
                ctx.stroke();

                // Eating range circle around mouth (varies by size)
                const sizeCategory = f.sizeCategory || 'medium';
                const BASE_EAT = 35;
                const debugEatRange = sizeCategory === 'large' ? BASE_EAT :
                                      (sizeCategory === 'medium' ? BASE_EAT * 0.5 : BASE_EAT * 0.25);
                ctx.strokeStyle = 'rgba(0, 255, 150, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(mouthX, mouthY, debugEatRange, 0, Math.PI * 2);
                ctx.stroke();

                // Heading direction arrow (current)
                ctx.setLineDash([]);
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.7)';
                ctx.lineWidth = 2;
                const arrowLen = 30;
                const arrowX = f.x + Math.cos(f.heading) * arrowLen;
                const arrowY = f.y + Math.sin(f.heading) * arrowLen;
                ctx.beginPath();
                ctx.moveTo(f.x, f.y);
                ctx.lineTo(arrowX, arrowY);
                ctx.stroke();

                // Arrowhead
                const headLen = 6;
                const headAngle = 0.5;
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(
                    arrowX - Math.cos(f.heading - headAngle) * headLen,
                    arrowY - Math.sin(f.heading - headAngle) * headLen
                );
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(
                    arrowX - Math.cos(f.heading + headAngle) * headLen,
                    arrowY - Math.sin(f.heading + headAngle) * headLen
                );
                ctx.stroke();

                // Target heading (where fish wants to go)
                if (f.targetHeading !== undefined) {
                    ctx.strokeStyle = 'rgba(255, 200, 0, 0.5)';
                    ctx.setLineDash([3, 3]);
                    const targetArrowLen = 22;
                    const targetX = f.x + Math.cos(f.targetHeading) * targetArrowLen;
                    const targetY = f.y + Math.sin(f.targetHeading) * targetArrowLen;
                    ctx.beginPath();
                    ctx.moveTo(f.x, f.y);
                    ctx.lineTo(targetX, targetY);
                    ctx.stroke();
                }

                // Center marker
                ctx.setLineDash([]);
                ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
                ctx.beginPath();
                ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw wander target if exists
                if (f.wanderTarget) {
                    ctx.strokeStyle = 'rgba(100, 255, 200, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 4]);
                    ctx.beginPath();
                    ctx.moveTo(f.x, f.y);
                    ctx.lineTo(f.wanderTarget.x, f.wanderTarget.y);
                    ctx.stroke();
                    // Wander target marker
                    ctx.fillStyle = 'rgba(100, 255, 200, 0.4)';
                    ctx.beginPath();
                    ctx.arc(f.wanderTarget.x, f.wanderTarget.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw hunt target line if hunting
                if (f.state === 'hunting' && f.huntTarget !== null) {
                    const prey = fish.find(p => p.id === f.huntTarget);
                    if (prey) {
                        ctx.strokeStyle = 'rgba(255, 50, 50, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([4, 4]);
                        ctx.beginPath();
                        ctx.moveTo(f.x, f.y);
                        ctx.lineTo(prey.x, prey.y);
                        ctx.stroke();
                    }
                }

                // Labels
                ctx.setLineDash([]);
                ctx.font = '9px JetBrains Mono';
                const labelX = f.x + collisionW + 10;

                // Size category label (SMALL/MEDIUM/LARGE) - sizeCategory already defined above
                let sizeColor;
                if (sizeCategory === 'small') sizeColor = 'rgba(150, 220, 150, 0.9)';
                else if (sizeCategory === 'medium') sizeColor = 'rgba(220, 200, 100, 0.9)';
                else sizeColor = 'rgba(150, 150, 220, 0.9)';
                ctx.fillStyle = sizeColor;
                ctx.fillText(sizeCategory.toUpperCase(), labelX, f.y - 14);

                // State label (with hunting indicator)
                let stateColor;
                let stateText = f.state || 'idle';
                if (f.state === 'fleeing') stateColor = 'rgba(255, 100, 100, 1)';
                else if (f.state === 'hunting') { stateColor = 'rgba(255, 50, 50, 0.9)'; stateText = '🎯 hunting'; }
                else if (f.state === 'seeking') stateColor = 'rgba(255, 200, 0, 0.9)';
                else stateColor = 'rgba(100, 200, 255, 0.6)';
                ctx.fillStyle = stateColor;
                ctx.fillText(stateText, labelX, f.y);

                // Personality bar (E/C/N = energy/curiosity/nervousness)
                const e = f.energy || 0.5;
                const c = f.curiosity || 0.4;
                const n = f.nervousness || 0.4;
                ctx.fillStyle = 'rgba(150, 150, 150, 0.4)';
                ctx.fillText(`E${(e*10).toFixed(0)} C${(c*10).toFixed(0)} N${(n*10).toFixed(0)}`, labelX, f.y + 14);

                // Dimensions
                ctx.fillStyle = 'rgba(120, 120, 120, 0.4)';
                ctx.fillText(`${Math.round(bodyWidth)}×${Math.round(bodyHeight)}`, labelX, f.y + 26);
            });

            // Draw jellyfish bounds
            jellyfish.forEach(j => {
                if (!j.shape) return;
                ctx.strokeStyle = 'rgba(199, 125, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(j.x, j.y, j.shape.bellRadius * 1.5, 0, Math.PI * 2);
                ctx.stroke();
            });

            ctx.setLineDash([]);
            ctx.restore();
        }

        // Animation loop - smart pausing when idle
        let animationFrameId = null;
        let isAnimating = false;

        function hasActiveAnimation() {
            return isDrawing ||
                   debugMode ||
                   particles.length > 0 ||
                   ripples.length > 0 ||
                   strokes.length > 0 ||
                   jellyfish.length > 0 ||
                   fish.length > 0 ||
                   coral.length > 0 ||
                   bubbles.length > 0 ||
                   food.length > 0 ||
                   tempLines.length > 0 ||
                   currentStroke !== null;
        }

        function animate() {
            drawGrid();
            drawAmbientParticles();
            drawCoralEntities();
            drawFoodEntities();
            drawFishEntities();
            drawJellyfishEntities();
            drawBubbleEntities();
            drawTempLineEntities();
            drawRawStrokes();
            drawRipples();
            drawParticles();
            drawCursor();
            drawDebug();

            // Only continue animation if there's something active
            if (hasActiveAnimation()) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                isAnimating = false;
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (!isAnimating) {
                isAnimating = true;
                animate();
            }
        }

        // Start initial animation
        startAnimation();
        
        // ============================================
        // Event Handlers
        // ============================================
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function startDraw(e) {
            e.preventDefault();
            isDrawing = true;
            hero.classList.add('drawing');
            startAnimation(); // Ensure animation loop is running

            const pos = getPos(e);
            currentStroke = {
                points: [pos],
                startTime: Date.now(),
                fadeStart: TIMING.strokeHold
            };
            strokes.push(currentStroke);
        }
        
        function draw(e) {
            const pos = getPos(e);
            cursorPos = pos;
            cursorVisible = true;
            
            if (!isDrawing || !currentStroke) return;
            e.preventDefault();
            currentStroke.points.push(pos);
        }
        
        function endDraw() {
            if (!currentStroke) {
                isDrawing = false;
                return;
            }

            const points = [...currentStroke.points];
            const classified = classifyStroke(points);

            if (classified) {
                const id = entityIdCounter++;
                const now = Date.now();

                if (classified.type === 'food') {
                    // FIFO: remove oldest if at limit
                    if (food.length >= MAX_FOOD) food.shift();
                    food.push({
                        id,
                        x: classified.center.x,
                        y: classified.center.y,
                        createdAt: now
                    });

                    // Ripple feedback
                    ripples.push({
                        x: classified.center.x,
                        y: classified.center.y,
                        createdAt: now,
                        maxRadius: 30
                    });

                } else if (classified.type === 'bubble') {
                    if (bubbles.length >= MAX_BUBBLES) bubbles.shift();
                    bubbles.push({
                        id,
                        x: classified.center.x,
                        y: classified.center.y,
                        radius: classified.radius,
                        vy: 0.3 + Math.random() * 0.4,
                        createdAt: now
                    });

                } else if (classified.type === 'coral') {
                    if (coral.length >= MAX_CORAL) coral.shift();
                    coral.push({
                        id,
                        shape: classified.shape,
                        x: classified.center.x,
                        y: classified.center.y,
                        size: classified.size,
                        settled: false,
                        createdAt: now
                    });

                } else if (classified.type === 'fish') {
                    if (fish.length >= MAX_FISH) fish.shift();
                    const fishShape = classified.fishShape;
                    const heading = fishShape.initialHeading;
                    const hueShift = (id * 47) % 360;

                    // Personality traits (0-1 scale)
                    const energy = 0.3 + Math.random() * 0.7;      // Lazy to hyperactive
                    const curiosity = 0.2 + Math.random() * 0.6;   // Stick to area vs explore
                    const nervousness = 0.2 + Math.random() * 0.6; // Calm vs easily startled

                    fish.push({
                        id,
                        points: fishShape.points,
                        bodyPoints: fishShape.bodyPoints,
                        throughLine: fishShape.throughLine,
                        bodyWidth: fishShape.bodyWidth,
                        bodyHeight: fishShape.bodyHeight,
                        noseOffset: fishShape.noseOffset,
                        isStrokeBased: fishShape.isStrokeBased,
                        useSvgPath: fishShape.useSvgPath,
                        scaleFactor: fishShape.scaleFactor,
                        x: classified.center.x,
                        y: classified.center.y,
                        size: classified.size,
                        vx: Math.cos(heading) * 0.4,
                        vy: Math.sin(heading) * 0.4,
                        heading: heading,
                        targetHeading: heading,
                        state: 'idle',
                        hueShift: hueShift,
                        scaleX: 0.9 + Math.random() * 0.2,
                        scaleY: 0.9 + Math.random() * 0.2,
                        // Personality
                        energy: energy,
                        curiosity: curiosity,
                        nervousness: nervousness,
                        // Wander system
                        wanderTarget: null,
                        wanderTimer: 0,
                        restTimer: 0,
                        currentSpeed: 0.4,
                        // Hunting (for large fish)
                        huntTarget: null,
                        lastAteAt: 0,
                        createdAt: now
                    });

                } else if (classified.type === 'jellyfish') {
                    if (jellyfish.length >= MAX_JELLYFISH) jellyfish.shift();
                    const w = canvas.width / (window.devicePixelRatio || 1);
                    const h = canvas.height / (window.devicePixelRatio || 1);
                    // Initialize orbit around center of tank
                    const orbitAngle = Math.random() * Math.PI * 2;
                    jellyfish.push({
                        id,
                        shape: classified.shape,
                        x: classified.center.x,
                        y: classified.center.y,
                        size: classified.size,
                        vx: 0,
                        vy: 0,
                        orbitAngle: orbitAngle,
                        orbitRadius: 80 + Math.random() * 60,
                        orbitSpeed: 0.0003 + Math.random() * 0.0002,
                        orbitCenterX: w / 2,
                        orbitCenterY: h * 0.4,
                        pulsePhase: Math.random() * Math.PI * 2,
                        createdAt: now
                    });

                } else if (classified.type === 'line') {
                    tempLines.push({
                        id,
                        points: classified.points,
                        createdAt: now
                    });
                }

                // Particle burst feedback for recognized entity types (not lines)
                if (classified.type !== 'line') {
                    const burstCount = classified.type === 'food' ? 4 : 8;
                    for (let i = 0; i < burstCount; i++) {
                        const angle = (i / burstCount) * Math.PI * 2;
                        particles.push({
                            x: classified.center.x,
                            y: classified.center.y,
                            vx: Math.cos(angle) * (1 + Math.random()),
                            vy: Math.sin(angle) * (1 + Math.random()),
                            life: 1,
                            createdAt: Date.now()
                        });
                    }
                }

                // Hide raw stroke quickly since entity is now rendered
                currentStroke.fadeStart = 0;
                startAnimation();
            }

            isDrawing = false;
            currentStroke = null;
            setTimeout(() => {
                if (!isDrawing) hero.classList.remove('drawing');
            }, 500);
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseleave', () => { endDraw(); cursorVisible = false; });
        canvas.addEventListener('mouseenter', () => { cursorVisible = true; });
        
        canvas.addEventListener('touchstart', startDraw, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', endDraw);
        canvas.addEventListener('touchcancel', endDraw);

        // Debug toggle
        const debugToggle = document.getElementById('toggleDebug');
        if (debugToggle) {
            debugToggle.addEventListener('change', (e) => {
                debugMode = e.target.checked;
                startAnimation();
            });
        }

        // Click to scare fish - check if click hit a fish
        function scareFishAtPoint(x, y) {
            const SCARE_RADIUS = 60; // How close click needs to be
            let scared = false;

            fish.forEach(f => {
                const dx = x - f.x;
                const dy = y - f.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Check if click is within fish's general area
                const hitRadius = Math.max(f.bodyWidth || 30, f.bodyHeight || 20) + SCARE_RADIUS;

                if (dist < hitRadius) {
                    // Scare this fish! Flee away from click point
                    f.state = 'fleeing';
                    f.fleeTimer = 800 + Math.random() * 400; // Flee for 0.8-1.2 seconds
                    f.targetHeading = Math.atan2(f.y - y, f.x - x); // Away from click
                    f.heading = f.targetHeading; // Instant turn when scared
                    scared = true;

                    // Burst of particles at fish location
                    for (let i = 0; i < 4; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        particles.push({
                            x: f.x, y: f.y,
                            vx: Math.cos(angle) * 2,
                            vy: Math.sin(angle) * 2,
                            life: 1, createdAt: Date.now()
                        });
                    }
                }
            });

            return scared;
        }

        // Add click listener for scaring fish
        canvas.addEventListener('click', (e) => {
            const pos = getPos(e);
            if (scareFishAtPoint(pos.x, pos.y)) {
                startAnimation();
            }
        });

        // ============================================
        // Cursor Spotlight Effect
        // ============================================
        const spotlight = document.getElementById('cursorSpotlight');
        let spotlightX = window.innerWidth / 2;
        let spotlightY = window.innerHeight / 2;
        let isSpotlightActive = false;

        function updateSpotlight(x, y) {
            spotlightX = x;
            spotlightY = y;
            const xPercent = (x / window.innerWidth) * 100;
            const yPercent = (y / window.innerHeight) * 100;
            spotlight.style.background = `radial-gradient(600px circle at ${xPercent}% ${yPercent}%, rgba(77, 201, 246, 0.12), rgba(212, 175, 55, 0.06) 40%, transparent 70%)`;
        }

        // Mouse events
        document.addEventListener('mousemove', (e) => {
            if (!isSpotlightActive) {
                spotlight.classList.add('active');
                isSpotlightActive = true;
            }
            updateSpotlight(e.clientX, e.clientY);
        });

        document.addEventListener('mouseleave', () => {
            spotlight.classList.remove('active');
            isSpotlightActive = false;
        });

        // Touch events
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 0) {
                spotlight.classList.add('active');
                isSpotlightActive = true;
                updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            // Keep spotlight visible for a moment after touch ends
            setTimeout(() => {
                if (!isSpotlightActive) {
                    spotlight.classList.remove('active');
                }
            }, 2000);
        });

        // ============================================
        // Demo Canvas - Interactive Fish Animation
        // ============================================
    </script>
</body>
</html>
