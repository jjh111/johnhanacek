<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>John Hanacek - Portfolio</title>
    <meta name="description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems. LLMs, XR, robotics.">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="./Assets/favicon-jhsigfrmpaper.png">

    <!-- Open Graph / Social Share -->
    <meta property="og:title" content="John Hanacek - Portfolio">
    <meta property="og:description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems.">
    <meta property="og:image" content="https://www.johnhanacek.com/Assets/socialgraph-jhcom.png">
    <meta property="og:url" content="https://www.johnhanacek.com/">
    <meta property="og:type" content="website">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="John Hanacek - Portfolio">
    <meta name="twitter:description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems.">
    <meta name="twitter:image" content="https://www.johnhanacek.com/Assets/socialgraph-jhcom.png">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Raleway:wght@100;200;300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles/shared.css">
</head>
<body>
    <!-- Interactive Cursor Spotlight -->
    <div id="cursorSpotlight"></div>

    <a href="#about" class="skip-link">Skip to main content</a>

    <nav id="nav" role="navigation" aria-label="Main navigation">
        <div class="nav-inner">
            <div class="nav-left">
                <a href="index.html" class="shape-link active" aria-label="Home" aria-current="page">
                    <svg class="shape triangle" viewBox="0 0 40 40"><polygon points="20,8 34,32 6,32"/></svg>
                    <img class="shape-label shape-label-img" src="./Assets/footer-JHsig.png" alt="JH">
                </a>
                <a href="design.html" class="shape-link" aria-label="Design">
                    <svg class="shape rounded-square" viewBox="0 0 40 40"><rect x="6" y="6" width="28" height="28" rx="6"/></svg>
                    <span class="shape-label">DESIGN</span>
                </a>
                <a href="art.html" class="shape-link" aria-label="Art">
                    <svg class="shape circle" viewBox="0 0 40 40"><circle cx="20" cy="20" r="14"/></svg>
                    <span class="shape-label">ART</span>
                </a>
                <a href="index.html" class="nav-title">John Hanacek</a>
            </div>
            <button class="nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-right">
                <li><a href="#about">About</a></li>
                <li><a href="#believe">I Believe</a></li>
                <li><a href="#highlights">Highlights</a></li>
                <li><a href="#endorsements">Endorsements</a></li>
                <li><a href="#explore">Explore</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </div>
    </nav>

    <header class="hero" id="top">
        <!-- Shape Navigation (hero) -->
        <nav class="shape-nav" aria-label="Page navigation">
            <a href="index.html" class="shape-link active" aria-label="Home" aria-current="page">
                <svg class="shape triangle" viewBox="0 0 40 40"><polygon points="20,8 34,32 6,32"/></svg>
                <img class="shape-label shape-label-img" src="./Assets/footer-JHsig.png" alt="JH">
            </a>
            <a href="design.html" class="shape-link" aria-label="Design">
                <svg class="shape rounded-square" viewBox="0 0 40 40"><rect x="6" y="6" width="28" height="28" rx="6"/></svg>
                <span class="shape-label">DESIGN</span>
            </a>
            <a href="art.html" class="shape-link" aria-label="Art">
                <svg class="shape circle" viewBox="0 0 40 40"><circle cx="20" cy="20" r="14"/></svg>
                <span class="shape-label">ART</span>
            </a>
        </nav>

        <!-- Interactive Blueprint Canvas -->
        <canvas id="heroCanvas"></canvas>
        <div class="hero-hint">
            <span class="hint-icon">✎</span>
            <span class="hint-text">draw</span>
        </div>
        
        <div class="hero-content">
            <h1>John <span class="meta">Hanacek</span></h1>
            <p class="tagline">FOUNDING DESIGNER · DESIGN ENGINEER · PRODUCT DESIGNER</p>
            <p class="byline"> <span class="role">Sounds like · (Hana-check)</span></p>
            <img class="hero-sig-inline" src="./Assets/footer-JHsig.png" alt="John Hanacek signature">
        </div>
        <a href="#about" class="scroll-indicator" aria-label="Scroll to content">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                <path d="M7 13l5 5 5-5M7 6l5 5 5-5"/>
            </svg>
            <span class="scroll-text">goto content</span>
        </a>
    </header>

    <main>
        <!-- ABOUT -->
        <section id="about">
            <h2>About</h2>

            <div class="content-card about">
                <p><strong>Founding Designer & Design Engineer</strong> building at the intersection of AI, spatial computing, and human-computer symbiosis.</p>
                <p>I design and code <strong>agentic systems</strong>, XR interfaces, and AI-augmented tools. Currently exploring <strong>MetaMedium</strong> concepts—dynamic knowledge systems that blur the line between tool and medium—and developing robotics projects like <strong>OpenClaw</strong>, an open-source manipulation bot.</p>
            </div>
        </section>

        <!-- I BELIEVE -->
        <section id="believe">
            <h2>I Believe</h2>

            <div class="content-card">
                <p>Imagination is within reality.</p>
                <p>Infinite Games are more powerful than Finite Games.</p>
                <p>Technology can augment human intelligence & collaboration.</p>
                <p>Optimism and pessimism are self-fulfilling prophecies.</p>
                <p>We can choose better prophecies...</p>
            </div>
        </section>

        <!-- HIGHLIGHTS -->
        <section id="highlights">
            <h2>Highlights</h2>

            <div class="card-grid cols-3">
                <div class="content-card" data-num="01">
                    <h4>Georgetown MA 2016</h4>
                    <p>Awarded <strong>"Most Meta"</strong> by peers in Communication, Culture & Technology</p>
                </div>

                <div class="content-card" data-num="02">
                    <h4>Founder Institute 2020</h4>
                    <p>Graduate as CEO of <strong><a href="https://www.avatarmedic.com" target="_blank" rel="noopener">AvatarMEDIC</a></strong></p>
                </div>

                <div class="content-card" data-num="03">
                    <h4>Aerospace Medical Association 2022</h4>
                    <p><strong>R&D Innovation Award</strong> for XR Digital Twin robotics control</p>
                </div>
            </div>
        </section>



        <!-- ENDORSEMENTS -->
        <section id="endorsements">
            <h2>Featured Endorsements</h2>

            <div class="grid-2">
                <div class="content-card endorsement">
                    <p>"My choice for the most plausible vision of a future I desire goes to John Hanacek's scenario. I think I'd like to live there, and I think it is plausible in 100 years. My $100 goes to him."</p>
                    <cite><strong><a href="https://kk.org/thetechnium/a-desirable-future-haiku/" target="_blank" rel="noopener">Kevin Kelly</a></strong>, Futurist, Founder of Wired Magazine</cite>
                </div>

                <div class="content-card endorsement short">
                    <p>"Talented and very experienced designer!"</p>
                    <cite><strong><a href="https://www.linkedin.com/in/ipetryaevskaya/" target="_blank" rel="noopener">Inga Petryaevskaya</a></strong>, CEO <a href="https://www.shapesxr.com" target="_blank" rel="noopener">ShapesXR</a></cite>
                </div>
            </div>
        </section>

        <!-- EXPLORE & CONTACT - side by side on widescreen -->
        <div class="widescreen-split">
            <section id="explore">
                <h2>Explore</h2>

                <div class="content-card">
                    <h4><a href="design.html">Design Portfolio</a></h4>
                    <p>Professional work, case studies, and XR projects</p>
                </div>

                <div class="content-card">
                    <h4><a href="art.html">Art & Creative</a></h4>
                    <p>Visual art, photography, and creative experiments</p>
                </div>

                <div class="content-card">
                    <h4><a href="about.html">About & Experience</a></h4>
                    <p>Full bio, work history, and expertise</p>
                </div>

                <div class="content-card">
                    <h4><a href="services.html">Services & Consulting</a></h4>
                    <p>Founding designer, design engineering, and AI product services</p>
                </div>
            </section>

            <section id="contact">
                <h2>Contact</h2>

                <div class="content-card">
                    <h4>Email</h4>
                    <p><a href="mailto:hi@johnhanacek.com">hi@johnhanacek.com</a></p>

                    <h4>Social</h4>
                    <ul>
                        <li><a href="https://bsky.app/profile/johnhanacek.bsky.social" target="_blank" rel="noopener">Bluesky</a></li>
                        <li><a href="https://x.com/johnhanacek" target="_blank" rel="noopener">X (Twitter)</a></li>
                        <li><a href="https://www.linkedin.com/in/johnhanacek/" target="_blank" rel="noopener">LinkedIn</a></li>
                    </ul>
                </div>
            </section>
        </div>

    </main>

    <footer>
        <p class="footer-title">John Hanacek</p>
        <p class="footer-subtitle">Founding Designer · Design Engineer · Product Designer</p>
        <p class="footer-copyright">© 2026 John Hanacek · JHDesign LLC </p>
        <p class="footer-signature"><img src="./Assets/footer-JHsig.png" alt="John Hanacek signature" loading="lazy"></p>
        <p class="version">Portfolio v1.0 · Updated January 2026 · Made with Claude Code</p>
    </footer>

    <script>
        // Navigation scroll visibility - show after scrolling past hero
        const nav = document.getElementById('nav');
        const hero = document.querySelector('.hero');

        function updateNavVisibility() {
            const heroBottom = hero.offsetTop + hero.offsetHeight - 60;
            if (window.scrollY > heroBottom) {
                nav.classList.add('visible');
            } else {
                nav.classList.remove('visible');
            }
        }

        window.addEventListener('scroll', updateNavVisibility);
        window.addEventListener('resize', updateNavVisibility);
        updateNavVisibility();

        // Mobile navigation toggle
        const navToggle = document.querySelector('.nav-toggle');
        const navMenu = document.querySelector('nav ul');

        navToggle.addEventListener('click', function() {
            const isExpanded = this.getAttribute('aria-expanded') === 'true';
            this.setAttribute('aria-expanded', !isExpanded);
            this.classList.toggle('active');
            navMenu.classList.toggle('open');
        });

        // Close menu when clicking a link
        navMenu.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', () => {
                navToggle.setAttribute('aria-expanded', 'false');
                navToggle.classList.remove('active');
                navMenu.classList.remove('open');
            });
        });
    </script>

    <!-- Hero Canvas Drawing Interaction -->
    <script>
        const canvas = document.getElementById('heroCanvas');
        const ctx = canvas.getContext('2d');
        
        // ============================================
        // Unified Timing Constants (in ms)
        // ============================================
        const TIMING = {
            // Raw strokes
            strokeHold: 1500,       // Time before stroke starts fading
            strokeFade: 2000,       // Fade duration for strokes
            
            // Recognized shapes
            morphDuration: 400,     // Shape morph animation
            shapeHold: 4000,        // Time shape stays at full opacity
            shapeFade: 1500,        // Fade duration for shapes
            
            // Whisper labels
            labelFadeIn: 200,       // Label fade in
            labelHold: 2500,        // Label at full opacity  
            labelFade: 800,         // Label fade out
            
            // Relationships & intersections
            relationshipFade: 1200, // Relationship indicator fade
            
            // Glyph reaction
            glyphActive: 2500,      // How long glyphs react after shape
        };
        
        // Computed totals
        TIMING.strokeTotal = TIMING.strokeHold + TIMING.strokeFade;
        TIMING.shapeTotal = TIMING.shapeHold + TIMING.shapeFade;
        TIMING.labelTotal = TIMING.labelFadeIn + TIMING.labelHold + TIMING.labelFade;
        
        let isDrawing = false;
        let strokes = [];           // Raw strokes (fade out)
        let recognizedShapes = [];  // Completed shapes (persist longer)
        let whisperLabels = [];     // Floating labels
        let rawIntersections = [];  // Intersections between raw strokes
        let currentStroke = null;
        let glyphRotation = 0;      // For reactive glyphs
        let glyphPulse = 0;
        let lastShapeTime = 0;
        let ripples = [];           // Tap ripple effects
        let particles = [];         // Recognition particle bursts
        let ambientParticles = [];  // Floating ambient particles
        
        // Deep Sea Terminal color palette
        const colors = {
            bg: '#020a12',
            grid: 'rgba(77, 201, 246, 0.06)',
            gridAccent: 'rgba(77, 201, 246, 0.12)',
            stroke: 'rgba(77, 201, 246, 0.85)',
            strokeComplete: 'rgba(212, 175, 55, 0.9)',
            ghost: 'rgba(77, 201, 246, 0.2)',
            glyph: 'rgba(77, 201, 246, 0.25)',
            glyphActive: 'rgba(212, 175, 55, 0.6)',
            cursor: 'rgba(212, 175, 55, 0.85)',
            glow: 'rgba(77, 201, 246, 0.4)',
            label: 'rgba(122, 229, 130, 0.8)'
        };

        // ============================================
        // Helper Functions
        // ============================================
        function getBounds(points) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            points.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            return { minX, minY, maxX, maxY };
        }

        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function getCircleScore(points, center, radius) {
            let totalError = 0;
            points.forEach(p => {
                const dist = distance(p, center);
                totalError += Math.abs(dist - radius) / radius;
            });
            return Math.max(0, 1 - (totalError / points.length));
        }

        function getRectScore(points, bounds) {
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            let cornerCount = 0;
            const corners = [
                { x: bounds.minX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.maxY },
                { x: bounds.minX, y: bounds.maxY }
            ];
            const threshold = Math.max(width, height) * 0.15;
            corners.forEach(corner => {
                if (points.some(p => distance(p, corner) < threshold)) cornerCount++;
            });
            return cornerCount / 4;
        }

        function getTriangleScore(points, bounds) {
            // Improved triangle detection
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const cx = (bounds.minX + bounds.maxX) / 2;
            const cy = (bounds.minY + bounds.maxY) / 2;

            // Find the 3 most extreme points (potential vertices)
            let topPoint = points[0], bottomLeft = points[0], bottomRight = points[0];

            points.forEach(p => {
                if (p.y < topPoint.y) topPoint = p;
                if (p.y > bottomLeft.y || (p.y === bottomLeft.y && p.x < bottomLeft.x)) bottomLeft = p;
                if (p.y > bottomRight.y || (p.y === bottomRight.y && p.x > bottomRight.x)) bottomRight = p;
            });

            // Check for roughly 3 direction changes (corners)
            let turns = 0;
            const step = Math.max(1, Math.floor(points.length / 20));
            for (let i = step; i < points.length - step; i += step) {
                const prev = points[i - step];
                const curr = points[i];
                const next = points[Math.min(i + step, points.length - 1)];
                const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                let diff = Math.abs(angle2 - angle1);
                if (diff > Math.PI) diff = 2 * Math.PI - diff;
                if (diff > 0.4 && diff < 2.8) turns++;
            }

            // Aspect ratio check - triangles shouldn't be too thin
            const aspect = Math.min(width, height) / Math.max(width, height);
            const aspectOk = aspect > 0.3;

            if (turns >= 2 && turns <= 6 && aspectOk) {
                return 0.65;
            }
            return 0.25;
        }

        function getLineScore(points) {
            if (points.length < 3) return 0;
            const start = points[0];
            const end = points[points.length - 1];
            const lineLen = distance(start, end);
            if (lineLen < 30) return 0;

            let totalDev = 0;
            points.forEach(p => {
                const t = Math.max(0, Math.min(1,
                    ((p.x - start.x) * (end.x - start.x) + (p.y - start.y) * (end.y - start.y)) / (lineLen * lineLen)
                ));
                const proj = { x: start.x + t * (end.x - start.x), y: start.y + t * (end.y - start.y) };
                totalDev += distance(p, proj);
            });
            return Math.max(0, 1 - (totalDev / points.length) / (lineLen * 0.1));
        }

        function detectArrowHead(points) {
            if (points.length < 10) return false;
            const last10 = points.slice(-10);
            const end = points[points.length - 1];
            const beforeEnd = points[Math.max(0, points.length - 8)];
            const mainDir = Math.atan2(end.y - beforeEnd.y, end.x - beforeEnd.x);

            // Check for splaying at end
            let hasSplay = false;
            for (let i = 1; i < last10.length - 1; i++) {
                const dir = Math.atan2(last10[i].y - end.y, last10[i].x - end.x);
                const diff = Math.abs(dir - mainDir);
                if (diff > 0.4 && diff < 2.7) hasSplay = true;
            }
            return hasSplay;
        }

        // ============================================
        // Shape Detection
        // ============================================
        function detectShape(points) {
            if (points.length < 5) return null;

            const bounds = getBounds(points);
            const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const size = Math.max(width, height);

            if (size < 20) return null; // Too small

            // Check if closed (start near end)
            const start = points[0];
            const end = points[points.length - 1];
            const closedThreshold = size * 0.25;
            const isClosed = distance(start, end) < closedThreshold;

            if (isClosed) {
                // Analyze closed shape
                const circleScore = getCircleScore(points, center, size / 2);
                const rectScore = getRectScore(points, bounds);
                const triScore = getTriangleScore(points, bounds);

                if (circleScore > 0.7 && circleScore > rectScore && circleScore > triScore) {
                    return { type: 'circle', center, radius: size / 2, confidence: circleScore };
                }
                if (rectScore > 0.6 && rectScore > triScore) {
                    return { type: 'rectangle', bounds, center, confidence: rectScore };
                }
                if (triScore > 0.5) {
                    return { type: 'triangle', bounds, center, confidence: triScore };
                }
            } else {
                // Open shape - line or arrow
                const lineScore = getLineScore(points);
                if (lineScore > 0.7) {
                    const hasArrow = detectArrowHead(points);
                    return {
                        type: hasArrow ? 'arrow' : 'line',
                        start, end, center,
                        confidence: lineScore
                    };
                }
            }

            return null;
        }
        
        // ============================================
        // Generate Ideal Shape Points
        // ============================================
        function generateIdealShape(shape, numPoints = 60) {
            const points = [];
            
            if (shape.type === 'circle') {
                for (let i = 0; i <= numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    points.push({
                        x: shape.center.x + Math.cos(angle) * shape.radius,
                        y: shape.center.y + Math.sin(angle) * shape.radius
                    });
                }
            } else if (shape.type === 'rectangle') {
                const b = shape.bounds;
                const corners = [
                    { x: b.minX, y: b.minY }, { x: b.maxX, y: b.minY },
                    { x: b.maxX, y: b.maxY }, { x: b.minX, y: b.maxY },
                    { x: b.minX, y: b.minY }
                ];
                const perSide = Math.floor(numPoints / 4);
                for (let s = 0; s < 4; s++) {
                    for (let i = 0; i < perSide; i++) {
                        const t = i / perSide;
                        points.push({
                            x: corners[s].x + t * (corners[s + 1].x - corners[s].x),
                            y: corners[s].y + t * (corners[s + 1].y - corners[s].y)
                        });
                    }
                }
            } else if (shape.type === 'triangle') {
                const b = shape.bounds;
                const cx = (b.minX + b.maxX) / 2;
                const triPoints = [
                    { x: cx, y: b.minY },
                    { x: b.maxX, y: b.maxY },
                    { x: b.minX, y: b.maxY },
                    { x: cx, y: b.minY }
                ];
                const perSide = Math.floor(numPoints / 3);
                for (let s = 0; s < 3; s++) {
                    for (let i = 0; i < perSide; i++) {
                        const t = i / perSide;
                        points.push({
                            x: triPoints[s].x + t * (triPoints[s + 1].x - triPoints[s].x),
                            y: triPoints[s].y + t * (triPoints[s + 1].y - triPoints[s].y)
                        });
                    }
                }
            } else if (shape.type === 'line' || shape.type === 'arrow') {
                for (let i = 0; i <= numPoints; i++) {
                    const t = i / numPoints;
                    points.push({
                        x: shape.start.x + t * (shape.end.x - shape.start.x),
                        y: shape.start.y + t * (shape.end.y - shape.start.y)
                    });
                }
                if (shape.type === 'arrow') {
                    const angle = Math.atan2(shape.end.y - shape.start.y, shape.end.x - shape.start.x);
                    const headLen = 15;
                    points.push({ x: shape.end.x - headLen * Math.cos(angle - 0.4), y: shape.end.y - headLen * Math.sin(angle - 0.4) });
                    points.push(shape.end);
                    points.push({ x: shape.end.x - headLen * Math.cos(angle + 0.4), y: shape.end.y - headLen * Math.sin(angle + 0.4) });
                }
            } else if (shape.type === 'dot') {
                // Dot is just a single point
                points.push(shape.center);
            }
            
            return points;
        }
        
        // ============================================
        // Relationship Detection
        // ============================================
        function detectRelationships() {
            const relationships = [];
            const shapes = recognizedShapes.filter(s => Date.now() - s.createdAt < TIMING.shapeTotal);
            
            for (let i = 0; i < shapes.length; i++) {
                for (let j = i + 1; j < shapes.length; j++) {
                    const a = shapes[i];
                    const b = shapes[j];
                    
                    const rel = analyzeRelationship(a, b);
                    if (rel) {
                        relationships.push({
                            shapeA: a,
                            shapeB: b,
                            ...rel
                        });
                    }
                }
            }
            return relationships;
        }
        
        function analyzeRelationship(a, b) {
            const dist = distance(a.center, b.center);
            const aSize = getShapeSize(a);
            const bSize = getShapeSize(b);
            const combinedSize = (aSize + bSize) / 2;
            
            // Lines don't "contain" things - skip containment check for lines
            const aIsLine = a.type === 'line' || a.type === 'arrow';
            const bIsLine = b.type === 'line' || b.type === 'arrow';
            
            // Check containment (only for closed shapes)
            if (!aIsLine && !bIsLine && dist < Math.abs(aSize - bSize) * 0.5) {
                const container = aSize > bSize ? a : b;
                const contained = aSize > bSize ? b : a;
                return { type: 'contains', container, contained, dist };
            }
            
            // Check intersection/overlap - always check for lines
            if (aIsLine || bIsLine || dist < combinedSize * 0.9) {
                const intersections = findIntersectionPoints(a, b);
                if (intersections.length > 0) {
                    return { type: 'intersects', intersections, dist };
                }
                if (!aIsLine && !bIsLine) {
                    return { type: 'overlaps', dist };
                }
            }
            
            // Check adjacency (close but not overlapping)
            if (dist < combinedSize * 1.5) {
                return { type: 'adjacent', dist };
            }
            
            // Check alignment
            const dx = Math.abs(a.center.x - b.center.x);
            const dy = Math.abs(a.center.y - b.center.y);
            if (dx < 15) return { type: 'aligned-vertical', dist };
            if (dy < 15) return { type: 'aligned-horizontal', dist };
            
            return null;
        }
        
        function getShapeSize(shape) {
            if (shape.type === 'circle') return shape.radius * 2;
            if (shape.type === 'dot') return 12; // Small fixed size for dots
            if (shape.bounds) {
                return Math.max(shape.bounds.maxX - shape.bounds.minX, shape.bounds.maxY - shape.bounds.minY);
            }
            if (shape.start && shape.end) {
                return distance(shape.start, shape.end);
            }
            return 50;
        }
        
        function findIntersectionPoints(a, b) {
            const points = [];
            
            // Special case: two circles - use geometric calculation
            if (a.type === 'circle' && b.type === 'circle') {
                const d = distance(a.center, b.center);
                const r1 = a.radius;
                const r2 = b.radius;
                
                // Check if circles actually intersect
                if (d < r1 + r2 && d > Math.abs(r1 - r2)) {
                    // Calculate intersection points
                    const a2 = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
                    const h = Math.sqrt(Math.max(0, r1 * r1 - a2 * a2));
                    
                    const px = a.center.x + a2 * (b.center.x - a.center.x) / d;
                    const py = a.center.y + a2 * (b.center.y - a.center.y) / d;
                    
                    const dx = h * (b.center.y - a.center.y) / d;
                    const dy = h * (b.center.x - a.center.x) / d;
                    
                    points.push({ x: px + dx, y: py - dy });
                    if (h > 1) { // Two distinct points
                        points.push({ x: px - dx, y: py + dy });
                    }
                }
                return points;
            }
            
            // General case: check line segment intersections
            const aPoints = a.idealPoints || [];
            const bPoints = b.idealPoints || [];
            
            if (aPoints.length < 4 || bPoints.length < 4) return points;
            
            const stepA = Math.max(1, Math.floor(aPoints.length / 24));
            const stepB = Math.max(1, Math.floor(bPoints.length / 24));
            
            for (let i = 0; i < aPoints.length - stepA; i += stepA) {
                const a1 = aPoints[i];
                const a2 = aPoints[i + stepA];
                
                for (let j = 0; j < bPoints.length - stepB; j += stepB) {
                    const b1 = bPoints[j];
                    const b2 = bPoints[j + stepB];
                    
                    const intersection = lineIntersection(a1, a2, b1, b2);
                    if (intersection) {
                        const tooClose = points.some(p => distance(p, intersection) < 15);
                        if (!tooClose) points.push(intersection);
                    }
                }
            }
            return points.slice(0, 4);
        }
        
        function lineIntersection(p1, p2, p3, p4) {
            const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (Math.abs(d) < 0.001) return null;
            
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / d;
            
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };
            }
            return null;
        }
        
        function drawRelationships() {
            const relationships = detectRelationships();
            const now = Date.now();
            
            relationships.forEach(rel => {
                const a = rel.shapeA;
                const b = rel.shapeB;
                const age = Math.max(now - a.createdAt, now - b.createdAt);
                let opacity = 1;
                // Fade with the shapes
                if (age > TIMING.shapeHold) {
                    opacity = 1 - ((age - TIMING.shapeHold) / TIMING.relationshipFade);
                }
                if (opacity <= 0) return;
                
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                // Draw connection line
                ctx.strokeStyle = `rgba(251, 191, 36, ${0.4 * easedOpacity})`; // Warm yellow
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(a.center.x, a.center.y);
                ctx.lineTo(b.center.x, b.center.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw relationship indicator at midpoint
                const midX = (a.center.x + b.center.x) / 2;
                const midY = (a.center.y + b.center.y) / 2;
                
                // Relationship-specific visuals
                if (rel.type === 'intersects' && rel.intersections) {
                    // Draw glowing intersection points
                    rel.intersections.forEach(pt => {
                        ctx.shadowColor = 'rgba(251, 191, 36, 0.8)';
                        ctx.shadowBlur = 12 * easedOpacity;
                        ctx.fillStyle = `rgba(251, 191, 36, ${0.9 * easedOpacity})`;
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Outer ring
                        ctx.strokeStyle = `rgba(251, 191, 36, ${0.5 * easedOpacity})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    });
                    
                    // Add label near first intersection
                    if (rel.intersections.length > 0) {
                        const pt = rel.intersections[0];
                        ctx.font = '500 10px "Raleway", sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillStyle = `rgba(251, 191, 36, ${0.9 * easedOpacity})`;
                        ctx.fillText('intersects', pt.x, pt.y - 16);
                    }
                }
                
                if (rel.type === 'contains') {
                    // Draw containment brackets
                    ctx.strokeStyle = `rgba(74, 222, 128, ${0.5 * easedOpacity})`; // Green
                    ctx.lineWidth = 2;
                    const r = getShapeSize(rel.container) / 2 + 8;
                    ctx.beginPath();
                    ctx.arc(rel.container.center.x, rel.container.center.y, r, -0.3, 0.3);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(rel.container.center.x, rel.container.center.y, r, Math.PI - 0.3, Math.PI + 0.3);
                    ctx.stroke();
                    
                    // Add label
                    ctx.font = '500 10px "Raleway", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = `rgba(74, 222, 128, ${0.8 * easedOpacity})`;
                    ctx.fillText('⊃ contains', rel.container.center.x, rel.container.center.y - r - 8);
                }
                
                if (rel.type === 'adjacent') {
                    // Draw proximity indicator
                    ctx.fillStyle = `rgba(147, 197, 253, ${0.6 * easedOpacity})`;
                    ctx.beginPath();
                    ctx.arc(midX, midY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (rel.type === 'aligned-vertical' || rel.type === 'aligned-horizontal') {
                    // Draw alignment guide
                    ctx.strokeStyle = `rgba(167, 139, 250, ${0.4 * easedOpacity})`; // Purple
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 4]);
                    ctx.beginPath();
                    if (rel.type === 'aligned-vertical') {
                        ctx.moveTo(a.center.x, Math.min(a.center.y, b.center.y) - 20);
                        ctx.lineTo(a.center.x, Math.max(a.center.y, b.center.y) + 20);
                    } else {
                        ctx.moveTo(Math.min(a.center.x, b.center.x) - 20, a.center.y);
                        ctx.lineTo(Math.max(a.center.x, b.center.x) + 20, a.center.y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw relationship label with word
                const labelData = {
                    'intersects': { symbol: '×', word: 'intersects' },
                    'contains': { symbol: '⊃', word: 'contains' },
                    'overlaps': { symbol: '∩', word: 'overlaps' },
                    'adjacent': { symbol: '↔', word: 'near' },
                    'aligned-vertical': { symbol: '│', word: 'aligned' },
                    'aligned-horizontal': { symbol: '─', word: 'aligned' }
                };
                
                const labelInfo = labelData[rel.type];
                if (labelInfo && rel.type !== 'intersects') { // intersects already has point markers
                    const displayText = `${labelInfo.symbol} ${labelInfo.word}`;
                    ctx.font = '500 10px "Raleway", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Background pill
                    ctx.fillStyle = `rgba(10, 22, 40, ${0.85 * easedOpacity})`;
                    const metrics = ctx.measureText(displayText);
                    const pw = metrics.width + 12;
                    const ph = 18;
                    ctx.beginPath();
                    const rr = 9;
                    ctx.moveTo(midX - pw/2 + rr, midY - ph/2);
                    ctx.lineTo(midX + pw/2 - rr, midY - ph/2);
                    ctx.quadraticCurveTo(midX + pw/2, midY - ph/2, midX + pw/2, midY - ph/2 + rr);
                    ctx.lineTo(midX + pw/2, midY + ph/2 - rr);
                    ctx.quadraticCurveTo(midX + pw/2, midY + ph/2, midX + pw/2 - rr, midY + ph/2);
                    ctx.lineTo(midX - pw/2 + rr, midY + ph/2);
                    ctx.quadraticCurveTo(midX - pw/2, midY + ph/2, midX - pw/2, midY + ph/2 - rr);
                    ctx.lineTo(midX - pw/2, midY - ph/2 + rr);
                    ctx.quadraticCurveTo(midX - pw/2, midY - ph/2, midX - pw/2 + rr, midY - ph/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Label text
                    ctx.fillStyle = `rgba(251, 191, 36, ${0.95 * easedOpacity})`;
                    ctx.fillText(displayText, midX, midY);
                }
            });
        }
        
        // ============================================
        // Raw Stroke Intersection Detection
        // ============================================
        function detectRawIntersections() {
            const now = Date.now();
            const activeStrokes = strokes.filter(s => {
                const age = now - s.startTime;
                return age < s.fadeStart + TIMING.strokeFade && s.points.length > 3;
            });
            
            const intersections = [];
            
            // Check strokes against each other
            for (let i = 0; i < activeStrokes.length; i++) {
                for (let j = i + 1; j < activeStrokes.length; j++) {
                    const pts = findStrokeIntersections(activeStrokes[i].points, activeStrokes[j].points);
                    pts.forEach(pt => {
                        intersections.push({
                            ...pt,
                            createdAt: Math.max(activeStrokes[i].startTime, activeStrokes[j].startTime)
                        });
                    });
                }
            }
            
            // Check strokes against recognized shapes
            const activeShapes = recognizedShapes.filter(s => now - s.createdAt < TIMING.shapeTotal);
            for (const stroke of activeStrokes) {
                for (const shape of activeShapes) {
                    const pts = findStrokeIntersections(stroke.points, shape.idealPoints || []);
                    pts.forEach(pt => {
                        intersections.push({
                            ...pt,
                            createdAt: Math.max(stroke.startTime, shape.createdAt)
                        });
                    });
                }
            }
            
            return intersections;
        }
        
        function findStrokeIntersections(pointsA, pointsB) {
            const results = [];
            if (pointsA.length < 5 || pointsB.length < 5) return results;
            
            // Coarser sampling to reduce noise
            const stepA = Math.max(3, Math.floor(pointsA.length / 15));
            const stepB = Math.max(3, Math.floor(pointsB.length / 15));
            
            for (let i = 0; i < pointsA.length - stepA; i += stepA) {
                const a1 = pointsA[i];
                const a2 = pointsA[Math.min(i + stepA, pointsA.length - 1)];
                
                for (let j = 0; j < pointsB.length - stepB; j += stepB) {
                    const b1 = pointsB[j];
                    const b2 = pointsB[Math.min(j + stepB, pointsB.length - 1)];
                    
                    const intersection = lineIntersection(a1, a2, b1, b2);
                    if (intersection) {
                        // Larger minimum distance to avoid clustering
                        const tooClose = results.some(p => distance(p, intersection) < 40);
                        if (!tooClose) results.push(intersection);
                    }
                }
            }
            return results.slice(0, 3); // Max 3 per pair
        }
        
        function drawRawIntersections() {
            const now = Date.now();
            const intersections = detectRawIntersections();
            
            intersections.forEach(pt => {
                const age = now - pt.createdAt;
                let opacity = 1;
                // Sync fade with strokes
                if (age > TIMING.strokeHold) {
                    opacity = 1 - ((age - TIMING.strokeHold) / TIMING.strokeFade);
                }
                if (opacity <= 0) return;
                
                // Ease out curve for smoother fade
                const easedOpacity = opacity * opacity; // Quadratic ease out
                
                // Subtle cyan glow for raw intersections
                ctx.shadowColor = 'rgba(34, 211, 238, 0.7)';
                ctx.shadowBlur = 10 * easedOpacity;
                ctx.fillStyle = `rgba(34, 211, 238, ${0.8 * easedOpacity})`;
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Outer ring
                ctx.strokeStyle = `rgba(34, 211, 238, ${0.4 * easedOpacity})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            });
        }
        
        // ============================================
        // Canvas Setup
        // ============================================
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ============================================
        // Drawing Functions
        // ============================================
        function drawGrid() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, w, h);

            drawGlyphs(w, h);
        }
        
        function drawGlyphs(w, h) {
            const now = Date.now();
            const timeSinceShape = now - lastShapeTime;
            const isActive = timeSinceShape < TIMING.glyphActive;
            
            // Smooth transition for active state
            let activeAmount = 0;
            if (isActive) {
                // Fade in quickly, fade out smoothly
                if (timeSinceShape < 200) {
                    activeAmount = timeSinceShape / 200;
                } else if (timeSinceShape > TIMING.glyphActive - 500) {
                    activeAmount = (TIMING.glyphActive - timeSinceShape) / 500;
                } else {
                    activeAmount = 1;
                }
            }
            
            // Pulse when idle
            if (!isActive && !isDrawing) {
                glyphPulse = Math.sin(now / 1000) * 0.15 + 0.85;
            } else {
                glyphPulse = 1;
            }
            
            // Rotate when shape detected (slow down as it fades)
            if (isActive) {
                glyphRotation += 0.02 * activeAmount;
            }
            
            const corners = [[40, 40], [w - 40, 40], [40, h - 40], [w - 40, h - 40]];
            corners.forEach(([x, y], i) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(glyphRotation * (i % 2 === 0 ? 1 : -1));
                
                // Interpolate between cyan (idle) and gold (active)
                const idleColor = [77, 201, 246];  // cyan
                const activeColor = [212, 175, 55];  // gold
                const r = Math.round(idleColor[0] + (activeColor[0] - idleColor[0]) * activeAmount);
                const g = Math.round(idleColor[1] + (activeColor[1] - idleColor[1]) * activeAmount);
                const b = Math.round(idleColor[2] + (activeColor[2] - idleColor[2]) * activeAmount);
                const a = 0.3 + 0.4 * activeAmount;

                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                ctx.globalAlpha = glyphPulse;
                ctx.lineWidth = 1.5 + 0.5 * activeAmount;

                // Art Nouveau crystalline motif - hexagonal with organic curves
                // Central hexagon
                ctx.beginPath();
                for (let j = 0; j < 6; j++) {
                    const angle = (j / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * 8;
                    const y = Math.sin(angle) * 8;
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();

                // Radiating lines (like spider silk strands)
                ctx.globalAlpha = glyphPulse * 0.6;
                for (let j = 0; j < 6; j++) {
                    const angle = (j / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 8, Math.sin(angle) * 8);
                    ctx.lineTo(Math.cos(angle) * 15, Math.sin(angle) * 15);
                    ctx.stroke();
                }

                // Outer ring with subtle glow (crystallization boundary)
                if (activeAmount > 0.2) {
                    ctx.globalAlpha = glyphPulse * activeAmount;
                    ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    ctx.shadowBlur = 8 + 6 * activeAmount;
                    ctx.beginPath();
                    ctx.arc(0, 0, 12 + 2 * activeAmount, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            });
            ctx.globalAlpha = 1;
        }
        
        function drawRawStrokes() {
            const now = Date.now();
            
            strokes = strokes.filter(stroke => {
                const age = now - stroke.startTime;
                if (age > stroke.fadeStart + TIMING.strokeFade) return false;
                
                let opacity = 1;
                if (age > stroke.fadeStart) {
                    opacity = 1 - ((age - stroke.fadeStart) / TIMING.strokeFade);
                }
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                if (stroke.points.length < 2) return true;
                
                ctx.shadowColor = colors.glow;
                ctx.shadowBlur = 12 * easedOpacity;
                ctx.strokeStyle = `rgba(147, 197, 253, ${0.85 * easedOpacity})`;
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    const p0 = stroke.points[i - 1];
                    const p1 = stroke.points[i];
                    ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                return true;
            });
        }
        
        function drawRecognizedShapes() {
            const now = Date.now();
            
            recognizedShapes = recognizedShapes.filter(shape => {
                const age = now - shape.createdAt;
                if (age > TIMING.shapeTotal) return false;
                
                let opacity = 1;
                if (age > TIMING.shapeHold) {
                    opacity = 1 - ((age - TIMING.shapeHold) / TIMING.shapeFade);
                }
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                const progress = Math.min(1, age / TIMING.morphDuration);
                const morphEase = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                
                // Interpolate between raw and ideal points
                const points = [];
                const idealLen = shape.idealPoints.length;
                const rawLen = shape.rawPoints.length;
                
                for (let i = 0; i < idealLen; i++) {
                    const rawIdx = Math.floor((i / idealLen) * rawLen);
                    const raw = shape.rawPoints[Math.min(rawIdx, rawLen - 1)];
                    const ideal = shape.idealPoints[i];
                    points.push({
                        x: raw.x + (ideal.x - raw.x) * morphEase,
                        y: raw.y + (ideal.y - raw.y) * morphEase
                    });
                }
                
                // Draw shape
                ctx.shadowColor = 'rgba(96, 165, 250, 0.6)';
                ctx.shadowBlur = 20 * easedOpacity;
                ctx.strokeStyle = `rgba(96, 165, 250, ${0.9 * easedOpacity})`;
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Special handling for dots
                if (shape.type === 'dot') {
                    ctx.fillStyle = `rgba(96, 165, 250, ${0.9 * easedOpacity})`;
                    ctx.beginPath();
                    ctx.arc(shape.center.x, shape.center.y, 5 + 2 * morphEase, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    return true;
                }
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                if (shape.type === 'circle' || shape.type === 'rectangle' || shape.type === 'triangle') {
                    ctx.closePath();
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                return true;
            });
        }
        
        function drawGhostSuggestion() {
            if (!isDrawing || !currentStroke || currentStroke.points.length < 10) return;
            
            const shape = detectShape(currentStroke.points);
            if (!shape || shape.confidence < 0.4) return;
            
            const idealPoints = generateIdealShape(shape);
            
            ctx.strokeStyle = colors.ghost;
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(idealPoints[0].x, idealPoints[0].y);
            for (let i = 1; i < idealPoints.length; i++) {
                ctx.lineTo(idealPoints[i].x, idealPoints[i].y);
            }
            if (shape.type === 'circle' || shape.type === 'rectangle' || shape.type === 'triangle') {
                ctx.closePath();
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawWhisperLabels() {
            const now = Date.now();
            
            whisperLabels = whisperLabels.filter(label => {
                const age = now - label.createdAt;
                if (age > TIMING.labelTotal) return false;
                
                let opacity = 1;
                if (age < TIMING.labelFadeIn) {
                    opacity = age / TIMING.labelFadeIn;
                } else if (age > TIMING.labelFadeIn + TIMING.labelHold) {
                    opacity = 1 - ((age - TIMING.labelFadeIn - TIMING.labelHold) / TIMING.labelFade);
                }
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                const yOffset = -20 - (age / 80); // Float upward slightly slower
                
                ctx.font = '500 13px "Raleway", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(147, 197, 253, ${0.8 * easedOpacity})`;
                ctx.fillText(label.text, label.x, label.y + yOffset);
                
                return true;
            });
        }
        
        // Cursor with glow
        let cursorPos = { x: -100, y: -100 };
        let cursorVisible = false;
        
        function drawCursor() {
            if (!cursorVisible) return;
            
            const x = cursorPos.x;
            const y = cursorPos.y;
            const size = isDrawing ? 14 : 10;
            
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
            gradient.addColorStop(0, isDrawing ? 'rgba(251, 146, 60, 0.25)' : 'rgba(59, 130, 246, 0.2)');
            gradient.addColorStop(0.5, isDrawing ? 'rgba(251, 146, 60, 0.08)' : 'rgba(59, 130, 246, 0.05)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, 60, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = isDrawing ? colors.cursor : 'rgba(147, 197, 253, 0.7)';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = isDrawing ? colors.cursor : colors.glow;
            ctx.shadowBlur = 8;
            
            ctx.beginPath();
            ctx.moveTo(x - size, y); ctx.lineTo(x - 4, y);
            ctx.moveTo(x + 4, y); ctx.lineTo(x + size, y);
            ctx.moveTo(x, y - size); ctx.lineTo(x, y - 4);
            ctx.moveTo(x, y + 4); ctx.lineTo(x, y + size);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            if (isDrawing) {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = colors.cursor;
                ctx.fill();
            }
        }
        
        // Draw ripple effects (for tap/dot feedback)
        function drawRipples() {
            const now = Date.now();
            const rippleDuration = 600;
            
            ripples = ripples.filter(ripple => {
                const age = now - ripple.createdAt;
                if (age > rippleDuration) return false;
                
                const progress = age / rippleDuration;
                const eased = 1 - Math.pow(1 - progress, 3); // ease out cubic
                const radius = ripple.maxRadius * eased;
                const opacity = 1 - progress;
                
                ctx.strokeStyle = `rgba(96, 165, 250, ${0.6 * opacity})`;
                ctx.lineWidth = 2 * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Second ring
                if (progress > 0.15) {
                    const innerProgress = (progress - 0.15) / 0.85;
                    const innerRadius = ripple.maxRadius * 0.6 * innerProgress;
                    ctx.strokeStyle = `rgba(147, 197, 253, ${0.4 * (1 - innerProgress)})`;
                    ctx.lineWidth = 1.5 * (1 - innerProgress * 0.5);
                    ctx.beginPath();
                    ctx.arc(ripple.x, ripple.y, innerRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                return true;
            });
        }
        
        // Draw particle burst (for shape recognition feedback)
        function drawParticles() {
            const now = Date.now();
            const particleDuration = 800;
            
            particles = particles.filter(p => {
                const age = now - p.createdAt;
                if (age > particleDuration) return false;
                
                const progress = age / particleDuration;
                const opacity = 1 - progress;
                
                // Update position with slight gravity
                p.x += p.vx;
                p.y += p.vy + progress * 0.5;
                p.vx *= 0.97;
                p.vy *= 0.97;
                
                // Draw crystalline particle - hexagonal shard
                const size = 4 * (1 - progress * 0.5);

                // Gradient from cyan to purple (bioluminescent crystallization)
                const hue = 180 + progress * 100; // cyan to purple transition
                const r = Math.round(0 + progress * 199);
                const g = Math.round(217 - progress * 92);
                const b = 255;

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.createdAt * 0.002); // Subtle rotation based on creation time

                // Hexagonal crystal shard with glow
                ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${0.6 * opacity})`;
                ctx.shadowBlur = 6 * opacity;
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.9 * opacity})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const x = Math.cos(angle) * size;
                    const y = Math.sin(angle) * size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.shadowBlur = 0;

                ctx.restore();
                
                return true;
            });
        }
        
        // Draw ambient floating particles
        function initAmbientParticles() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            for (let i = 0; i < 15; i++) {
                ambientParticles.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    size: 1 + Math.random() * 2,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }
        initAmbientParticles();
        
        function drawAmbientParticles() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            ambientParticles.forEach(p => {
                // Drift movement
                p.x += p.vx;
                p.y += p.vy;
                
                // Wrap around edges
                if (p.x < 0) p.x = w;
                if (p.x > w) p.x = 0;
                if (p.y < 0) p.y = h;
                if (p.y > h) p.y = 0;
                
                // Pulsing opacity
                const pulse = 0.15 + 0.1 * Math.sin(now / 2000 + p.phase);
                
                ctx.fillStyle = `rgba(147, 197, 253, ${pulse})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Animation loop - smart pausing when idle
        let animationFrameId = null;
        let isAnimating = false;

        function hasActiveAnimation() {
            return isDrawing ||
                   particles.length > 0 ||
                   ripples.length > 0 ||
                   strokes.length > 0 ||
                   recognizedShapes.length > 0 ||
                   whisperLabels.length > 0 ||
                   currentStroke !== null;
        }

        function animate() {
            drawGrid();
            drawAmbientParticles();
            drawRawStrokes();
            drawRawIntersections();
            drawRecognizedShapes();
            drawRelationships();
            drawGhostSuggestion();
            drawWhisperLabels();
            drawRipples();
            drawParticles();
            drawCursor();

            // Only continue animation if there's something active
            if (hasActiveAnimation()) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                isAnimating = false;
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (!isAnimating) {
                isAnimating = true;
                animate();
            }
        }

        // Start initial animation
        startAnimation();
        
        // ============================================
        // Event Handlers
        // ============================================
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function startDraw(e) {
            e.preventDefault();
            isDrawing = true;
            hero.classList.add('drawing');
            startAnimation(); // Ensure animation loop is running

            const pos = getPos(e);
            currentStroke = {
                points: [pos],
                startTime: Date.now(),
                fadeStart: TIMING.strokeHold
            };
            strokes.push(currentStroke);
        }
        
        function draw(e) {
            const pos = getPos(e);
            cursorPos = pos;
            cursorVisible = true;
            
            if (!isDrawing || !currentStroke) return;
            e.preventDefault();
            currentStroke.points.push(pos);
        }
        
        function endDraw() {
            // Detect tap/dot (few points, small area)
            if (currentStroke && currentStroke.points.length >= 1 && currentStroke.points.length <= 8) {
                const bounds = getBounds(currentStroke.points);
                const size = Math.max(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
                
                if (size < 25) {
                    // It's a tap/dot!
                    const center = currentStroke.points.length === 1 
                        ? currentStroke.points[0]
                        : { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
                    
                    // Add dot as recognized shape
                    recognizedShapes.push({
                        type: 'dot',
                        center,
                        radius: 6,
                        confidence: 1,
                        rawPoints: [...currentStroke.points],
                        idealPoints: [center],
                        createdAt: Date.now()
                    });
                    
                    // Add whisper label
                    whisperLabels.push({
                        text: 'Point',
                        x: center.x,
                        y: center.y,
                        createdAt: Date.now()
                    });
                    
                    // Add ripple effect
                    ripples.push({
                        x: center.x,
                        y: center.y,
                        createdAt: Date.now(),
                        maxRadius: 40
                    });
                    startAnimation(); // Restart animation for ripple

                    lastShapeTime = Date.now();
                    currentStroke.fadeStart = 0;
                }
            }
            
            if (currentStroke && currentStroke.points.length > 5) {
                const shape = detectShape(currentStroke.points);
                
                if (shape && shape.confidence > 0.5) {
                    // Create recognized shape with ideal points
                    recognizedShapes.push({
                        ...shape,
                        rawPoints: [...currentStroke.points],
                        idealPoints: generateIdealShape(shape),
                        createdAt: Date.now()
                    });
                    
                    // Add whisper label
                    const labelText = shape.type.charAt(0).toUpperCase() + shape.type.slice(1);
                    whisperLabels.push({
                        text: labelText,
                        x: shape.center.x,
                        y: shape.center.y,
                        createdAt: Date.now()
                    });
                    
                    // Add particle burst for recognition feedback
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        particles.push({
                            x: shape.center.x,
                            y: shape.center.y,
                            vx: Math.cos(angle) * (1.5 + Math.random()),
                            vy: Math.sin(angle) * (1.5 + Math.random()),
                            life: 1,
                            createdAt: Date.now()
                        });
                    }
                    startAnimation(); // Restart animation for particles

                    lastShapeTime = Date.now();
                    
                    // Hide raw stroke quickly since we're showing recognized version
                    currentStroke.fadeStart = 0;
                }
            }
            
            isDrawing = false;
            currentStroke = null;
            setTimeout(() => {
                if (!isDrawing) hero.classList.remove('drawing');
            }, 500);
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseleave', () => { endDraw(); cursorVisible = false; });
        canvas.addEventListener('mouseenter', () => { cursorVisible = true; });
        
        canvas.addEventListener('touchstart', startDraw, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', endDraw);
        canvas.addEventListener('touchcancel', endDraw);

        // ============================================
        // Cursor Spotlight Effect
        // ============================================
        const spotlight = document.getElementById('cursorSpotlight');
        let spotlightX = window.innerWidth / 2;
        let spotlightY = window.innerHeight / 2;
        let isSpotlightActive = false;

        function updateSpotlight(x, y) {
            spotlightX = x;
            spotlightY = y;
            const xPercent = (x / window.innerWidth) * 100;
            const yPercent = (y / window.innerHeight) * 100;
            spotlight.style.background = `radial-gradient(600px circle at ${xPercent}% ${yPercent}%, rgba(77, 201, 246, 0.12), rgba(212, 175, 55, 0.06) 40%, transparent 70%)`;
        }

        // Mouse events
        document.addEventListener('mousemove', (e) => {
            if (!isSpotlightActive) {
                spotlight.classList.add('active');
                isSpotlightActive = true;
            }
            updateSpotlight(e.clientX, e.clientY);
        });

        document.addEventListener('mouseleave', () => {
            spotlight.classList.remove('active');
            isSpotlightActive = false;
        });

        // Touch events
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 0) {
                spotlight.classList.add('active');
                isSpotlightActive = true;
                updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            // Keep spotlight visible for a moment after touch ends
            setTimeout(() => {
                if (!isSpotlightActive) {
                    spotlight.classList.remove('active');
                }
            }, 2000);
        });

        // ============================================
        // Demo Canvas - Interactive Fish Animation
        // ============================================
    </script>
</body>
</html>
