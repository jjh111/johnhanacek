<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>John Hanacek - Portfolio</title>
    <meta name="description" content="Innovator, Designer, Creator working at the intersection of Creativity, Curiosity, AI & Human Augmentation">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="./Assets/favicon-jhsigfrmpaper.png">

    <!-- Open Graph / Social Share -->
    <meta property="og:title" content="John Hanacek - Portfolio">
    <meta property="og:description" content="Innovator, Designer, Creator working at the intersection of Creativity, Curiosity, AI & Human Augmentation">
    <meta property="og:image" content="./Assets/socialgraph-jhcom.png">
    <meta property="og:type" content="website">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="John Hanacek - Portfolio">
    <meta name="twitter:description" content="Innovator, Designer, Creator working at the intersection of Creativity, Curiosity, AI & Human Augmentation">
    <meta name="twitter:image" content="./Assets/socialgraph-jhcom.png">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,400;1,9..40,500&family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* ===========================================
           MetaMedium Design System v4
           Warm Palette · Space Grotesk Headings
           WCAG AA Compliant
        =========================================== */
        
        :root {
            /* Earth Star Palette - Bioluminescent Nanotech */
            --void-deep: #020208;
            --void-mid: #0a0d14;
            --void-soft: #12151f;

            --bio-cyan: #00d9ff;
            --bio-purple: #c77dff;
            --bio-green: #7ae582;
            --bio-pink: #ff6ec7;

            --silk-white: #e8f4f8;
            --silk-glow: rgba(0, 217, 255, 0.4);

            /* Legacy compatibility */
            --ink: var(--void-soft);
            --ink-soft: var(--void-mid);
            --paper: var(--void-mid);
            --paper-warm: var(--void-soft);
            --accent: var(--bio-cyan);
            --accent-hover: var(--bio-purple);
            --muted: #8b95a8;
            --muted-light: #a8b2c0;
            --highlight: rgba(199, 125, 255, 0.15);
            --sketch-blue: var(--bio-cyan);
            --sketch-green: var(--bio-green);
            --sketch-purple: var(--bio-purple);
            --border: rgba(0, 217, 255, 0.2);
            --shadow: rgba(0, 217, 255, 0.15);
            --focus: var(--bio-cyan);
            
            --text-xs: 0.8125rem;
            --text-sm: 0.9375rem;
            --text-base: 1.125rem;
            --text-lg: 1.3125rem;
            --text-xl: 1.625rem;
            --text-2xl: 2rem;
            --text-3xl: 2.5rem;
            
            --space-xs: 0.375rem;
            --space-sm: 0.75rem;
            --space-md: 1.25rem;
            --space-lg: 2rem;
            --space-xl: 3rem;
            --space-2xl: 4.5rem;
        }
        
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        
        html { scroll-behavior: smooth; font-size: 100%; }
        
        @media (prefers-reduced-motion: reduce) {
            html { scroll-behavior: auto; }
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        body {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: var(--text-base);
            font-weight: 450;
            line-height: 1.7;
            color: #ffffff;
            background: linear-gradient(180deg, var(--void-deep) 0%, var(--void-mid) 100%);
            -webkit-font-smoothing: antialiased;
            position: relative;
        }

        /* Interactive Cursor Spotlight */
        #cursorSpotlight {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            background: radial-gradient(600px circle at 50% 50%, rgba(0, 217, 255, 0.15), rgba(199, 125, 255, 0.1) 40%, transparent 70%);
        }

        #cursorSpotlight.active {
            opacity: 1;
        }

        .skip-link {
            position: absolute;
            top: -100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--ink);
            color: var(--paper);
            padding: var(--space-sm) var(--space-md);
            border-radius: 0 0 8px 8px;
            font-weight: 600;
            z-index: 9999;
        }
        .skip-link:focus { top: 0; }
        
        :focus-visible { outline: 3px solid var(--focus); outline-offset: 3px; }
        
        /* Hero - Blueprint Canvas (Dark/Inverted) */
        .hero {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            text-align: center;
            padding: clamp(5rem, 10vh, 8rem) var(--space-sm) 0;
            position: relative;
            overflow: hidden;
            background: radial-gradient(ellipse at center, var(--void-mid) 0%, var(--void-deep) 100%);
        }
        
        /* Gradient transition to content - simple fade */
        .hero::after {
            content: '';
            position: absolute;
            bottom: 0; left: 0; right: 0;
            height: 60px;
            background: linear-gradient(to bottom, transparent 0%, var(--void-mid) 100%);
            z-index: 3;
            pointer-events: none;
        }
        
        #heroCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            cursor: crosshair;
        }
        
        .hero-hint {
            position: absolute;
            bottom: 9rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'DM Sans', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            color: rgba(147, 197, 253, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .hero-hint .hint-icon {
            font-size: 0.9rem;
            animation: pencil-wiggle 2s ease-in-out infinite;
        }
        @keyframes pencil-wiggle {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }
        .hero.drawing .hero-hint { opacity: 0; }
        
        .hero-content {
            position: relative;
            z-index: 2;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }

        .hero-content * {
            pointer-events: none;
        }
        
        .sr-only {
            position: absolute;
            width: 1px; height: 1px;
            padding: 0; margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .hero h1 {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            font-size: clamp(3rem, 10vw, 5.5rem);
            font-weight: 700;
            letter-spacing: 0.02em;
            line-height: 1;
            margin-bottom: var(--space-sm);
            color: #ffffff;
            text-shadow: 0 0 60px rgba(0, 217, 255, 0.8), 0 4px 20px rgba(0, 0, 0, 0.9), 0 2px 4px rgba(0, 0, 0, 1);
        }

        .hero h1 .meta {
            background: linear-gradient(135deg, var(--bio-cyan) 0%, var(--bio-purple) 50%, var(--bio-green) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            filter: drop-shadow(0 0 30px var(--bio-purple));
            animation: shimmer 8s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% {
                filter: drop-shadow(0 0 30px var(--bio-cyan));
                opacity: 0.95;
            }
            50% {
                filter: drop-shadow(0 0 40px var(--bio-purple));
                opacity: 1;
            }
        }
        
        .hero .tagline {
            font-family: 'DM Sans', sans-serif;
            font-size: var(--text-base);
            font-weight: 500;
            color: #00d9ff;
            letter-spacing: 0.48em;
            text-transform: uppercase;
            margin-bottom: var(--space-sm);
            text-shadow: 0 0 30px rgba(0, 217, 255, 0.9), 0 2px 8px rgba(0, 0, 0, 0.8);
        }

        .hero .subtitle {
            font-family: 'DM Serif Display', Georgia, serif;
            font-size: clamp(1.1rem, 2.2vw, 1.4rem);
            font-weight: 400;
            font-style: italic;
            color: rgba(255, 255, 255, 0.95);
            max-width: 550px;
            margin: 0 auto var(--space-sm);
            line-height: 1.4;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9), 0 1px 2px rgba(0, 0, 0, 1);
        }
        
        .hero .byline {
            font-size: var(--text-sm);
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
        }
        .hero .byline .role {
            color: rgba(255, 255, 255, 0.75);
            font-weight: 400;
            margin-left: 0.25em;
        }
        
        .scroll-indicator {
            position: absolute;
            bottom: 10.5rem;
            z-index: 4;
            animation: bounce 2s infinite;
            cursor: pointer;
            text-decoration: none;
            display: block;
        }
        .scroll-indicator svg { 
            width: 35px; 
            height: 35px; 
            stroke-width: 2.5;
            animation: strokeGlow 0.8s ease-in-out infinite alternate;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-8px); }
            60% { transform: translateY(-4px); }
        }
        
        @keyframes strokeGlow {
            0% { stroke: rgba(147, 197, 253, 0.3); }
            100% { stroke: rgba(147, 197, 253, 0.9); }
        }

        .hero-sig-inline {
            height: 2.5em;
            opacity: 0.5;
            margin-top: var(--space-sm);
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.8));
        }

        /* Navigation - Slim with left title */
        nav {
            position: fixed;
            top: 0; left: 0; right: 0;
            background: rgba(2, 2, 8, 0.85);
            backdrop-filter: blur(20px);
            z-index: 1000;
            border-bottom: 1px solid rgba(0, 217, 255, 0.25);
            box-shadow: 0 4px 30px rgba(0, 217, 255, 0.1);
            transform: translateY(-100%);
            transition: transform 0.25s ease;
            height: 40px;
        }
        nav.visible { transform: translateY(0); }
        
        .nav-inner {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1100px;
            margin: 0 auto;
            padding: 0 var(--space-md);
            height: 100%;
        }
        
        .nav-title {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.95);
            text-decoration: none;
            letter-spacing: -0.02em;
            line-height: 1;
        }
        .nav-title:hover { color: var(--accent); }
        
        /* Mobile nav toggle */
        .nav-toggle {
            display: none;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            margin-right: -0.5rem;
        }
        .nav-toggle span {
            display: block;
            width: 20px;
            height: 2px;
            background: rgba(255, 255, 255, 0.95);
            margin: 4px 0;
            transition: transform 0.2s, opacity 0.2s;
        }
        .nav-toggle.active span:nth-child(1) { transform: rotate(45deg) translate(4px, 4px); }
        .nav-toggle.active span:nth-child(2) { opacity: 0; }
        .nav-toggle.active span:nth-child(3) { transform: rotate(-45deg) translate(4px, -4px); }
        
        nav ul {
            display: flex;
            align-items: center;
            gap: 0;
            list-style: none;
            margin: 0;
            padding: 0;
            height: 100%;
        }
        
        nav li {
            display: flex;
            align-items: center;
            height: 100%;
            margin: 0;
        }
        
        nav a {
            font-family: 'DM Sans', sans-serif;
            font-size: 0.6875rem;
            font-weight: 600;
            text-decoration: none;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.06em;
            padding: 0 0.625rem;
            display: flex;
            align-items: center;
            height: 100%;
            transition: color 0.2s;
        }
        nav ul a:hover, nav ul a:focus { color: var(--accent); }

        /* Nav page tabs and separators */
        .nav-tab { font-weight: 700; }
        .nav-page { color: var(--accent); font-weight: 700; }
        .nav-separator {
            color: rgba(255, 255, 255, 0.25);
            font-size: 0.75rem;
            padding: 0 0.5rem;
            pointer-events: none;
        }

        /* Shape Navigation */
        .shape-nav {
            position: absolute;
            top: 1.5rem;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            z-index: 5;
            display: flex;
            width: fit-content;
            gap: 1.5rem;
            align-items: flex-start;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem 0.75rem;
            border-radius: 2rem;
            /*border: 1px solid rgba(0, 217, 255, 0.15);*/
        }
        .shape-link {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            opacity: 0.4;
            transition: opacity 0.3s;
            text-decoration: none;
        }
        .shape-link:hover {
            opacity: 0.8;
        }
        .shape-link.active {
            opacity: 1;
        }
        .shape-link .shape {
            width: 28px;
            height: 28px;
            fill: none;
            stroke: var(--bio-cyan, #00d9ff);
            stroke-width: 2;
            transition: width 0.2s, height 0.2s;
        }
        .shape-link.active .shape {
            fill: rgba(0, 217, 255, 0.15);
            filter: drop-shadow(0 0 8px rgba(0, 217, 255, 0.6));
        }
        .shape-label {
            font-family: 'DM Sans', sans-serif;
            font-size: 0.5rem;
            font-weight: 700;
            color: var(--bio-cyan, #00d9ff);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            line-height: 1;
            white-space: nowrap;
            max-height: 0;
            opacity: 0;
            overflow: visible;
            transition: max-height 0.2s, opacity 0.2s;
        }
        .shape-label-img {
            height: auto;
            max-height: 0;
            width: auto;
            filter: brightness(1.2);
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.2s, opacity 0.2s;
        }
        .shape-nav:hover .shape {
            width: 36px;
            height: 36px;
        }
        .shape-nav:hover .shape-label {
            max-height: 1.5rem;
            opacity: 1;
        }
        .shape-nav:hover .shape-label-img {
            max-height: 0.9rem;
            opacity: 1;
        }

        /* Mobile nav styles */
        @media (max-width: 900px) {
            .nav-toggle {
                display: block;
                position: relative;
                z-index: 1001;
            }

            nav ul {
                position: absolute;
                top: 10px;
                left: 0;
                right: 0;
                background: rgba(26, 26, 46, 0.98);
                backdrop-filter: blur(12px);
                flex-direction: column;
                align-items: stretch;
                height: auto;
                padding: var(--space-md) 0;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                display: none;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            }
            
            nav ul.open { display: flex; }
            
            nav li {
                height: auto;
            }
            
            nav ul a {
                padding: .5rem var(--space-sm);
                height: auto;
                font-size: 1rem;
                font-weight: 800;
                letter-spacing: 0.02em;
                text-transform: none;
                color: rgba(255, 255, 255, 0.9);
            }

            nav ul a:hover, nav ul a:focus {
                color: var(--accent);
            }
        }
        
        /* Main Content */
        main {
            max-width: 760px;
            margin: 0 auto;
            padding: var(--space-lg) var(--space-lg) var(--space-xl);
            position: relative;
            z-index: 1;
        }
        
        /* Overview/Abstract section */
        #abstract {
            scroll-margin-top: 0;
        }
        
        section {
            margin-bottom: var(--space-xl);
            scroll-margin-top: 4rem;
        }
        
        h2 {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            font-size: clamp(1.875rem, 4vw, var(--text-3xl));
            font-weight: 600;
            margin-bottom: var(--space-md);
            letter-spacing: 0.06em;
            line-height: 1.2;
            position: relative;
            padding-left: 1.25rem;
            color: #ffffff;
            text-shadow: 0 0 40px rgba(0, 217, 255, 0.7), 0 2px 8px rgba(0, 0, 0, 0.8);
            cursor: default;
        }

        h2::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: linear-gradient(180deg, var(--bio-cyan), var(--bio-purple));
            border-radius: 2px;
            box-shadow: 0 0 15px var(--silk-glow);
        }
        
        h3 {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            font-size: var(--text-xl);
            font-weight: 500;
            margin: var(--space-md) 0 var(--space-sm);
            line-height: 1.25;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
            cursor: default;
        }

        h4 {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            font-size: var(--text-lg);
            font-weight: 600;
            margin: var(--space-md) 0 var(--space-xs);
            letter-spacing: -0.01em;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
            cursor: default;
        }

        p {
            margin-bottom: var(--space-md);
            max-width: 65ch;
            color: rgba(255, 255, 255, 0.92);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            cursor: default;
        }

        strong {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.98);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
        }
        em {
            font-style: italic;
            color: rgba(255, 255, 255, 0.9);
        }
        
        a {
            color: var(--bio-cyan);
            text-decoration: underline;
            text-underline-offset: 3px;
            text-decoration-thickness: 1px;
            text-decoration-color: rgba(0, 217, 255, 0.4);
            transition: all 0.3s ease;
            position: relative;
        }

        a:hover {
            color: var(--bio-purple);
            text-decoration-color: var(--bio-purple);
            text-shadow: 0 0 15px var(--silk-glow);
            animation: biolume 2s ease-in-out infinite;
        }

        @keyframes biolume {
            0%, 100% {
                opacity: 0.95;
                text-shadow: 0 0 10px var(--silk-glow);
            }
            50% {
                opacity: 1;
                text-shadow: 0 0 20px var(--silk-glow), 0 0 30px var(--bio-purple);
            }
        }

        /* External link icon */
        a[target="_blank"]::after {
            content: "↗";
            display: inline-block;
            font-size: 0.55em;
            margin-left: 0.25em;
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        a[target="_blank"]:hover::after {
            opacity: 1;
        }

        /* Core Content Card - Standardized glass-morphism style */
        .content-card {
            font-family: 'DM Sans', sans-serif;
            background: rgba(199, 125, 255, 0.05);
            backdrop-filter: blur(16px) saturate(1.5);
            -webkit-backdrop-filter: blur(16px) saturate(1.5);
            border-radius: 12px;
            border: 1px solid transparent;
            box-shadow: 0 2px 10px rgba(199, 125, 255, 0.05);
            padding: var(--space-lg);
            margin: var(--space-lg) 0;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* Clickable variant - adds stripe and hover effects */
        .content-card.clickable {
            cursor: pointer;
        }

        .content-card.clickable::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 4px; height: 100%;
            background: linear-gradient(180deg, var(--sketch-blue), var(--sketch-green));
        }

        .content-card.clickable:hover {
            background: rgba(199, 125, 255, 0.18);
            box-shadow: 0 8px 32px rgba(199, 125, 255, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 12px 48px rgba(0, 0, 0, 0.4);
            transform: translateY(-2px);
            border: 1px solid rgba(199, 125, 255, 0.4);
        }

        /* Endorsement-specific styles (replace blockquote) */
        .content-card.endorsement {
            font-size: 1.3rem;
            font-weight: 400;
            font-style: italic;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.95);
            padding: var(--space-md) var(--space-xl) var(--space-md) var(--space-lg);
        }

        .content-card.endorsement cite {
            display: block;
            font-family: 'DM Sans', sans-serif;
            font-style: normal;
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--muted-light);
            margin-top: var(--space-sm);
        }
        .content-card.endorsement cite em { font-style: italic; }

        /* Remove hover effects on endorsement links */
        .content-card.endorsement a:hover {
            animation: none;
            text-shadow: none;
        }

        /* Typography inside cards */
        .content-card h4 {
            margin-top: 0;
            font-family: 'Space Grotesk', sans-serif;
            font-size: var(--text-lg);
            font-weight: 600;
            color: rgba(255, 255, 255, 0.95);
        }
        .content-card p {
            font-size: var(--text-base);
            line-height: 1.65;
            color: rgba(255, 255, 255, 0.9);
        }
        .content-card p:last-child { margin-bottom: 0; }

        /* Data number watermark (for education, achievements, etc.) */
        .content-card::before {
            content: attr(data-num);
            position: absolute;
            top: 15px;
            right: 15px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 5rem;
            font-weight: 700;
            color: rgba(26, 26, 46, 0.04);
            line-height: 1;
            pointer-events: none;
        }

        /* About section - larger text variant */
        .content-card.about p {
            font-size: clamp(1.5rem, 3vw, 2rem);
            font-style: italic;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.95);
            font-weight: 400;
        }
        .content-card.about strong {
            color: var(--bio-cyan);
            font-weight: 600;
        }
        
        ul, ol {
            margin-bottom: var(--space-md);
            padding-left: var(--space-md);
        }
        
        li {
            margin-bottom: var(--space-xs);
            line-height: 1.65;
            color: rgba(255, 255, 255, 0.92);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            cursor: default;
        }

        /* Figures */
        /*figure { margin: var(--space-lg) 0; }
        */
    figure {
            margin: 3rem 0;
            background: #fff;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }
        
        /* Two-column figures */
           .figure-pair {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 1.5rem 0;
        }

        .figure-pair figure {
            padding: var(--space-xs) 0;
        }

        @media (max-width: 768px) {
            .figure-pair {
                grid-template-columns: 1fr;
            }
        }

        .placeholder-figure {
            background: linear-gradient(135deg, var(--paper-warm) 0%, #fff 100%);
            border: 2px dashed var(--border);
            border-radius: 10px;
            padding: var(--space-md);
            text-align: left;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: left;
            min-height: 220px;
        }

        .placeholder-figure .icon { font-size: 3rem; margin-bottom: var(--space-sm); opacity: 0.5; }
        .placeholder-figure .label {
            font-family: 'DM Sans', sans-serif;
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: var(--space-xs);
            width: 100%;
        }
        .placeholder-figure .description {
            font-size: var(--text-base);
            color: var(--muted);
            line-height: 1.5;
            width: 100%;
        }

        .placeholder-figure .image {
            width: 100%;
            margin-bottom: var(--space-md);
        }

        .placeholder-figure .image svg,
        .placeholder-figure .image img {
            width: 100%;
            height: auto;
            display: block;
        }

        figure img {
            width: 100%;
            display: block;
        }
        
        figure.sketch-figure {
            background: #fafafa;
            border: 2px dashed var(--border);
        }
        
        figcaption {
            padding: 1rem 1.5rem;
            font-size: 0.95rem;
            color: var(--muted);
            border-top: 1px solid var(--border);
            font-style: italic;
        }
        
        figcaption strong {
            color: var(--ink);
            font-style: normal;
        }
        /*
        figcaption {
            font-size: var(--text-sm);
            color: var(--muted);
            margin-top: var(--space-sm);
            line-height: 1.6;
        }
        figcaption strong { color: var(--ink); }
        *?
        /* Video Embed */
        .video-embed {
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            overflow: hidden;
            margin: var(--space-md) 0;
            border-radius: 10px;
            box-shadow: 0 3px 20px var(--shadow);
        }
        .video-embed iframe {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border: none;
        }
        
        /* Demo Container */
        .demo-container {
            margin: var(--space-lg) 0;
            border: 2px solid var(--sketch-blue);
            border-radius: 12px;
            overflow: hidden;
            background: #fff;
        }
        .demo-header {
            background: linear-gradient(135deg, var(--sketch-blue), var(--sketch-green));
            color: white;
            padding: var(--space-sm) var(--space-md);
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .demo-header span {
            font-size: var(--text-sm);
            opacity: 0.9;
            font-weight: 400;
        }
        .demo-container iframe {
            width: 100%;
            height: 640px;
            border: none;
            display: block;
        }
        
        /* Callout */
        .callout {
            background: rgba(10, 13, 20, 0.3);
            backdrop-filter: blur(16px) saturate(1.5);
            -webkit-backdrop-filter: blur(16px) saturate(1.5);
            border-radius: 10px;
            padding: var(--space-md);
            margin: var(--space-md) 0;
            border: 1px solid transparent;
            box-shadow: 0 2px 10px rgba(0, 217, 255, 0.05);
            position: relative;
            cursor: default;
        }

        .callout:hover {
            background: rgba(10, 13, 20, 0.7);
            box-shadow: 0 8px 32px rgba(0, 217, 255, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.15), 0 12px 48px rgba(0, 0, 0, 0.4);
            transform: translateY(-2px);
            border: 1px solid rgba(0, 217, 255, 0.5);
        }

        .callout.insight { border-left-color: var(--sketch-purple); }
        .callout.key { border-left-color: var(--accent); }
        .callout h4 {
            margin-top: 0;
            font-size: var(--text-base);
        }
        .callout p {
            font-size: var(--text-base);
            line-height: 1.65;
        }
        .callout p:last-child { margin-bottom: 0; }
        
        /* Genealogy */
        .genealogy-item {
            display: grid;
            grid-template-columns: 70px 1fr;
            gap: var(--space-md);
            margin: var(--space-lg) 0;
            padding: 0;
            align-items: start;
        }
        .genealogy-item .year {
            font-family: 'Space Grotesk', sans-serif;
            font-size: var(--text-base);
            font-weight: 600;
            color: var(--accent);
            line-height: 1.4;
            padding-top: 2px;
        }
        .genealogy-item .content h4 { margin-top: 0; font-size: var(--text-lg); line-height: 1.25; }
        .genealogy-item .content p { font-size: var(--text-base); line-height: 1.65; }
        .genealogy-item .content p:last-of-type { margin-bottom: 0; }
        
        /* Media placeholder for timeline */
        .media-placeholder {
            margin-top: var(--space-sm);
            border-radius: 8px;
            overflow: hidden;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(139, 92, 246, 0.08) 100%);
            border: 1px dashed rgba(59, 130, 246, 0.3);
            position: relative;
        }
        .media-placeholder.video {
            aspect-ratio: 16/9;
        }
        .media-placeholder.image {
            aspect-ratio: 4/3;
        }
        .media-placeholder-inner {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--muted-light);
            font-size: var(--text-sm);
            gap: var(--space-xs);
        }
        .media-placeholder-inner .icon {
            font-size: 1.5rem;
            opacity: 0.6;
        }
        .media-placeholder-inner .label {
            font-weight: 500;
            opacity: 0.8;
        }
        .media-placeholder-inner .caption {
            font-size: var(--text-xs);
            opacity: 0.6;
            text-align: center;
            max-width: 80%;
        }
        
        /* Embedded video in timeline */
        .timeline-video {
            margin-top: var(--space-sm);
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
            background: #000;
        }
        .timeline-video iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        /* Embedded image in timeline */
        .timeline-image {
            margin-top: var(--space-sm);
            border-radius: 8px;
            overflow: hidden;
        }
        .timeline-image img {
            width: 100%;
            height: auto;
            display: block;
        }
        
        /* Gallery grid */
        .gallery {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-xs);
            margin: var(--space-xs) 0;
        }
        .gallery-item {
            background: rgba(74, 85, 104, 0.08);
            border: 1px solid rgba(107, 114, 128, 0.4);
            border-radius: 4px;
            padding: var(--space-xs) var(--space-xs);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin: 0;  /* Override default figure margin */
        }
        .gallery-item .image {
            width: 100%;
            aspect-ratio: 16 / 10;
            margin-bottom: var(--space-xs);
            background: rgba(10, 14, 26, 0.9);
            border-radius: 2px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .gallery-item .image:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            background: rgba(10, 14, 26, 1);
        }
        .gallery-item .image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }
        .gallery-item figcaption {
            font-size: var(--text-sm);
            color: rgba(51, 51, 51, 0.9);
            line-height: 1.4;
            width: 100%;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .gallery {
                grid-template-columns: repeat(2, 1fr);
                gap: var(--space-sm);
            }
            .gallery-item .image {
                aspect-ratio: 4 / 3;  /* Taller ratio for smaller screens */
            }
        }
        @media (max-width: 480px) {
            .gallery {
                grid-template-columns: 1fr;
            }
            .gallery-item .image {
                aspect-ratio: 16 / 10;  /* Back to wider for full-width */
            }
        }
        
        /* Card grid layout */
        .card-grid {
            display: grid;
            gap: var(--space-xs);
            margin: var(--space-md) 0;
        }

        /* Tighter spacing for cards in grid */
        .card-grid .content-card {
            margin: 0;
        }

        /* Card link wrapper */
        .card-link {
            text-decoration: none;
            color: inherit;
            display: block;
        }
        
        /* Practice use cases - principles label */
        .principles-used {
            font-size: var(--text-xs);
            color: var(--sketch-blue);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: var(--space-xs);
        }
        .principles-used strong {
            color: var(--ink-muted);
            font-weight: 500;
        }
        
        /* Video fallback links */
        .video-link {
            font-size: var(--text-sm);
            color: var(--ink-muted);
            margin-top: var(--space-xs);
        }
        .video-link a {
            color: var(--accent);
        }
        
        /* Footer */
        footer {
            background: var(--void-deep);
            color: var(--silk-white);
            text-align: center;
            padding: var(--space-xl) var(--space-md);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-top: 1px solid rgba(0, 217, 255, 0.2);
            box-shadow: 0 -4px 30px rgba(0, 217, 255, 0.1);
        }
        .footer-title {
            font-family: 'Space Grotesk', -apple-system, sans-serif;
            font-size: var(--text-lg);
            font-weight: 600;
            margin-bottom: var(--space-xs);
        }
        .footer-subtitle {
            font-size: var(--text-sm);
            opacity: 0.65;
            margin-bottom: var(--space-md);
        }
        .footer-copyright {
            font-size: var(--text-sm);
            opacity: 0.8;
            margin-bottom: var(--space-xs);
        }
        footer a { 
            color: #fff; 
            opacity: 0.8;
            text-decoration: underline;
            text-underline-offset: 2px;
        }
        footer a:hover { opacity: 1; }
        footer .version {
            font-family: 'DM Sans', sans-serif;
            font-size: var(--text-xs);
            font-weight: 500;
            opacity: 0.45;
            margin-top: var(--space-sm);
            letter-spacing: 0.05em;
        }

        /* Demo Canvas - Fish Animation */
        .demo-wrapper {
            margin: var(--space-lg) 0 var(--space-md);
        }

        .demo-prompt {
            text-align: center;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            color: var(--ink);
            font-weight: 500;
            min-height: 2rem;
        }

        .demo-prompt .highlight {
            color: #e63946;
            font-weight: 600;
        }

        .demo-canvas-container {
            position: relative;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }

        #demoCanvas {
            display: block;
            width: 100%;
            aspect-ratio: 4/3;
            cursor: crosshair;
            touch-action: none;
        }

        #demoCanvas.grabbing {
            cursor: grabbing;
        }

        .demo-labels {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .demo-label {
            position: absolute;
            font-size: 0.75rem;
            font-weight: 600;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transform: translate(-50%, -100%);
            margin-top: -8px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .demo-label.visible {
            opacity: 1;
        }

        .demo-label.fish {
            background: rgba(59, 130, 246, 0.9);
            color: white;
        }

        .demo-label.food {
            background: rgba(74, 222, 128, 0.9);
            color: #1a1a2e;
        }

        .demo-controls {
            display: flex;
            justify-content: center;
            margin-top: 1rem;
            gap: 0.75rem;
        }

        .demo-reset-btn {
            font-family: inherit;
            font-size: 0.875rem;
            font-weight: 500;
            padding: 0.625rem 1.25rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #1a1a2e;
            color: white;
            opacity: 0;
            pointer-events: none;
        }

        .demo-reset-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .demo-reset-btn:hover {
            background: #2d2d4a;
        }

        .demo-status {
            text-align: center;
            margin-top: 0.75rem;
            font-size: 0.8125rem;
            color: #666;
            min-height: 1.25rem;
        }

        /* Image Modal / Lightbox */
        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .image-modal.active {
            display: flex;
            opacity: 1;
        }

        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 20, 0.92);
            cursor: pointer;
        }

        .modal-content {
            position: relative;
            z-index: 10001;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .modal-image-container {
            width: 90vw;
            height: 80vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-image-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 4px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            line-height: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .modal-prev,
        .modal-next {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            line-height: 1;
            padding: 0;
            padding-bottom: 2px;
            font-family: Arial, sans-serif;
        }

        .modal-prev:hover:not(:disabled),
        .modal-next:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .modal-prev:disabled,
        .modal-next:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        #modalCaption {
            color: white;
            text-align: center;
            margin-top: 1rem;
            font-size: 0.9375rem;
            max-width: 80vw;
            line-height: 1.5;
        }

        .modal-controls {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            width: 90vw;
            margin-top: 0.75rem;
        }

        .modal-nav-group {
            grid-column: 2;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .modal-close {
            grid-column: 3;
            justify-self: end;
        }

        .modal-counter {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.875rem;
            font-family: 'JetBrains Mono', monospace;
            min-width: 60px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .modal-image-container {
                width: 95vw;
                height: 70vh;
            }

            .modal-controls {
                width: 95vw;
            }

            .modal-nav-group {
                gap: 0.75rem;
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            :root { 
                --text-base: 1.0625rem;
                --space-lg: 1.5rem;
                --space-xl: 2.25rem;
                --space-2xl: 3rem;
            }
            main { padding: var(--space-md) var(--space-md) var(--space-xl); }

            nav { height: 36px; }
            .nav-inner { padding: 0 var(--space-sm); }
            .nav-title { font-size: 0.9375rem; }

            .genealogy-item { grid-template-columns: 1fr; gap: var(--space-xs); }
            .genealogy-item .year { margin-bottom: var(--space-xs); }
            
            .media-placeholder.video { aspect-ratio: 16/9; }
            .media-placeholder.image { aspect-ratio: 3/2; }
            .timeline-video { aspect-ratio: 16/9; }
            blockquote { padding-left: var(--space-sm); }
            .hero { padding-top: 4rem; padding-left: var(--space-md); padding-right: var(--space-md); }
            .hero-hint { bottom: 7rem; }
        }
        
        @media (max-width: 480px) {
            nav { height: 34px; }
            .nav-title { font-size: 0.875rem; }
            .hero h1 { font-size: clamp(2.5rem, 14vw, 4rem); }
        }
        
        @media (min-width: 1200px) { main { max-width: 800px; } }
        
        @media print {
            body { font-size: 11pt; line-height: 1.5; }
            nav, .scroll-indicator, #heroCanvas, .hero-hint, .demo-wrapper { display: none; }
            .hero { min-height: auto; padding: 1.5rem 0; background: none; }
            .hero::after { display: none; }
            .hero h1, .hero .subtitle, .hero .tagline, .hero .byline { color: var(--ink); }
            .hero h1 .meta { -webkit-text-fill-color: var(--accent); }
        }
    </style>
</head>
<body>
    <!-- Interactive Cursor Spotlight -->
    <div id="cursorSpotlight"></div>

    <a href="#about" class="skip-link">Skip to main content</a>

    <nav id="nav" role="navigation" aria-label="Main navigation">
        <div class="nav-inner">
            <a href="index.html" class="nav-title">John Hanacek</a>
            <button class="nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul>
                <li><a href="index.html" class="nav-page">Home</a></li>
                <li><a href="design.html" class="nav-tab">Design</a></li>
                <li><a href="art.html" class="nav-tab">Art</a></li>
                <li class="nav-separator">|</li>
                <li><a href="#about">About</a></li>
                <li><a href="#believe">I Believe</a></li>
                <li><a href="#highlights">Highlights</a></li>
                <li><a href="#endorsements">Endorsements</a></li>
                <li><a href="#explore">Explore</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </div>
    </nav>

    <header class="hero" id="top">
        <!-- Shape Navigation -->
        <nav class="shape-nav" aria-label="Page navigation">
            <a href="index.html" class="shape-link active" aria-label="Home" aria-current="page">
                <svg class="shape triangle" viewBox="0 0 40 40"><polygon points="20,8 34,32 6,32"/></svg>
                <img class="shape-label shape-label-img" src="./Assets/footer-JHsig.png" alt="JH">
            </a>
            <a href="design.html" class="shape-link" aria-label="Design">
                <svg class="shape rounded-square" viewBox="0 0 40 40"><rect x="6" y="6" width="28" height="28" rx="6"/></svg>
                <span class="shape-label">DESIGN</span>
            </a>
            <a href="art.html" class="shape-link" aria-label="Art">
                <svg class="shape circle" viewBox="0 0 40 40"><circle cx="20" cy="20" r="14"/></svg>
                <span class="shape-label">ART</span>
            </a>
        </nav>

        <!-- Interactive Blueprint Canvas -->
        <canvas id="heroCanvas"></canvas>
        <div class="hero-hint">
            <span class="hint-icon">✎</span>
            <span class="hint-text">draw here</span>
        </div>
        
        <div class="hero-content">
            <h1>John <span class="meta">Hanacek</span></h1>
            <p class="tagline">INNOVATOR · DESIGNER · CREATOR</p>
            <p class="byline"> <span class="role">Sounds like · (Hana-check)</span></p>
            <img class="hero-sig-inline" src="./Assets/footer-JHsig.png" alt="John Hanacek signature">
        </div>
        <a href="#about" class="scroll-indicator" aria-label="Scroll to content">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                <path d="M7 13l5 5 5-5M7 6l5 5 5-5"/>
            </svg>
        </a>
    </header>

    <main>
        <!-- ABOUT -->
        <section id="about">
            <h2>About</h2>

            <div class="content-card about">
                <p>At the intersection of <strong>Creativity</strong>, <strong>Curiosity</strong> & <strong>Technology</strong> for <strong>Human Augmentation</strong>.</p>
            </div>
        </section>

        <!-- I BELIEVE -->
        <section id="believe">
            <h2>I Believe</h2>

            <div class="content-card">
                <p>Imagination is within reality.</p>
                <p>Infinite Games are more powerful than Finite Games.</p>
                <p>Technology can augment human intelligence & collaboration.</p>
                <p>Optimism and pessimism are self-fulfilling prophecies.</p>
                <p>We can choose better prophecies...</p>
            </div>
        </section>

        <!-- HIGHLIGHTS -->
        <section id="highlights">
            <h2>Highlights</h2>

            <div class="card-grid">
                <div class="content-card" data-num="01">
                    <h4>Georgetown MA 2016</h4>
                    <p>Awarded <strong>"Most Meta"</strong> by peers in Communication, Culture & Technology</p>
                </div>

                <div class="content-card" data-num="02">
                    <h4>Founder Institute 2020</h4>
                    <p>Graduate as CEO of <strong><a href="https://www.avatarmedic.com" target="_blank" rel="noopener">AvatarMEDIC</a></strong></p>
                </div>

                <div class="content-card" data-num="03">
                    <h4>Aerospace Medical Assn 2022</h4>
                    <p><strong>R&D Innovation Award</strong> for XR Digital Twin robotics control</p>
                </div>
            </div>
        </section>

        <!-- HIDE FOR NOW METAMEDIUM EMBEDDED 
        <section id="metamedium">
            <h2>MetaMedium: AI Beyond Chat</h2>

            <p>A Framework for Diagrammatic Human-AI Communication</p>

            <div class="demo-container">
                <div class="demo-header">
                    <span>Interactive Whitepaper</span>
                    <span>Scroll to explore →</span>
                </div>
                <iframe src="https://jjh111.github.io/MetaMedium/MetaMedium_Whitepaper_v4.html" title="MetaMedium Whitepaper" allowfullscreen></iframe>
            </div>
        </section>
        -->

        <!-- ENDORSEMENTS -->
        <section id="endorsements">
            <h2>Featured Endorsements</h2>

            <div class="content-card endorsement">
                <p>"My choice for the most plausible vision of a future I desire goes to John Hanacek's scenario. I think I'd like to live there, and I think it is plausible in 100 years. My $100 goes to him."</p>
                <cite><strong><a href="https://kk.org/thetechnium/a-desirable-future-haiku/" target="_blank" rel="noopener">Kevin Kelly</a></strong>, Futurist, Founder of Wired Magazine</cite>
            </div>

            <div class="content-card endorsement">
                <p>"Talented and very experienced designer!"</p>
                <cite><strong><a href="https://www.linkedin.com/in/ipetryaevskaya/" target="_blank" rel="noopener">Inga Petryaevskaya</a></strong>, CEO <a href="https://www.shapesxr.com" target="_blank" rel="noopener">ShapesXR</a></cite>
            </div>
        </section>

        <!-- EXPLORE -->
        <section id="explore">
            <h2>Explore</h2>

            <div class="card-grid">
                <div class="content-card" data-num="01">
                    <h4><a href="design.html">Design Portfolio</a></h4>
                    <p>Professional work, case studies, and XR projects</p>
                </div>

                <div class="content-card" data-num="02">
                    <h4><a href="art.html">Art & Creative</a></h4>
                    <p>Visual art, photography, and creative experiments</p>
                </div>
            </div>
        </section>

        <!-- CONTACT -->
        <section id="contact">
            <h2>Contact</h2>

            <div class="content-card">
                <h4>Email</h4>
                
                <p><a href="mailto:hi@johnhanacek.com">hi@johnhanacek.com</a></p>

                <h4>Social</h4>
                <ul>
                    <li><a href="https://bsky.app/profile/johnhanacek.bsky.social" target="_blank" rel="noopener">Bluesky</a></li>
                    <li><a href="https://x.com/johnhanacek" target="_blank" rel="noopener">X (Twitter)</a></li>
                    <li><a href="https://www.linkedin.com/in/johnhanacek/" target="_blank" rel="noopener">LinkedIn</a></li>
                </ul>
            </div>
        </section>

    </main>

    <footer>
        <p class="footer-title">John Hanacek</p>
        <p class="footer-subtitle">Innovator · Designer · Creator</p>
        <p class="footer-copyright">© 2026 John Hanacek · JHDesign LLC </p>
        <p class="footer-signature"><img src="./Assets/footer-JHsig.png" alt="John Hanacek signature" style="height: 2em; opacity: 0.7;" loading="lazy"></p>
        <p class="version">Portfolio v1.0 · Updated January 2026 · Made with Claude Code</p>
    </footer>

    <script>
        // Navigation scroll visibility - show after scrolling past hero
        const nav = document.getElementById('nav');
        const hero = document.querySelector('.hero');

        function updateNavVisibility() {
            const heroBottom = hero.offsetTop + hero.offsetHeight - 60;
            if (window.scrollY > heroBottom) {
                nav.classList.add('visible');
            } else {
                nav.classList.remove('visible');
            }
        }

        window.addEventListener('scroll', updateNavVisibility);
        window.addEventListener('resize', updateNavVisibility);
        updateNavVisibility();

        // Mobile navigation toggle
        const navToggle = document.querySelector('.nav-toggle');
        const navMenu = document.querySelector('nav ul');

        navToggle.addEventListener('click', function() {
            const isExpanded = this.getAttribute('aria-expanded') === 'true';
            this.setAttribute('aria-expanded', !isExpanded);
            this.classList.toggle('active');
            navMenu.classList.toggle('open');
        });

        // Close menu when clicking a link
        navMenu.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', () => {
                navToggle.setAttribute('aria-expanded', 'false');
                navToggle.classList.remove('active');
                navMenu.classList.remove('open');
            });
        });
    </script>

    <!-- Hero Canvas Drawing Interaction -->
    <script>
        const canvas = document.getElementById('heroCanvas');
        const ctx = canvas.getContext('2d');
        
        // ============================================
        // Unified Timing Constants (in ms)
        // ============================================
        const TIMING = {
            // Raw strokes
            strokeHold: 1500,       // Time before stroke starts fading
            strokeFade: 2000,       // Fade duration for strokes
            
            // Recognized shapes
            morphDuration: 400,     // Shape morph animation
            shapeHold: 4000,        // Time shape stays at full opacity
            shapeFade: 1500,        // Fade duration for shapes
            
            // Whisper labels
            labelFadeIn: 200,       // Label fade in
            labelHold: 2500,        // Label at full opacity  
            labelFade: 800,         // Label fade out
            
            // Relationships & intersections
            relationshipFade: 1200, // Relationship indicator fade
            
            // Glyph reaction
            glyphActive: 2500,      // How long glyphs react after shape
        };
        
        // Computed totals
        TIMING.strokeTotal = TIMING.strokeHold + TIMING.strokeFade;
        TIMING.shapeTotal = TIMING.shapeHold + TIMING.shapeFade;
        TIMING.labelTotal = TIMING.labelFadeIn + TIMING.labelHold + TIMING.labelFade;
        
        let isDrawing = false;
        let strokes = [];           // Raw strokes (fade out)
        let recognizedShapes = [];  // Completed shapes (persist longer)
        let whisperLabels = [];     // Floating labels
        let rawIntersections = [];  // Intersections between raw strokes
        let currentStroke = null;
        let glyphRotation = 0;      // For reactive glyphs
        let glyphPulse = 0;
        let lastShapeTime = 0;
        let ripples = [];           // Tap ripple effects
        let particles = [];         // Recognition particle bursts
        let ambientParticles = [];  // Floating ambient particles
        
        // Blueprint colors
        // Earth Star color palette - bioluminescent nanotech
        const colors = {
            bg: '#020208',
            grid: 'rgba(0, 217, 255, 0.08)',
            gridAccent: 'rgba(0, 217, 255, 0.15)',
            stroke: 'rgba(0, 217, 255, 0.85)',
            strokeComplete: 'rgba(199, 125, 255, 0.95)',
            ghost: 'rgba(0, 217, 255, 0.25)',
            glyph: 'rgba(0, 217, 255, 0.3)',
            glyphActive: 'rgba(199, 125, 255, 0.6)',
            cursor: 'rgba(255, 110, 199, 0.9)',
            glow: 'rgba(0, 217, 255, 0.5)',
            label: 'rgba(122, 229, 130, 0.8)'
        };

        // ============================================
        // Helper Functions
        // ============================================
        function getBounds(points) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            points.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            return { minX, minY, maxX, maxY };
        }

        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function getCircleScore(points, center, radius) {
            let totalError = 0;
            points.forEach(p => {
                const dist = distance(p, center);
                totalError += Math.abs(dist - radius) / radius;
            });
            return Math.max(0, 1 - (totalError / points.length));
        }

        function getRectScore(points, bounds) {
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            let cornerCount = 0;
            const corners = [
                { x: bounds.minX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.maxY },
                { x: bounds.minX, y: bounds.maxY }
            ];
            const threshold = Math.max(width, height) * 0.15;
            corners.forEach(corner => {
                if (points.some(p => distance(p, corner) < threshold)) cornerCount++;
            });
            return cornerCount / 4;
        }

        function getTriangleScore(points, bounds) {
            // Improved triangle detection
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const cx = (bounds.minX + bounds.maxX) / 2;
            const cy = (bounds.minY + bounds.maxY) / 2;

            // Find the 3 most extreme points (potential vertices)
            let topPoint = points[0], bottomLeft = points[0], bottomRight = points[0];

            points.forEach(p => {
                if (p.y < topPoint.y) topPoint = p;
                if (p.y > bottomLeft.y || (p.y === bottomLeft.y && p.x < bottomLeft.x)) bottomLeft = p;
                if (p.y > bottomRight.y || (p.y === bottomRight.y && p.x > bottomRight.x)) bottomRight = p;
            });

            // Check for roughly 3 direction changes (corners)
            let turns = 0;
            const step = Math.max(1, Math.floor(points.length / 20));
            for (let i = step; i < points.length - step; i += step) {
                const prev = points[i - step];
                const curr = points[i];
                const next = points[Math.min(i + step, points.length - 1)];
                const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                let diff = Math.abs(angle2 - angle1);
                if (diff > Math.PI) diff = 2 * Math.PI - diff;
                if (diff > 0.4 && diff < 2.8) turns++;
            }

            // Aspect ratio check - triangles shouldn't be too thin
            const aspect = Math.min(width, height) / Math.max(width, height);
            const aspectOk = aspect > 0.3;

            if (turns >= 2 && turns <= 6 && aspectOk) {
                return 0.65;
            }
            return 0.25;
        }

        function getLineScore(points) {
            if (points.length < 3) return 0;
            const start = points[0];
            const end = points[points.length - 1];
            const lineLen = distance(start, end);
            if (lineLen < 30) return 0;

            let totalDev = 0;
            points.forEach(p => {
                const t = Math.max(0, Math.min(1,
                    ((p.x - start.x) * (end.x - start.x) + (p.y - start.y) * (end.y - start.y)) / (lineLen * lineLen)
                ));
                const proj = { x: start.x + t * (end.x - start.x), y: start.y + t * (end.y - start.y) };
                totalDev += distance(p, proj);
            });
            return Math.max(0, 1 - (totalDev / points.length) / (lineLen * 0.1));
        }

        function detectArrowHead(points) {
            if (points.length < 10) return false;
            const last10 = points.slice(-10);
            const end = points[points.length - 1];
            const beforeEnd = points[Math.max(0, points.length - 8)];
            const mainDir = Math.atan2(end.y - beforeEnd.y, end.x - beforeEnd.x);

            // Check for splaying at end
            let hasSplay = false;
            for (let i = 1; i < last10.length - 1; i++) {
                const dir = Math.atan2(last10[i].y - end.y, last10[i].x - end.x);
                const diff = Math.abs(dir - mainDir);
                if (diff > 0.4 && diff < 2.7) hasSplay = true;
            }
            return hasSplay;
        }

        // ============================================
        // Shape Detection
        // ============================================
        function detectShape(points) {
            if (points.length < 5) return null;

            const bounds = getBounds(points);
            const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const size = Math.max(width, height);

            if (size < 20) return null; // Too small

            // Check if closed (start near end)
            const start = points[0];
            const end = points[points.length - 1];
            const closedThreshold = size * 0.25;
            const isClosed = distance(start, end) < closedThreshold;

            if (isClosed) {
                // Analyze closed shape
                const circleScore = getCircleScore(points, center, size / 2);
                const rectScore = getRectScore(points, bounds);
                const triScore = getTriangleScore(points, bounds);

                if (circleScore > 0.7 && circleScore > rectScore && circleScore > triScore) {
                    return { type: 'circle', center, radius: size / 2, confidence: circleScore };
                }
                if (rectScore > 0.6 && rectScore > triScore) {
                    return { type: 'rectangle', bounds, center, confidence: rectScore };
                }
                if (triScore > 0.5) {
                    return { type: 'triangle', bounds, center, confidence: triScore };
                }
            } else {
                // Open shape - line or arrow
                const lineScore = getLineScore(points);
                if (lineScore > 0.7) {
                    const hasArrow = detectArrowHead(points);
                    return {
                        type: hasArrow ? 'arrow' : 'line',
                        start, end, center,
                        confidence: lineScore
                    };
                }
            }

            return null;
        }
        
        // ============================================
        // Generate Ideal Shape Points
        // ============================================
        function generateIdealShape(shape, numPoints = 60) {
            const points = [];
            
            if (shape.type === 'circle') {
                for (let i = 0; i <= numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    points.push({
                        x: shape.center.x + Math.cos(angle) * shape.radius,
                        y: shape.center.y + Math.sin(angle) * shape.radius
                    });
                }
            } else if (shape.type === 'rectangle') {
                const b = shape.bounds;
                const corners = [
                    { x: b.minX, y: b.minY }, { x: b.maxX, y: b.minY },
                    { x: b.maxX, y: b.maxY }, { x: b.minX, y: b.maxY },
                    { x: b.minX, y: b.minY }
                ];
                const perSide = Math.floor(numPoints / 4);
                for (let s = 0; s < 4; s++) {
                    for (let i = 0; i < perSide; i++) {
                        const t = i / perSide;
                        points.push({
                            x: corners[s].x + t * (corners[s + 1].x - corners[s].x),
                            y: corners[s].y + t * (corners[s + 1].y - corners[s].y)
                        });
                    }
                }
            } else if (shape.type === 'triangle') {
                const b = shape.bounds;
                const cx = (b.minX + b.maxX) / 2;
                const triPoints = [
                    { x: cx, y: b.minY },
                    { x: b.maxX, y: b.maxY },
                    { x: b.minX, y: b.maxY },
                    { x: cx, y: b.minY }
                ];
                const perSide = Math.floor(numPoints / 3);
                for (let s = 0; s < 3; s++) {
                    for (let i = 0; i < perSide; i++) {
                        const t = i / perSide;
                        points.push({
                            x: triPoints[s].x + t * (triPoints[s + 1].x - triPoints[s].x),
                            y: triPoints[s].y + t * (triPoints[s + 1].y - triPoints[s].y)
                        });
                    }
                }
            } else if (shape.type === 'line' || shape.type === 'arrow') {
                for (let i = 0; i <= numPoints; i++) {
                    const t = i / numPoints;
                    points.push({
                        x: shape.start.x + t * (shape.end.x - shape.start.x),
                        y: shape.start.y + t * (shape.end.y - shape.start.y)
                    });
                }
                if (shape.type === 'arrow') {
                    const angle = Math.atan2(shape.end.y - shape.start.y, shape.end.x - shape.start.x);
                    const headLen = 15;
                    points.push({ x: shape.end.x - headLen * Math.cos(angle - 0.4), y: shape.end.y - headLen * Math.sin(angle - 0.4) });
                    points.push(shape.end);
                    points.push({ x: shape.end.x - headLen * Math.cos(angle + 0.4), y: shape.end.y - headLen * Math.sin(angle + 0.4) });
                }
            } else if (shape.type === 'dot') {
                // Dot is just a single point
                points.push(shape.center);
            }
            
            return points;
        }
        
        // ============================================
        // Relationship Detection
        // ============================================
        function detectRelationships() {
            const relationships = [];
            const shapes = recognizedShapes.filter(s => Date.now() - s.createdAt < TIMING.shapeTotal);
            
            for (let i = 0; i < shapes.length; i++) {
                for (let j = i + 1; j < shapes.length; j++) {
                    const a = shapes[i];
                    const b = shapes[j];
                    
                    const rel = analyzeRelationship(a, b);
                    if (rel) {
                        relationships.push({
                            shapeA: a,
                            shapeB: b,
                            ...rel
                        });
                    }
                }
            }
            return relationships;
        }
        
        function analyzeRelationship(a, b) {
            const dist = distance(a.center, b.center);
            const aSize = getShapeSize(a);
            const bSize = getShapeSize(b);
            const combinedSize = (aSize + bSize) / 2;
            
            // Lines don't "contain" things - skip containment check for lines
            const aIsLine = a.type === 'line' || a.type === 'arrow';
            const bIsLine = b.type === 'line' || b.type === 'arrow';
            
            // Check containment (only for closed shapes)
            if (!aIsLine && !bIsLine && dist < Math.abs(aSize - bSize) * 0.5) {
                const container = aSize > bSize ? a : b;
                const contained = aSize > bSize ? b : a;
                return { type: 'contains', container, contained, dist };
            }
            
            // Check intersection/overlap - always check for lines
            if (aIsLine || bIsLine || dist < combinedSize * 0.9) {
                const intersections = findIntersectionPoints(a, b);
                if (intersections.length > 0) {
                    return { type: 'intersects', intersections, dist };
                }
                if (!aIsLine && !bIsLine) {
                    return { type: 'overlaps', dist };
                }
            }
            
            // Check adjacency (close but not overlapping)
            if (dist < combinedSize * 1.5) {
                return { type: 'adjacent', dist };
            }
            
            // Check alignment
            const dx = Math.abs(a.center.x - b.center.x);
            const dy = Math.abs(a.center.y - b.center.y);
            if (dx < 15) return { type: 'aligned-vertical', dist };
            if (dy < 15) return { type: 'aligned-horizontal', dist };
            
            return null;
        }
        
        function getShapeSize(shape) {
            if (shape.type === 'circle') return shape.radius * 2;
            if (shape.type === 'dot') return 12; // Small fixed size for dots
            if (shape.bounds) {
                return Math.max(shape.bounds.maxX - shape.bounds.minX, shape.bounds.maxY - shape.bounds.minY);
            }
            if (shape.start && shape.end) {
                return distance(shape.start, shape.end);
            }
            return 50;
        }
        
        function findIntersectionPoints(a, b) {
            const points = [];
            
            // Special case: two circles - use geometric calculation
            if (a.type === 'circle' && b.type === 'circle') {
                const d = distance(a.center, b.center);
                const r1 = a.radius;
                const r2 = b.radius;
                
                // Check if circles actually intersect
                if (d < r1 + r2 && d > Math.abs(r1 - r2)) {
                    // Calculate intersection points
                    const a2 = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
                    const h = Math.sqrt(Math.max(0, r1 * r1 - a2 * a2));
                    
                    const px = a.center.x + a2 * (b.center.x - a.center.x) / d;
                    const py = a.center.y + a2 * (b.center.y - a.center.y) / d;
                    
                    const dx = h * (b.center.y - a.center.y) / d;
                    const dy = h * (b.center.x - a.center.x) / d;
                    
                    points.push({ x: px + dx, y: py - dy });
                    if (h > 1) { // Two distinct points
                        points.push({ x: px - dx, y: py + dy });
                    }
                }
                return points;
            }
            
            // General case: check line segment intersections
            const aPoints = a.idealPoints || [];
            const bPoints = b.idealPoints || [];
            
            if (aPoints.length < 4 || bPoints.length < 4) return points;
            
            const stepA = Math.max(1, Math.floor(aPoints.length / 24));
            const stepB = Math.max(1, Math.floor(bPoints.length / 24));
            
            for (let i = 0; i < aPoints.length - stepA; i += stepA) {
                const a1 = aPoints[i];
                const a2 = aPoints[i + stepA];
                
                for (let j = 0; j < bPoints.length - stepB; j += stepB) {
                    const b1 = bPoints[j];
                    const b2 = bPoints[j + stepB];
                    
                    const intersection = lineIntersection(a1, a2, b1, b2);
                    if (intersection) {
                        const tooClose = points.some(p => distance(p, intersection) < 15);
                        if (!tooClose) points.push(intersection);
                    }
                }
            }
            return points.slice(0, 4);
        }
        
        function lineIntersection(p1, p2, p3, p4) {
            const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (Math.abs(d) < 0.001) return null;
            
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / d;
            
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };
            }
            return null;
        }
        
        function drawRelationships() {
            const relationships = detectRelationships();
            const now = Date.now();
            
            relationships.forEach(rel => {
                const a = rel.shapeA;
                const b = rel.shapeB;
                const age = Math.max(now - a.createdAt, now - b.createdAt);
                let opacity = 1;
                // Fade with the shapes
                if (age > TIMING.shapeHold) {
                    opacity = 1 - ((age - TIMING.shapeHold) / TIMING.relationshipFade);
                }
                if (opacity <= 0) return;
                
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                // Draw connection line
                ctx.strokeStyle = `rgba(251, 191, 36, ${0.4 * easedOpacity})`; // Warm yellow
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(a.center.x, a.center.y);
                ctx.lineTo(b.center.x, b.center.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw relationship indicator at midpoint
                const midX = (a.center.x + b.center.x) / 2;
                const midY = (a.center.y + b.center.y) / 2;
                
                // Relationship-specific visuals
                if (rel.type === 'intersects' && rel.intersections) {
                    // Draw glowing intersection points
                    rel.intersections.forEach(pt => {
                        ctx.shadowColor = 'rgba(251, 191, 36, 0.8)';
                        ctx.shadowBlur = 12 * easedOpacity;
                        ctx.fillStyle = `rgba(251, 191, 36, ${0.9 * easedOpacity})`;
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Outer ring
                        ctx.strokeStyle = `rgba(251, 191, 36, ${0.5 * easedOpacity})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    });
                    
                    // Add label near first intersection
                    if (rel.intersections.length > 0) {
                        const pt = rel.intersections[0];
                        ctx.font = '500 10px "DM Sans", sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillStyle = `rgba(251, 191, 36, ${0.9 * easedOpacity})`;
                        ctx.fillText('intersects', pt.x, pt.y - 16);
                    }
                }
                
                if (rel.type === 'contains') {
                    // Draw containment brackets
                    ctx.strokeStyle = `rgba(74, 222, 128, ${0.5 * easedOpacity})`; // Green
                    ctx.lineWidth = 2;
                    const r = getShapeSize(rel.container) / 2 + 8;
                    ctx.beginPath();
                    ctx.arc(rel.container.center.x, rel.container.center.y, r, -0.3, 0.3);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(rel.container.center.x, rel.container.center.y, r, Math.PI - 0.3, Math.PI + 0.3);
                    ctx.stroke();
                    
                    // Add label
                    ctx.font = '500 10px "DM Sans", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = `rgba(74, 222, 128, ${0.8 * easedOpacity})`;
                    ctx.fillText('⊃ contains', rel.container.center.x, rel.container.center.y - r - 8);
                }
                
                if (rel.type === 'adjacent') {
                    // Draw proximity indicator
                    ctx.fillStyle = `rgba(147, 197, 253, ${0.6 * easedOpacity})`;
                    ctx.beginPath();
                    ctx.arc(midX, midY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (rel.type === 'aligned-vertical' || rel.type === 'aligned-horizontal') {
                    // Draw alignment guide
                    ctx.strokeStyle = `rgba(167, 139, 250, ${0.4 * easedOpacity})`; // Purple
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 4]);
                    ctx.beginPath();
                    if (rel.type === 'aligned-vertical') {
                        ctx.moveTo(a.center.x, Math.min(a.center.y, b.center.y) - 20);
                        ctx.lineTo(a.center.x, Math.max(a.center.y, b.center.y) + 20);
                    } else {
                        ctx.moveTo(Math.min(a.center.x, b.center.x) - 20, a.center.y);
                        ctx.lineTo(Math.max(a.center.x, b.center.x) + 20, a.center.y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw relationship label with word
                const labelData = {
                    'intersects': { symbol: '×', word: 'intersects' },
                    'contains': { symbol: '⊃', word: 'contains' },
                    'overlaps': { symbol: '∩', word: 'overlaps' },
                    'adjacent': { symbol: '↔', word: 'near' },
                    'aligned-vertical': { symbol: '│', word: 'aligned' },
                    'aligned-horizontal': { symbol: '─', word: 'aligned' }
                };
                
                const labelInfo = labelData[rel.type];
                if (labelInfo && rel.type !== 'intersects') { // intersects already has point markers
                    const displayText = `${labelInfo.symbol} ${labelInfo.word}`;
                    ctx.font = '500 10px "DM Sans", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Background pill
                    ctx.fillStyle = `rgba(10, 22, 40, ${0.85 * easedOpacity})`;
                    const metrics = ctx.measureText(displayText);
                    const pw = metrics.width + 12;
                    const ph = 18;
                    ctx.beginPath();
                    const rr = 9;
                    ctx.moveTo(midX - pw/2 + rr, midY - ph/2);
                    ctx.lineTo(midX + pw/2 - rr, midY - ph/2);
                    ctx.quadraticCurveTo(midX + pw/2, midY - ph/2, midX + pw/2, midY - ph/2 + rr);
                    ctx.lineTo(midX + pw/2, midY + ph/2 - rr);
                    ctx.quadraticCurveTo(midX + pw/2, midY + ph/2, midX + pw/2 - rr, midY + ph/2);
                    ctx.lineTo(midX - pw/2 + rr, midY + ph/2);
                    ctx.quadraticCurveTo(midX - pw/2, midY + ph/2, midX - pw/2, midY + ph/2 - rr);
                    ctx.lineTo(midX - pw/2, midY - ph/2 + rr);
                    ctx.quadraticCurveTo(midX - pw/2, midY - ph/2, midX - pw/2 + rr, midY - ph/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Label text
                    ctx.fillStyle = `rgba(251, 191, 36, ${0.95 * easedOpacity})`;
                    ctx.fillText(displayText, midX, midY);
                }
            });
        }
        
        // ============================================
        // Raw Stroke Intersection Detection
        // ============================================
        function detectRawIntersections() {
            const now = Date.now();
            const activeStrokes = strokes.filter(s => {
                const age = now - s.startTime;
                return age < s.fadeStart + TIMING.strokeFade && s.points.length > 3;
            });
            
            const intersections = [];
            
            // Check strokes against each other
            for (let i = 0; i < activeStrokes.length; i++) {
                for (let j = i + 1; j < activeStrokes.length; j++) {
                    const pts = findStrokeIntersections(activeStrokes[i].points, activeStrokes[j].points);
                    pts.forEach(pt => {
                        intersections.push({
                            ...pt,
                            createdAt: Math.max(activeStrokes[i].startTime, activeStrokes[j].startTime)
                        });
                    });
                }
            }
            
            // Check strokes against recognized shapes
            const activeShapes = recognizedShapes.filter(s => now - s.createdAt < TIMING.shapeTotal);
            for (const stroke of activeStrokes) {
                for (const shape of activeShapes) {
                    const pts = findStrokeIntersections(stroke.points, shape.idealPoints || []);
                    pts.forEach(pt => {
                        intersections.push({
                            ...pt,
                            createdAt: Math.max(stroke.startTime, shape.createdAt)
                        });
                    });
                }
            }
            
            return intersections;
        }
        
        function findStrokeIntersections(pointsA, pointsB) {
            const results = [];
            if (pointsA.length < 5 || pointsB.length < 5) return results;
            
            // Coarser sampling to reduce noise
            const stepA = Math.max(3, Math.floor(pointsA.length / 15));
            const stepB = Math.max(3, Math.floor(pointsB.length / 15));
            
            for (let i = 0; i < pointsA.length - stepA; i += stepA) {
                const a1 = pointsA[i];
                const a2 = pointsA[Math.min(i + stepA, pointsA.length - 1)];
                
                for (let j = 0; j < pointsB.length - stepB; j += stepB) {
                    const b1 = pointsB[j];
                    const b2 = pointsB[Math.min(j + stepB, pointsB.length - 1)];
                    
                    const intersection = lineIntersection(a1, a2, b1, b2);
                    if (intersection) {
                        // Larger minimum distance to avoid clustering
                        const tooClose = results.some(p => distance(p, intersection) < 40);
                        if (!tooClose) results.push(intersection);
                    }
                }
            }
            return results.slice(0, 3); // Max 3 per pair
        }
        
        function drawRawIntersections() {
            const now = Date.now();
            const intersections = detectRawIntersections();
            
            intersections.forEach(pt => {
                const age = now - pt.createdAt;
                let opacity = 1;
                // Sync fade with strokes
                if (age > TIMING.strokeHold) {
                    opacity = 1 - ((age - TIMING.strokeHold) / TIMING.strokeFade);
                }
                if (opacity <= 0) return;
                
                // Ease out curve for smoother fade
                const easedOpacity = opacity * opacity; // Quadratic ease out
                
                // Subtle cyan glow for raw intersections
                ctx.shadowColor = 'rgba(34, 211, 238, 0.7)';
                ctx.shadowBlur = 10 * easedOpacity;
                ctx.fillStyle = `rgba(34, 211, 238, ${0.8 * easedOpacity})`;
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Outer ring
                ctx.strokeStyle = `rgba(34, 211, 238, ${0.4 * easedOpacity})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 7, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            });
        }
        
        // ============================================
        // Canvas Setup
        // ============================================
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ============================================
        // Drawing Functions
        // ============================================
        function drawGrid() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, w, h);

            drawGlyphs(w, h);
        }
        
        function drawGlyphs(w, h) {
            const now = Date.now();
            const timeSinceShape = now - lastShapeTime;
            const isActive = timeSinceShape < TIMING.glyphActive;
            
            // Smooth transition for active state
            let activeAmount = 0;
            if (isActive) {
                // Fade in quickly, fade out smoothly
                if (timeSinceShape < 200) {
                    activeAmount = timeSinceShape / 200;
                } else if (timeSinceShape > TIMING.glyphActive - 500) {
                    activeAmount = (TIMING.glyphActive - timeSinceShape) / 500;
                } else {
                    activeAmount = 1;
                }
            }
            
            // Pulse when idle
            if (!isActive && !isDrawing) {
                glyphPulse = Math.sin(now / 1000) * 0.15 + 0.85;
            } else {
                glyphPulse = 1;
            }
            
            // Rotate when shape detected (slow down as it fades)
            if (isActive) {
                glyphRotation += 0.02 * activeAmount;
            }
            
            const corners = [[40, 40], [w - 40, 40], [40, h - 40], [w - 40, h - 40]];
            corners.forEach(([x, y], i) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(glyphRotation * (i % 2 === 0 ? 1 : -1));
                
                // Interpolate between cyan (idle) and purple (active) - Earth Star palette
                const idleColor = [0, 217, 255];  // bio-cyan
                const activeColor = [199, 125, 255];  // bio-purple
                const r = Math.round(idleColor[0] + (activeColor[0] - idleColor[0]) * activeAmount);
                const g = Math.round(idleColor[1] + (activeColor[1] - idleColor[1]) * activeAmount);
                const b = Math.round(idleColor[2] + (activeColor[2] - idleColor[2]) * activeAmount);
                const a = 0.3 + 0.4 * activeAmount;

                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                ctx.globalAlpha = glyphPulse;
                ctx.lineWidth = 1.5 + 0.5 * activeAmount;

                // Art Nouveau crystalline motif - hexagonal with organic curves
                // Central hexagon
                ctx.beginPath();
                for (let j = 0; j < 6; j++) {
                    const angle = (j / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * 8;
                    const y = Math.sin(angle) * 8;
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();

                // Radiating lines (like spider silk strands)
                ctx.globalAlpha = glyphPulse * 0.6;
                for (let j = 0; j < 6; j++) {
                    const angle = (j / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 8, Math.sin(angle) * 8);
                    ctx.lineTo(Math.cos(angle) * 15, Math.sin(angle) * 15);
                    ctx.stroke();
                }

                // Outer ring with subtle glow (crystallization boundary)
                if (activeAmount > 0.2) {
                    ctx.globalAlpha = glyphPulse * activeAmount;
                    ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    ctx.shadowBlur = 8 + 6 * activeAmount;
                    ctx.beginPath();
                    ctx.arc(0, 0, 12 + 2 * activeAmount, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            });
            ctx.globalAlpha = 1;
        }
        
        function drawRawStrokes() {
            const now = Date.now();
            
            strokes = strokes.filter(stroke => {
                const age = now - stroke.startTime;
                if (age > stroke.fadeStart + TIMING.strokeFade) return false;
                
                let opacity = 1;
                if (age > stroke.fadeStart) {
                    opacity = 1 - ((age - stroke.fadeStart) / TIMING.strokeFade);
                }
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                if (stroke.points.length < 2) return true;
                
                ctx.shadowColor = colors.glow;
                ctx.shadowBlur = 12 * easedOpacity;
                ctx.strokeStyle = `rgba(147, 197, 253, ${0.85 * easedOpacity})`;
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    const p0 = stroke.points[i - 1];
                    const p1 = stroke.points[i];
                    ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                return true;
            });
        }
        
        function drawRecognizedShapes() {
            const now = Date.now();
            
            recognizedShapes = recognizedShapes.filter(shape => {
                const age = now - shape.createdAt;
                if (age > TIMING.shapeTotal) return false;
                
                let opacity = 1;
                if (age > TIMING.shapeHold) {
                    opacity = 1 - ((age - TIMING.shapeHold) / TIMING.shapeFade);
                }
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                const progress = Math.min(1, age / TIMING.morphDuration);
                const morphEase = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                
                // Interpolate between raw and ideal points
                const points = [];
                const idealLen = shape.idealPoints.length;
                const rawLen = shape.rawPoints.length;
                
                for (let i = 0; i < idealLen; i++) {
                    const rawIdx = Math.floor((i / idealLen) * rawLen);
                    const raw = shape.rawPoints[Math.min(rawIdx, rawLen - 1)];
                    const ideal = shape.idealPoints[i];
                    points.push({
                        x: raw.x + (ideal.x - raw.x) * morphEase,
                        y: raw.y + (ideal.y - raw.y) * morphEase
                    });
                }
                
                // Draw shape
                ctx.shadowColor = 'rgba(96, 165, 250, 0.6)';
                ctx.shadowBlur = 20 * easedOpacity;
                ctx.strokeStyle = `rgba(96, 165, 250, ${0.9 * easedOpacity})`;
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Special handling for dots
                if (shape.type === 'dot') {
                    ctx.fillStyle = `rgba(96, 165, 250, ${0.9 * easedOpacity})`;
                    ctx.beginPath();
                    ctx.arc(shape.center.x, shape.center.y, 5 + 2 * morphEase, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    return true;
                }
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                if (shape.type === 'circle' || shape.type === 'rectangle' || shape.type === 'triangle') {
                    ctx.closePath();
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                return true;
            });
        }
        
        function drawGhostSuggestion() {
            if (!isDrawing || !currentStroke || currentStroke.points.length < 10) return;
            
            const shape = detectShape(currentStroke.points);
            if (!shape || shape.confidence < 0.4) return;
            
            const idealPoints = generateIdealShape(shape);
            
            ctx.strokeStyle = colors.ghost;
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(idealPoints[0].x, idealPoints[0].y);
            for (let i = 1; i < idealPoints.length; i++) {
                ctx.lineTo(idealPoints[i].x, idealPoints[i].y);
            }
            if (shape.type === 'circle' || shape.type === 'rectangle' || shape.type === 'triangle') {
                ctx.closePath();
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawWhisperLabels() {
            const now = Date.now();
            
            whisperLabels = whisperLabels.filter(label => {
                const age = now - label.createdAt;
                if (age > TIMING.labelTotal) return false;
                
                let opacity = 1;
                if (age < TIMING.labelFadeIn) {
                    opacity = age / TIMING.labelFadeIn;
                } else if (age > TIMING.labelFadeIn + TIMING.labelHold) {
                    opacity = 1 - ((age - TIMING.labelFadeIn - TIMING.labelHold) / TIMING.labelFade);
                }
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                const yOffset = -20 - (age / 80); // Float upward slightly slower
                
                ctx.font = '500 13px "DM Sans", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = `rgba(147, 197, 253, ${0.8 * easedOpacity})`;
                ctx.fillText(label.text, label.x, label.y + yOffset);
                
                return true;
            });
        }
        
        // Cursor with glow
        let cursorPos = { x: -100, y: -100 };
        let cursorVisible = false;
        
        function drawCursor() {
            if (!cursorVisible) return;
            
            const x = cursorPos.x;
            const y = cursorPos.y;
            const size = isDrawing ? 14 : 10;
            
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
            gradient.addColorStop(0, isDrawing ? 'rgba(251, 146, 60, 0.25)' : 'rgba(59, 130, 246, 0.2)');
            gradient.addColorStop(0.5, isDrawing ? 'rgba(251, 146, 60, 0.08)' : 'rgba(59, 130, 246, 0.05)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, 60, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = isDrawing ? colors.cursor : 'rgba(147, 197, 253, 0.7)';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = isDrawing ? colors.cursor : colors.glow;
            ctx.shadowBlur = 8;
            
            ctx.beginPath();
            ctx.moveTo(x - size, y); ctx.lineTo(x - 4, y);
            ctx.moveTo(x + 4, y); ctx.lineTo(x + size, y);
            ctx.moveTo(x, y - size); ctx.lineTo(x, y - 4);
            ctx.moveTo(x, y + 4); ctx.lineTo(x, y + size);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            if (isDrawing) {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = colors.cursor;
                ctx.fill();
            }
        }
        
        // Draw ripple effects (for tap/dot feedback)
        function drawRipples() {
            const now = Date.now();
            const rippleDuration = 600;
            
            ripples = ripples.filter(ripple => {
                const age = now - ripple.createdAt;
                if (age > rippleDuration) return false;
                
                const progress = age / rippleDuration;
                const eased = 1 - Math.pow(1 - progress, 3); // ease out cubic
                const radius = ripple.maxRadius * eased;
                const opacity = 1 - progress;
                
                ctx.strokeStyle = `rgba(96, 165, 250, ${0.6 * opacity})`;
                ctx.lineWidth = 2 * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Second ring
                if (progress > 0.15) {
                    const innerProgress = (progress - 0.15) / 0.85;
                    const innerRadius = ripple.maxRadius * 0.6 * innerProgress;
                    ctx.strokeStyle = `rgba(147, 197, 253, ${0.4 * (1 - innerProgress)})`;
                    ctx.lineWidth = 1.5 * (1 - innerProgress * 0.5);
                    ctx.beginPath();
                    ctx.arc(ripple.x, ripple.y, innerRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                return true;
            });
        }
        
        // Draw particle burst (for shape recognition feedback)
        function drawParticles() {
            const now = Date.now();
            const particleDuration = 800;
            
            particles = particles.filter(p => {
                const age = now - p.createdAt;
                if (age > particleDuration) return false;
                
                const progress = age / particleDuration;
                const opacity = 1 - progress;
                
                // Update position with slight gravity
                p.x += p.vx;
                p.y += p.vy + progress * 0.5;
                p.vx *= 0.97;
                p.vy *= 0.97;
                
                // Draw crystalline particle - hexagonal shard
                const size = 4 * (1 - progress * 0.5);

                // Gradient from cyan to purple (bioluminescent crystallization)
                const hue = 180 + progress * 100; // cyan to purple transition
                const r = Math.round(0 + progress * 199);
                const g = Math.round(217 - progress * 92);
                const b = 255;

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.createdAt * 0.002); // Subtle rotation based on creation time

                // Hexagonal crystal shard with glow
                ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${0.6 * opacity})`;
                ctx.shadowBlur = 6 * opacity;
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.9 * opacity})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const x = Math.cos(angle) * size;
                    const y = Math.sin(angle) * size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.shadowBlur = 0;

                ctx.restore();
                
                return true;
            });
        }
        
        // Draw ambient floating particles
        function initAmbientParticles() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            for (let i = 0; i < 15; i++) {
                ambientParticles.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    size: 1 + Math.random() * 2,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }
        initAmbientParticles();
        
        function drawAmbientParticles() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            ambientParticles.forEach(p => {
                // Drift movement
                p.x += p.vx;
                p.y += p.vy;
                
                // Wrap around edges
                if (p.x < 0) p.x = w;
                if (p.x > w) p.x = 0;
                if (p.y < 0) p.y = h;
                if (p.y > h) p.y = 0;
                
                // Pulsing opacity
                const pulse = 0.15 + 0.1 * Math.sin(now / 2000 + p.phase);
                
                ctx.fillStyle = `rgba(147, 197, 253, ${pulse})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Animation loop - smart pausing when idle
        let animationFrameId = null;
        let isAnimating = false;

        function hasActiveAnimation() {
            return isDrawing ||
                   particles.length > 0 ||
                   ripples.length > 0 ||
                   strokes.length > 0 ||
                   recognizedShapes.length > 0 ||
                   whisperLabels.length > 0 ||
                   currentStroke !== null;
        }

        function animate() {
            drawGrid();
            drawAmbientParticles();
            drawRawStrokes();
            drawRawIntersections();
            drawRecognizedShapes();
            drawRelationships();
            drawGhostSuggestion();
            drawWhisperLabels();
            drawRipples();
            drawParticles();
            drawCursor();

            // Only continue animation if there's something active
            if (hasActiveAnimation()) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                isAnimating = false;
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (!isAnimating) {
                isAnimating = true;
                animate();
            }
        }

        // Start initial animation
        startAnimation();
        
        // ============================================
        // Event Handlers
        // ============================================
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function startDraw(e) {
            e.preventDefault();
            isDrawing = true;
            hero.classList.add('drawing');
            startAnimation(); // Ensure animation loop is running

            const pos = getPos(e);
            currentStroke = {
                points: [pos],
                startTime: Date.now(),
                fadeStart: TIMING.strokeHold
            };
            strokes.push(currentStroke);
        }
        
        function draw(e) {
            const pos = getPos(e);
            cursorPos = pos;
            cursorVisible = true;
            
            if (!isDrawing || !currentStroke) return;
            e.preventDefault();
            currentStroke.points.push(pos);
        }
        
        function endDraw() {
            // Detect tap/dot (few points, small area)
            if (currentStroke && currentStroke.points.length >= 1 && currentStroke.points.length <= 8) {
                const bounds = getBounds(currentStroke.points);
                const size = Math.max(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
                
                if (size < 25) {
                    // It's a tap/dot!
                    const center = currentStroke.points.length === 1 
                        ? currentStroke.points[0]
                        : { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
                    
                    // Add dot as recognized shape
                    recognizedShapes.push({
                        type: 'dot',
                        center,
                        radius: 6,
                        confidence: 1,
                        rawPoints: [...currentStroke.points],
                        idealPoints: [center],
                        createdAt: Date.now()
                    });
                    
                    // Add whisper label
                    whisperLabels.push({
                        text: 'Point',
                        x: center.x,
                        y: center.y,
                        createdAt: Date.now()
                    });
                    
                    // Add ripple effect
                    ripples.push({
                        x: center.x,
                        y: center.y,
                        createdAt: Date.now(),
                        maxRadius: 40
                    });
                    startAnimation(); // Restart animation for ripple

                    lastShapeTime = Date.now();
                    currentStroke.fadeStart = 0;
                }
            }
            
            if (currentStroke && currentStroke.points.length > 5) {
                const shape = detectShape(currentStroke.points);
                
                if (shape && shape.confidence > 0.5) {
                    // Create recognized shape with ideal points
                    recognizedShapes.push({
                        ...shape,
                        rawPoints: [...currentStroke.points],
                        idealPoints: generateIdealShape(shape),
                        createdAt: Date.now()
                    });
                    
                    // Add whisper label
                    const labelText = shape.type.charAt(0).toUpperCase() + shape.type.slice(1);
                    whisperLabels.push({
                        text: labelText,
                        x: shape.center.x,
                        y: shape.center.y,
                        createdAt: Date.now()
                    });
                    
                    // Add particle burst for recognition feedback
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        particles.push({
                            x: shape.center.x,
                            y: shape.center.y,
                            vx: Math.cos(angle) * (1.5 + Math.random()),
                            vy: Math.sin(angle) * (1.5 + Math.random()),
                            life: 1,
                            createdAt: Date.now()
                        });
                    }
                    startAnimation(); // Restart animation for particles

                    lastShapeTime = Date.now();
                    
                    // Hide raw stroke quickly since we're showing recognized version
                    currentStroke.fadeStart = 0;
                }
            }
            
            isDrawing = false;
            currentStroke = null;
            setTimeout(() => {
                if (!isDrawing) hero.classList.remove('drawing');
            }, 500);
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseleave', () => { endDraw(); cursorVisible = false; });
        canvas.addEventListener('mouseenter', () => { cursorVisible = true; });
        
        canvas.addEventListener('touchstart', startDraw, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', endDraw);
        canvas.addEventListener('touchcancel', endDraw);

        // ============================================
        // Cursor Spotlight Effect
        // ============================================
        const spotlight = document.getElementById('cursorSpotlight');
        let spotlightX = window.innerWidth / 2;
        let spotlightY = window.innerHeight / 2;
        let isSpotlightActive = false;

        function updateSpotlight(x, y) {
            spotlightX = x;
            spotlightY = y;
            const xPercent = (x / window.innerWidth) * 100;
            const yPercent = (y / window.innerHeight) * 100;
            spotlight.style.background = `radial-gradient(600px circle at ${xPercent}% ${yPercent}%, rgba(0, 217, 255, 0.15), rgba(199, 125, 255, 0.1) 40%, transparent 70%)`;
        }

        // Mouse events
        document.addEventListener('mousemove', (e) => {
            if (!isSpotlightActive) {
                spotlight.classList.add('active');
                isSpotlightActive = true;
            }
            updateSpotlight(e.clientX, e.clientY);
        });

        document.addEventListener('mouseleave', () => {
            spotlight.classList.remove('active');
            isSpotlightActive = false;
        });

        // Touch events
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 0) {
                spotlight.classList.add('active');
                isSpotlightActive = true;
                updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            // Keep spotlight visible for a moment after touch ends
            setTimeout(() => {
                if (!isSpotlightActive) {
                    spotlight.classList.remove('active');
                }
            }, 2000);
        });

        // ============================================
        // Demo Canvas - Interactive Fish Animation
        // ============================================
    </script>
</body>
</html>
