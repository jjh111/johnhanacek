<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>John Hanacek - Portfolio</title>
    <meta name="description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems. LLMs, XR, robotics.">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="./Assets/favicon-jhsigfrmpaper.png">

    <!-- Open Graph / Social Share -->
    <meta property="og:title" content="John Hanacek - Portfolio">
    <meta property="og:description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems.">
    <meta property="og:image" content="https://www.johnhanacek.com/Assets/socialgraph-jhcom.png">
    <meta property="og:url" content="https://www.johnhanacek.com/">
    <meta property="og:type" content="website">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="John Hanacek - Portfolio">
    <meta name="twitter:description" content="Founding Designer & Design Engineer. Building AI-native products, spatial computing interfaces, and agentic systems.">
    <meta name="twitter:image" content="https://www.johnhanacek.com/Assets/socialgraph-jhcom.png">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Raleway:wght@100;200;300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles/shared.css">

    <!-- Structured Data for AI/Search -->
    <link rel="alternate" type="application/json" href="./john-hanacek.json" title="Structured data">
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "ProfilePage",
        "mainEntity": {
            "@type": "Person",
            "name": "John Hanacek",
            "url": "https://www.johnhanacek.com",
            "image": "https://www.johnhanacek.com/Assets/socialgraph-jhcom.png",
            "jobTitle": ["Founding Designer", "Design Engineer", "Product Designer"],
            "description": "Founding Designer & Design Engineer building at the intersection of AI, spatial computing, and human-computer symbiosis.",
            "email": "hi@johnhanacek.com",
            "sameAs": [
                "https://www.linkedin.com/in/johnhanacek/",
                "https://bsky.app/profile/johnhanacek.bsky.social",
                "https://x.com/johnhanacek"
            ],
            "knowsAbout": ["AI-native product design", "Agentic systems", "LLM integration", "XR/Spatial interface design", "Design engineering", "MetaMedium", "Robotics"],
            "worksFor": {
                "@type": "Organization",
                "name": "JH Design LLC"
            }
        }
    }
    </script>
</head>
<body>
    <!-- Interactive Cursor Spotlight -->
    <div id="cursorSpotlight"></div>

    <a href="#about" class="skip-link">Skip to main content</a>

    <nav id="nav" role="navigation" aria-label="Main navigation">
        <div class="nav-inner">
            <div class="nav-left">
                <a href="index.html" class="shape-link active" aria-label="Home" aria-current="page">
                    <svg class="shape triangle" viewBox="0 0 40 40"><polygon points="20,8 34,32 6,32"/></svg>
                    <img class="shape-label shape-label-img" src="./Assets/footer-JHsig.png" alt="JH">
                </a>
                <a href="design.html" class="shape-link" aria-label="Design">
                    <svg class="shape rounded-square" viewBox="0 0 40 40"><rect x="6" y="6" width="28" height="28" rx="6"/></svg>
                    <span class="shape-label">DESIGN</span>
                </a>
                <a href="art.html" class="shape-link" aria-label="Art">
                    <svg class="shape circle" viewBox="0 0 40 40"><circle cx="20" cy="20" r="14"/></svg>
                    <span class="shape-label">ART</span>
                </a>
                <a href="index.html" class="nav-title">John Hanacek</a>
                <a href="about.html" class="shape-link secondary" aria-label="About">
                    <svg class="shape diamond" viewBox="0 0 40 40"><polygon points="20,6 34,20 20,34 6,20"/></svg>
                    <span class="shape-label">ABOUT</span>
                </a>
                <a href="services.html" class="shape-link secondary" aria-label="Services">
                    <svg class="shape star" viewBox="0 0 40 40"><polygon points="20,6 23,16 34,16 25,22 28,34 20,26 12,34 15,22 6,16 17,16"/></svg>
                    <span class="shape-label">SERVICES</span>
                </a>
            </div>
            <button class="nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-right">
                <li><a href="#about">About</a></li>
                <li><a href="#believe">I Believe</a></li>
                <li><a href="#highlights">Highlights</a></li>
                <li><a href="#endorsements">Endorsements</a></li>
                <li><a href="#explore">Explore</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </div>
    </nav>

    <header class="hero" id="top">
        <!-- Shape Navigation (hero) -->
        <nav class="shape-nav" aria-label="Page navigation">
            <a href="index.html" class="shape-link active" aria-label="Home" aria-current="page">
                <svg class="shape triangle" viewBox="0 0 40 40"><polygon points="20,8 34,32 6,32"/></svg>
                <img class="shape-label shape-label-img" src="./Assets/footer-JHsig.png" alt="JH">
            </a>
            <a href="design.html" class="shape-link" aria-label="Design">
                <svg class="shape rounded-square" viewBox="0 0 40 40"><rect x="6" y="6" width="28" height="28" rx="6"/></svg>
                <span class="shape-label">DESIGN</span>
            </a>
            <a href="art.html" class="shape-link" aria-label="Art">
                <svg class="shape circle" viewBox="0 0 40 40"><circle cx="20" cy="20" r="14"/></svg>
                <span class="shape-label">ART</span>
            </a>
        </nav>

        <!-- Interactive Blueprint Canvas -->
        <canvas id="heroCanvas"></canvas>
        <div class="hero-hint">
            <span class="hint-icon">✎</span>
            <span class="hint-text">draw</span>
        </div>
        
        <div class="hero-content">
            <h1>John <span class="meta">Hanacek</span></h1>
            <p class="tagline">DESIGN ENGINEER · PRODUCT DESIGNER · ARTIST</p>
            <p class="byline"> <span class="role">Sounds like · (Hana-check)</span></p>
            <img class="hero-sig-inline" src="./Assets/footer-JHsig.png" alt="John Hanacek signature">
        </div>
        <a href="#about" class="scroll-indicator" aria-label="Scroll to content">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                <path d="M7 13l5 5 5-5M7 6l5 5 5-5"/>
            </svg>
            <span class="scroll-text">goto content</span>
        </a>
    </header>

    <main>
        <!-- ABOUT -->
        <section id="about">
            <h2>About</h2>

            <div class="content-card about">
                <p><strong>Founding Designer </strong>& <strong>Design Engineer</strong> building at the intersection of AI, spatial computing, and human-computer symbiosis.</p>
                <p>I design and develop <strong>agentic systems</strong>, XR interfaces, and AI-augmented tools. Currently exploring <strong>MetaMedium</strong> concepts, dynamic design systems that blur the line between tool and medium, and a self improving automated research framework <strong>Earth Star </strong>using OpenClaw.</p>
            </div>
        </section>

        <!-- I BELIEVE -->
        <section id="believe">
            <h2>I Believe</h2>

            <div class="content-card">
                <p>Imagination is within reality.</p>
                <p>Infinite Games are more powerful than Finite Games.</p>
                <p>Technology can augment human intelligence & collaboration.</p>
                <p>Optimism and pessimism are self-fulfilling prophecies.</p>
                <p>We can choose better prophecies...</p>
            </div>
        </section>

        <!-- HIGHLIGHTS -->
        <section id="highlights">
            <h2>Highlights</h2>

            <div class="card-grid cols-3">
                <div class="content-card" data-num="01">
                    <h4>Georgetown MA 2016</h4>
                    <p>Awarded <strong>"Most Meta"</strong> by peers in Communication, Culture & Technology</p>
                </div>

                <div class="content-card" data-num="02">
                    <h4>Founder Institute 2020</h4>
                    <p>Graduate as CEO of <strong><a href="https://www.avatarmedic.com" target="_blank" rel="noopener">AvatarMEDIC</a></strong></p>
                </div>

                <div class="content-card" data-num="03">
                    <h4>Aerospace Medical Association 2022</h4>
                    <p><strong>R&D Innovation Award</strong> for XR Digital Twin robotics control</p>
                </div>
            </div>
        </section>



        <!-- ENDORSEMENTS -->
        <section id="endorsements">
            <h2>Featured Endorsements</h2>

            <div class="grid-2">
                <div class="content-card endorsement">
                    <p>"My choice for the most plausible vision of a future I desire goes to John Hanacek's scenario. I think I'd like to live there, and I think it is plausible in 100 years. My $100 goes to him."</p>
                    <cite><strong><a href="https://kk.org/thetechnium/a-desirable-future-haiku/" target="_blank" rel="noopener">Kevin Kelly</a></strong>, Futurist, Founder of Wired Magazine</cite>
                </div>

                <div class="content-card endorsement short">
                    <p>"Talented and very experienced designer!"</p>
                    <cite><strong><a href="https://www.linkedin.com/in/ipetryaevskaya/" target="_blank" rel="noopener">Inga Petryaevskaya</a></strong>, CEO <a href="https://www.shapesxr.com" target="_blank" rel="noopener">ShapesXR</a></cite>
                </div>
            </div>
        </section>

        <!-- EXPLORE & CONTACT - side by side on widescreen -->
        <div class="widescreen-split">
            <section id="explore">
                <h2>Explore</h2>

                <div class="content-card">
                    <h4><a href="design.html">Design Portfolio</a></h4>
                    <p>Professional work, case studies, and XR projects</p>
                </div>

                <div class="content-card">
                    <h4><a href="art.html">Art & Creative</a></h4>
                    <p>Visual art, photography, and creative experiments</p>
                </div>

                <div class="content-card">
                    <h4><a href="about.html">About & Experience</a></h4>
                    <p>Full bio, work history, and expertise</p>
                </div>

                <div class="content-card">
                    <h4><a href="services.html">Services & Consulting</a></h4>
                    <p>Founding designer, design engineering, and AI product services</p>
                </div>
            </section>

            <section id="contact">
                <h2>Contact</h2>

                <div class="content-card">
                    <h4>Email</h4>
                    <p><a href="mailto:hi@johnhanacek.com">hi@johnhanacek.com</a></p>

                    <h4>Writing</h4>
                    <ul>
                        <li><a href="https://spatialandimmersivedesign.substack.com/" target="_blank" rel="noopener">Spatial & Immersive Design Blog</a></li>
                        <li><a href="https://johnhanacek.substack.com" target="_blank" rel="noopener">Personal Blog (Tech, Strategy & Research)</a></li>
                    </ul>

                    <h4>Social</h4>
                    <ul>
                        <li><a href="https://bsky.app/profile/johnhanacek.bsky.social" target="_blank" rel="noopener">Bluesky</a></li>
                        <li><a href="https://x.com/johnhanacek" target="_blank" rel="noopener">X (Twitter)</a></li>
                        <li><a href="https://www.linkedin.com/in/johnhanacek/" target="_blank" rel="noopener">LinkedIn</a></li>
                    </ul>
                </div>
            </section>
        </div>

    </main>

    <footer>
        <p class="footer-title">John Hanacek</p>
        <p class="footer-subtitle">Founding Designer · Design Engineer · Product Designer</p>
        <p class="footer-copyright">© 2026 John Hanacek · JHDesign LLC </p>
        <p class="footer-signature"><img src="./Assets/footer-JHsig.png" alt="John Hanacek signature" loading="lazy"></p>
        <p class="version">Portfolio v1.0 · Updated January 2026 · Made with Claude Code</p>
    </footer>

    <script>
        // Navigation scroll visibility - show after scrolling past hero
        const nav = document.getElementById('nav');
        const hero = document.querySelector('.hero');

        function updateNavVisibility() {
            const heroBottom = hero.offsetTop + hero.offsetHeight - 60;
            if (window.scrollY > heroBottom) {
                nav.classList.add('visible');
            } else {
                nav.classList.remove('visible');
            }
        }

        window.addEventListener('scroll', updateNavVisibility);
        window.addEventListener('resize', updateNavVisibility);
        updateNavVisibility();

        // Mobile navigation toggle
        const navToggle = document.querySelector('.nav-toggle');
        const navMenu = document.querySelector('nav ul');

        navToggle.addEventListener('click', function() {
            const isExpanded = this.getAttribute('aria-expanded') === 'true';
            this.setAttribute('aria-expanded', !isExpanded);
            this.classList.toggle('active');
            navMenu.classList.toggle('open');
        });

        // Close menu when clicking a link
        navMenu.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', () => {
                navToggle.setAttribute('aria-expanded', 'false');
                navToggle.classList.remove('active');
                navMenu.classList.remove('open');
            });
        });
    </script>

    <!-- Hero Canvas Drawing Interaction -->
    <script>
        const canvas = document.getElementById('heroCanvas');
        const ctx = canvas.getContext('2d');
        
        // ============================================
        // Unified Timing Constants (in ms)
        // ============================================
        const TIMING = {
            strokeHold: 1500,       // Time before stroke starts fading
            strokeFade: 2000,       // Fade duration for strokes
        };
        TIMING.strokeTotal = TIMING.strokeHold + TIMING.strokeFade;
        
        let isDrawing = false;
        let strokes = [];           // Raw strokes (fade out)
        let currentStroke = null;
        let ripples = [];           // Tap ripple effects
        let particles = [];         // Recognition particle bursts
        let ambientParticles = [];  // Floating ambient particles

        // ============================================
        // Entity State (Fish Minigame)
        // ============================================
        let jellyfish = [];
        let fish = [];
        let coral = [];
        let bubbles = [];
        let food = [];
        let tempLines = [];
        let entityIdCounter = 0;

        const MAX_JELLYFISH = 3;
        const MAX_FISH = 10;
        const MAX_CORAL = 6;
        const MAX_BUBBLES = 20;
        const MAX_FOOD = 12;
        const FOOD_LIFETIME = 15000;
        const LINE_DURATION = 1500;

        const aquaColors = {
            jellyfish: ['#c77dff', '#a78bfa', '#e879f9'],
            fish: ['#00d9ff', '#4dc9f6', '#38bdf8'],
            coral: ['#ff6ec7', '#f472b6', '#fb7185'],
            bubble: 'rgba(77, 201, 246, 0.3)',
            food: '#7ae582',
            line: 'rgba(77, 201, 246, 0.5)'
        };

        // Deep Sea Terminal color palette
        const colors = {
            bg: '#020a12',
            stroke: 'rgba(77, 201, 246, 0.85)',
            cursor: 'rgba(212, 175, 55, 0.85)',
            glow: 'rgba(77, 201, 246, 0.4)',
        };

        // ============================================
        // Helper Functions
        // ============================================
        function getBounds(points) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            points.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            return { minX, minY, maxX, maxY };
        }

        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        // Shortest angular difference (returns value in [-PI, PI])
        function angleDiff(target, current) {
            let d = target - current;
            while (d > Math.PI) d -= Math.PI * 2;
            while (d < -Math.PI) d += Math.PI * 2;
            return d;
        }

        // Check if food position is inside any bubble (hidden from fish)
        function isFoodInBubble(fx, fy) {
            for (let i = 0; i < bubbles.length; i++) {
                const b = bubbles[i];
                const dx = fx - b.x;
                const dy = fy - b.y;
                if (dx * dx + dy * dy < b.radius * b.radius) return true;
            }
            return false;
        }

        // Check if line segment intersects a circle
        function segmentIntersectsCircle(p1, p2, cx, cy, r) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const fx = p1.x - cx;
            const fy = p1.y - cy;
            const a = dx * dx + dy * dy;
            const b2 = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - r * r;
            let disc = b2 * b2 - 4 * a * c;
            if (disc < 0) return false;
            disc = Math.sqrt(disc);
            const t1 = (-b2 - disc) / (2 * a);
            const t2 = (-b2 + disc) / (2 * a);
            return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
        }

        function getCircleScore(points, center, radius) {
            let totalError = 0;
            points.forEach(p => {
                const dist = distance(p, center);
                totalError += Math.abs(dist - radius) / radius;
            });
            return Math.max(0, 1 - (totalError / points.length));
        }

        // Exact scoring functions from design.html
        function getRectScore(points, bounds) {
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            let cornerCount = 0;
            const corners = [
                { x: bounds.minX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.minY },
                { x: bounds.maxX, y: bounds.maxY },
                { x: bounds.minX, y: bounds.maxY }
            ];
            const threshold = Math.max(width, height) * 0.15;
            corners.forEach(corner => {
                if (points.some(p => distance(p, corner) < threshold)) cornerCount++;
            });
            return cornerCount / 4;
        }

        function getTriangleScore(points, bounds) {
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;

            // Check for roughly 3 direction changes (corners)
            let turns = 0;
            const step = Math.max(1, Math.floor(points.length / 20));
            for (let i = step; i < points.length - step; i += step) {
                const prev = points[i - step];
                const curr = points[i];
                const next = points[Math.min(i + step, points.length - 1)];
                const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                let diff = Math.abs(angle2 - angle1);
                if (diff > Math.PI) diff = 2 * Math.PI - diff;
                if (diff > 0.4 && diff < 2.8) turns++;
            }

            // Aspect ratio check - triangles shouldn't be too thin
            const aspect = Math.min(width, height) / Math.max(width, height);
            const aspectOk = aspect > 0.3;

            if (turns >= 2 && turns <= 6 && aspectOk) {
                return 0.65;
            }
            return 0.25;
        }

        function getLineScore(points) {
            if (points.length < 3) return 0;
            const start = points[0];
            const end = points[points.length - 1];
            const lineLen = distance(start, end);
            if (lineLen < 30) return 0;

            let totalDev = 0;
            points.forEach(p => {
                const t = Math.max(0, Math.min(1,
                    ((p.x - start.x) * (end.x - start.x) + (p.y - start.y) * (end.y - start.y)) / (lineLen * lineLen)
                ));
                const proj = { x: start.x + t * (end.x - start.x), y: start.y + t * (end.y - start.y) };
                totalDev += distance(p, proj);
            });
            return Math.max(0, 1 - (totalDev / points.length) / (lineLen * 0.1));
        }

        function detectArrowHead(points) {
            if (points.length < 10) return false;
            const last10 = points.slice(-10);
            const end = points[points.length - 1];
            const beforeEnd = points[Math.max(0, points.length - 8)];
            const mainDir = Math.atan2(end.y - beforeEnd.y, end.x - beforeEnd.x);

            // Check for splaying at end
            let hasSplay = false;
            for (let i = 1; i < last10.length - 1; i++) {
                const dir = Math.atan2(last10[i].y - end.y, last10[i].x - end.x);
                const diff = Math.abs(dir - mainDir);
                if (diff > 0.4 && diff < 2.7) hasSplay = true;
            }
            return hasSplay;
        }

        // ============================================
        // Shape Detection
        // ============================================
        function detectShape(points) {
            if (points.length < 5) return null;

            const bounds = getBounds(points);
            const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const size = Math.max(width, height);

            if (size < 20) return null; // Too small

            // Check if closed (start near end)
            const start = points[0];
            const end = points[points.length - 1];
            const closedThreshold = size * 0.25;
            const isClosed = distance(start, end) < closedThreshold;

            if (isClosed) {
                // Analyze closed shape
                const circleScore = getCircleScore(points, center, size / 2);
                const rectScore = getRectScore(points, bounds);
                const triScore = getTriangleScore(points, bounds);

                if (circleScore > 0.7 && circleScore > rectScore && circleScore > triScore) {
                    return { type: 'circle', center, radius: size / 2, confidence: circleScore };
                }
                if (rectScore > 0.6 && rectScore > triScore) {
                    return { type: 'rectangle', bounds, center, confidence: rectScore };
                }
                if (triScore > 0.5) {
                    return { type: 'triangle', bounds, center, confidence: triScore };
                }
            } else {
                // Open shape - line or arrow
                const lineScore = getLineScore(points);
                if (lineScore > 0.7) {
                    const hasArrow = detectArrowHead(points);
                    return {
                        type: hasArrow ? 'arrow' : 'line',
                        start, end, center,
                        confidence: lineScore
                    };
                }
            }

            return null;
        }

        // ============================================
        // Stroke → Entity Classification
        // ============================================

        // Check if two line segments intersect, return intersection point
        function segmentsIntersect(p1, p2, p3, p4, returnPoint = false) {
            const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (Math.abs(d) < 0.001) return returnPoint ? null : false;
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / d;
            if (t > 0 && t < 1 && u > 0 && u < 1) {
                if (returnPoint) {
                    return {
                        x: p1.x + t * (p2.x - p1.x),
                        y: p1.y + t * (p2.y - p1.y)
                    };
                }
                return true;
            }
            return returnPoint ? null : false;
        }

        // Detect self-intersection and find loop center (fish body pivot)
        // Returns { loopCenter, loopStart, loopEnd, intersectionPoint } or null
        function findSelfIntersectionLoop(points) {
            if (points.length < 15) return null;

            const step = Math.max(1, Math.floor(points.length / 50));

            for (let i = 0; i < points.length - step * 4; i += step) {
                const a1 = points[i];
                const a2 = points[Math.min(i + step, points.length - 1)];

                for (let j = i + step * 3; j < points.length - step; j += step) {
                    const b1 = points[j];
                    const b2 = points[Math.min(j + step, points.length - 1)];

                    const intersection = segmentsIntersect(a1, a2, b1, b2, true);
                    if (intersection) {
                        // Found intersection - extract the loop (points between i and j)
                        const loopPoints = points.slice(i, j + 1);

                        // Check loop is curved (not sharp angular)
                        // Measure curvature by checking angle changes
                        let totalAngleChange = 0;
                        const sampleStep = Math.max(1, Math.floor(loopPoints.length / 10));
                        for (let k = sampleStep; k < loopPoints.length - sampleStep; k += sampleStep) {
                            const prev = loopPoints[k - sampleStep];
                            const curr = loopPoints[k];
                            const next = loopPoints[Math.min(k + sampleStep, loopPoints.length - 1)];
                            const a1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                            const a2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                            let diff = Math.abs(a2 - a1);
                            if (diff > Math.PI) diff = 2 * Math.PI - diff;
                            totalAngleChange += diff;
                        }

                        // Reject if too angular (sharp corners)
                        const avgAngleChange = totalAngleChange / (loopPoints.length / sampleStep);
                        if (avgAngleChange > 0.8) continue; // Too sharp, not a curved loop

                        // Calculate loop centroid (fish body center)
                        let cx = 0, cy = 0;
                        loopPoints.forEach(p => { cx += p.x; cy += p.y; });
                        cx /= loopPoints.length;
                        cy /= loopPoints.length;

                        // Check loop has decent size
                        const loopBounds = getBounds(loopPoints);
                        const loopSize = Math.max(loopBounds.maxX - loopBounds.minX, loopBounds.maxY - loopBounds.minY);
                        if (loopSize < 25) continue; // Loop too small

                        return {
                            loopCenter: { x: cx, y: cy },
                            loopStart: i,
                            loopEnd: j,
                            intersectionPoint: intersection,
                            loopSize: loopSize
                        };
                    }
                }
            }
            return null;
        }

        // Simple boolean check for backwards compatibility
        function hasSelfIntersection(points) {
            return findSelfIntersectionLoop(points) !== null;
        }

        // Generate jellyfish replacement art (bell + flowing tentacles)
        // Generate jellyfish with bell and separate tentacle data for animation
        function generateJellyfishShape(size) {
            const r = size * 0.35;
            const numTentacles = 5 + Math.floor(Math.random() * 3);
            const tentacleLength = 4 + Math.floor(Math.random() * 3);

            return {
                bellRadius: r,
                bellHeight: r * 0.6,
                numTentacles: numTentacles,
                tentacleLength: tentacleLength,
                // Random variation per jellyfish
                tentacleSpacing: 0.7 + Math.random() * 0.3,
                wobbleOffset: Math.random() * Math.PI * 2,
                pulseOffset: Math.random() * Math.PI * 2
            };
        }

        // Generate coral - simplified for performance
        function generateCoralShape(size, bounds) {
            const width = bounds ? (bounds.maxX - bounds.minX) : size;
            const height = bounds ? (bounds.maxY - bounds.minY) : size * 0.8;

            // Fewer stalks for better performance
            const numStalks = Math.max(2, Math.min(6, Math.floor(width / 25)));
            const stalks = [];

            for (let s = 0; s < numStalks; s++) {
                const xPos = -width / 2 + (s + 0.5) * (width / numStalks);
                const stalkHeight = height * (0.5 + Math.random() * 0.4);

                // 2-3 branches per stalk
                const numBranches = 2 + Math.floor(Math.random() * 2);

                stalks.push({
                    x: xPos + (Math.random() - 0.5) * 6,
                    height: stalkHeight,
                    branches: []
                });

                for (let b = 0; b < numBranches; b++) {
                    const branchY = stalkHeight * (0.3 + (b / numBranches) * 0.5);
                    const branchDir = (b % 2 === 0) ? -1 : 1;
                    const branchLen = 8 + Math.random() * 15;
                    const branchAngle = (0.3 + Math.random() * 0.4) * branchDir;

                    stalks[s].branches.push({
                        y: branchY,
                        angle: branchAngle,
                        length: branchLen,
                        hasTip: Math.random() > 0.3
                    });
                }
            }

            return {
                width: width,
                height: height,
                stalks: stalks,
                swayOffset: Math.random() * Math.PI * 2
            };
        }

        // Generate fish shape - proper fish outline with body and tail integrated
        function generateFishShape(loopInfo, originalPoints, size) {
            // Get loop dimensions
            const loopPoints = originalPoints.slice(loopInfo.loopStart, loopInfo.loopEnd + 1);
            const loopBounds = getBounds(loopPoints);
            const loopWidth = loopBounds.maxX - loopBounds.minX;
            const loopHeight = loopBounds.maxY - loopBounds.minY;

            // Fish dimensions based on drawn loop
            const bodyLen = Math.max(loopWidth, loopHeight) * 0.45;
            const bodyH = Math.min(loopWidth, loopHeight) * 0.35;
            const tailLen = bodyLen * 0.6;
            const tailSpread = bodyH * 0.9;

            // Calculate orientation from stroke
            const headDir = Math.atan2(
                loopInfo.intersectionPoint.y - loopInfo.loopCenter.y,
                loopInfo.intersectionPoint.x - loopInfo.loopCenter.x
            );

            // Create proper fish outline (head at +X, tail at -X)
            // Top edge: head -> body curve -> tail
            const pts = [];

            // Head point (nose)
            pts.push({ x: bodyLen, y: 0 });

            // Top body curve
            pts.push({ x: bodyLen * 0.7, y: -bodyH * 0.5 });
            pts.push({ x: bodyLen * 0.3, y: -bodyH * 0.8 });
            pts.push({ x: -bodyLen * 0.2, y: -bodyH * 0.6 });

            // Tail top
            pts.push({ x: -bodyLen * 0.5, y: -bodyH * 0.3 });
            pts.push({ x: -bodyLen * 0.5 - tailLen, y: -tailSpread });

            // Tail center notch
            pts.push({ x: -bodyLen * 0.5 - tailLen * 0.5, y: 0 });

            // Tail bottom
            pts.push({ x: -bodyLen * 0.5 - tailLen, y: tailSpread });
            pts.push({ x: -bodyLen * 0.5, y: bodyH * 0.3 });

            // Bottom body curve
            pts.push({ x: -bodyLen * 0.2, y: bodyH * 0.6 });
            pts.push({ x: bodyLen * 0.3, y: bodyH * 0.8 });
            pts.push({ x: bodyLen * 0.7, y: bodyH * 0.5 });

            // Back to head
            pts.push({ x: bodyLen, y: 0 });

            return {
                points: pts,
                initialHeading: headDir,
                bodyWidth: bodyLen,
                bodyHeight: bodyH
            };
        }

        // Shape classification - matches design.html detectShape() exactly, plus fish
        function classifyStroke(points) {
            if (!points || points.length === 0) return null;

            // Tiny tap/dot → food (before other checks)
            if (points.length < 8) {
                const bounds = getBounds(points);
                const size = Math.max(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
                if (size < 25) {
                    const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
                    return { type: 'food', center, size, points };
                }
            }

            if (points.length < 5) return null;

            const bounds = getBounds(points);
            const center = { x: (bounds.minX + bounds.maxX) / 2, y: (bounds.minY + bounds.maxY) / 2 };
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const size = Math.max(width, height);

            if (size < 20) return null; // Too small

            // Check if closed (start near end) - exact design.html logic
            const start = points[0];
            const end = points[points.length - 1];
            const closedThreshold = size * 0.25;
            const isClosed = distance(start, end) < closedThreshold;

            if (isClosed) {
                // Analyze closed shape - exact design.html scoring and comparison
                const circleScore = getCircleScore(points, center, size / 2);
                const rectScore = getRectScore(points, bounds);
                const triScore = getTriangleScore(points, bounds);

                // Circle → bubble (must beat both others)
                if (circleScore > 0.7 && circleScore > rectScore && circleScore > triScore) {
                    return { type: 'bubble', center, radius: size / 2, size, points };
                }
                // Rectangle → coral (must beat triangle)
                if (rectScore > 0.6 && rectScore > triScore) {
                    const coralShape = generateCoralShape(size, bounds);
                    return { type: 'coral', center, size, bounds, shape: coralShape };
                }
                // Triangle → jellyfish
                if (triScore > 0.5) {
                    const jellyShape = generateJellyfishShape(size);
                    return { type: 'jellyfish', center, size, bounds, shape: jellyShape };
                }
                // Unrecognized closed shape → no entity
                return null;
            }

            // OPEN STROKES - check for self-intersecting fish shape (ichthys)
            // This is the ONE new shape type we add to design.html's logic
            const loopInfo = findSelfIntersectionLoop(points);
            if (loopInfo && loopInfo.loopSize > 25) {
                const fishShape = generateFishShape(loopInfo, points, size);
                return {
                    type: 'fish',
                    center: loopInfo.loopCenter,
                    size: loopInfo.loopSize,
                    fishShape: fishShape,  // Contains points, initialHeading, bodyWidth, bodyHeight
                    loopInfo: loopInfo
                };
            }

            // Open stroke → temporary line (for bubble-popping)
            return { type: 'line', center, size, points, start, end };
        }

        // ============================================
        // Canvas Setup
        // ============================================
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ============================================
        // Drawing Functions
        // ============================================
        function drawGrid() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, w, h);
        }
        
        
        function drawRawStrokes() {
            const now = Date.now();
            
            strokes = strokes.filter(stroke => {
                const age = now - stroke.startTime;
                if (age > stroke.fadeStart + TIMING.strokeFade) return false;
                
                let opacity = 1;
                if (age > stroke.fadeStart) {
                    opacity = 1 - ((age - stroke.fadeStart) / TIMING.strokeFade);
                }
                // Ease out for smoother fade
                const easedOpacity = opacity * opacity;
                
                if (stroke.points.length < 2) return true;
                
                ctx.shadowColor = colors.glow;
                ctx.shadowBlur = 12 * easedOpacity;
                ctx.strokeStyle = `rgba(147, 197, 253, ${0.85 * easedOpacity})`;
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    const p0 = stroke.points[i - 1];
                    const p1 = stroke.points[i];
                    ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                return true;
            });
        }

        // ============================================
        // Entity Rendering
        // ============================================
        function drawFishEntities() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            // Physics constants - tuned for smooth movement
            const DETECT_RANGE = 400;
            const EAT_RANGE = 18;
            const SEEK_SPEED = 1.2;
            const IDLE_SPEED = 0.4;
            const TURN_RATE = 0.03;         // Slower turning for smoother motion
            const MAX_TURN_PER_FRAME = 0.08; // Cap heading change per frame
            const EDGE_MARGIN = 50;
            const EDGE_FORCE = 0.1;

            // Boids - separation is critical to prevent overlap
            const BOID_SEP_RANGE = 100;      // Larger separation range
            const BOID_ALIGN_RANGE = 180;
            const BOID_COHESION_RANGE = 280;

            // Size-based behavior thresholds
            const SMALL_FISH_SIZE = 50;    // Below this = "small" fish

            fish.forEach((f, fi) => {
                const pts = f.points;
                if (pts.length < 2) return;

                // Per-fish unique color using hue shift
                const baseColor = aquaColors.fish[f.id % aquaColors.fish.length];
                const hueShift = f.hueShift || 0;
                // Apply hue shift by rotating through color spectrum
                const hsl = `hsl(${(180 + hueShift) % 360}, 80%, 65%)`;
                const color = hueShift ? hsl : baseColor;

                // Per-fish randomness offset (consistent per fish)
                const fishRand = (f.id * 0.618) % 1;

                // ---- Fish AI: seek visible food (not inside bubbles) ----
                let nearestFood = null;
                let nearestDist = Infinity;
                food.forEach(fd => {
                    if (isFoodInBubble(fd.x, fd.y)) return;
                    const d = Math.sqrt((f.x - fd.x) ** 2 + (f.y - fd.y) ** 2);
                    if (d < nearestDist) { nearestDist = d; nearestFood = fd; }
                });

                if (nearestFood && nearestDist < DETECT_RANGE) {
                    f.state = 'seeking';
                    f.targetHeading = Math.atan2(nearestFood.y - f.y, nearestFood.x - f.x);
                    // Add slight wobble to avoid all fish converging on same point
                    f.targetHeading += (fishRand - 0.5) * 0.3;

                    // Eat food on proximity
                    if (nearestDist < EAT_RANGE) {
                        const idx = food.indexOf(nearestFood);
                        if (idx !== -1) {
                            food.splice(idx, 1);
                            for (let i = 0; i < 5; i++) {
                                const a = (i / 5) * Math.PI * 2;
                                particles.push({
                                    x: nearestFood.x, y: nearestFood.y,
                                    vx: Math.cos(a) * 0.8, vy: Math.sin(a) * 0.8,
                                    life: 1, createdAt: now
                                });
                            }
                        }
                        f.state = 'idle';
                    }
                } else {
                    f.state = 'idle';
                    const isSmallFish = f.size < SMALL_FISH_SIZE;

                    // Size-based behavior
                    if (isSmallFish) {
                        // Small fish: cluster near coral at bottom
                        let nearestCoral = null;
                        let coralDist = Infinity;
                        coral.forEach(c => {
                            if (!c.settled) return;
                            const d = Math.sqrt((f.x - c.x) ** 2 + (f.y - c.y) ** 2);
                            if (d < coralDist) { coralDist = d; nearestCoral = c; }
                        });

                        if (nearestCoral && coralDist > 40 && coralDist < 300) {
                            // Gently drift toward coral, orbit above it
                            const coralAngle = Math.atan2(nearestCoral.y - 60 - f.y, nearestCoral.x - f.x);
                            f.targetHeading += angleDiff(coralAngle, f.heading) * 0.02;
                        }

                        // Small gentle wander
                        f.targetHeading += (Math.random() - 0.5) * 0.08;
                    } else {
                        // Big fish: school up in upper area
                        // Prefer upper third of tank
                        const preferredY = h * 0.35;
                        if (f.y > preferredY) {
                            f.targetHeading += angleDiff(-Math.PI / 2, f.heading) * 0.03;
                        }

                        // Gentle random wander
                        f.targetHeading += (Math.random() - 0.5) * 0.12;

                        // Occasional larger direction change
                        if (Math.random() < 0.005) {
                            f.targetHeading += (Math.random() - 0.5) * Math.PI * 0.4;
                        }
                    }
                }

                // ---- Boids: smooth velocity-based separation, size-dependent schooling ----
                const isSmallFish = f.size < SMALL_FISH_SIZE;
                let sepX = 0, sepY = 0;
                let alignVx = 0, alignVy = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohCount = 0;

                fish.forEach((other, oi) => {
                    if (oi === fi) return;
                    const dx = f.x - other.x;
                    const dy = f.y - other.y;
                    const d = Math.sqrt(dx * dx + dy * dy);

                    // Separation - always active, uses velocity push not heading
                    if (d < BOID_SEP_RANGE && d > 0) {
                        const strength = 1 - (d / BOID_SEP_RANGE);
                        sepX += (dx / d) * strength;
                        sepY += (dy / d) * strength;
                    }

                    // Alignment and cohesion - only for big fish schooling
                    if (!isSmallFish && other.size >= SMALL_FISH_SIZE) {
                        if (d < BOID_ALIGN_RANGE && d > BOID_SEP_RANGE) {
                            alignVx += other.vx;
                            alignVy += other.vy;
                            alignCount++;
                        }
                        if (d < BOID_COHESION_RANGE && d > BOID_SEP_RANGE) {
                            cohX += other.x;
                            cohY += other.y;
                            cohCount++;
                        }
                    }
                });

                // Apply separation as direct velocity push - stronger when closer
                if (sepX !== 0 || sepY !== 0) {
                    const sepMag = Math.sqrt(sepX * sepX + sepY * sepY);
                    // Scale force by accumulated separation (stronger when many/close neighbors)
                    const sepForce = Math.min(0.5, sepMag * 0.3);
                    f.vx += (sepX / sepMag) * sepForce;
                    f.vy += (sepY / sepMag) * sepForce;
                }

                // Apply alignment for big fish
                if (alignCount > 0) {
                    const avgAngle = Math.atan2(alignVy / alignCount, alignVx / alignCount);
                    f.targetHeading += angleDiff(avgAngle, f.heading) * 0.015;
                }

                // Apply cohesion for big fish (gentle pull toward school center)
                if (cohCount > 0) {
                    const centerX = cohX / cohCount;
                    const centerY = cohY / cohCount;
                    const cohAngle = Math.atan2(centerY - f.y, centerX - f.x);
                    f.targetHeading += angleDiff(cohAngle, f.heading) * 0.008;
                }

                // ---- Jellyfish avoidance ----
                const JELLY_AVOID_RANGE = 80;
                const JELLY_AVOID_FORCE = 0.2;
                jellyfish.forEach(j => {
                    if (!j.shape) return;
                    const dx = f.x - j.x;
                    const dy = f.y - j.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = JELLY_AVOID_RANGE + j.shape.bellRadius;
                    if (dist < minDist && dist > 0) {
                        const avoidAngle = Math.atan2(dy, dx);
                        const strength = (minDist - dist) / minDist;
                        f.targetHeading += angleDiff(avoidAngle, f.heading) * JELLY_AVOID_FORCE * strength;
                    }
                });

                // ---- Soft edge avoidance ----
                let avoidX = 0, avoidY = 0;
                if (f.x < EDGE_MARGIN) avoidX = (EDGE_MARGIN - f.x) / EDGE_MARGIN;
                if (f.x > w - EDGE_MARGIN) avoidX = -(f.x - (w - EDGE_MARGIN)) / EDGE_MARGIN;
                if (f.y < EDGE_MARGIN) avoidY = (EDGE_MARGIN - f.y) / EDGE_MARGIN;
                if (f.y > h - EDGE_MARGIN) avoidY = -(f.y - (h - EDGE_MARGIN)) / EDGE_MARGIN;

                if (avoidX !== 0 || avoidY !== 0) {
                    const avoidAngle = Math.atan2(avoidY, avoidX);
                    f.targetHeading += angleDiff(avoidAngle, f.heading) * EDGE_FORCE;
                }

                // ---- Smooth heading interpolation with capped turn rate ----
                let headingDelta = angleDiff(f.targetHeading, f.heading) * TURN_RATE;
                // Cap maximum turn per frame to prevent jittery oscillation
                headingDelta = Math.max(-MAX_TURN_PER_FRAME, Math.min(MAX_TURN_PER_FRAME, headingDelta));
                f.heading += headingDelta;

                // ---- Apply velocity with per-fish speed variation ----
                const speedMult = 0.85 + fishRand * 0.3;
                const speed = (f.state === 'seeking' ? SEEK_SPEED : IDLE_SPEED) * speedMult;
                f.vx = Math.cos(f.heading) * speed;
                f.vy = Math.sin(f.heading) * speed;
                f.x += f.vx;
                f.y += f.vy;

                // Strong edge bounce - prevent getting stuck
                const hardMargin = 30;
                const bounceStrength = 0.25;
                if (f.x < hardMargin) {
                    f.vx += bounceStrength;
                    f.x = hardMargin;
                    f.targetHeading = Math.PI * 0.1 * (Math.random() - 0.5); // Bounce right
                }
                if (f.x > w - hardMargin) {
                    f.vx -= bounceStrength;
                    f.x = w - hardMargin;
                    f.targetHeading = Math.PI + Math.PI * 0.1 * (Math.random() - 0.5); // Bounce left
                }
                if (f.y < hardMargin) {
                    f.vy += bounceStrength;
                    f.y = hardMargin;
                    f.targetHeading = Math.PI * 0.5 + Math.PI * 0.1 * (Math.random() - 0.5); // Bounce down
                }
                if (f.y > h - hardMargin - 20) {
                    f.vy -= bounceStrength * 1.5; // Extra strong floor bounce
                    f.y = h - hardMargin - 20;
                    f.targetHeading = -Math.PI * 0.5 + Math.PI * 0.1 * (Math.random() - 0.5); // Bounce up
                }

                // ---- Render (normalized points, centered at origin) ----
                const wiggleSpeed = f.state === 'seeking' ? 120 : 200;
                const wiggleAmt = f.state === 'seeking' ? 5 : 3;
                const wiggle = Math.sin(now / wiggleSpeed + f.id) * wiggleAmt;

                // Apply per-fish scale variation
                const scaleX = f.scaleX || 1;
                const scaleY = f.scaleY || 1;

                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.heading);
                ctx.scale(scaleX, scaleY);

                ctx.strokeStyle = color;
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalAlpha = 0.9;

                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                for (let i = 1; i < pts.length; i++) {
                    const t = i / pts.length;
                    const wg = wiggle * Math.sin(t * Math.PI);
                    const p0 = pts[i - 1];
                    const p1 = pts[i];
                    ctx.quadraticCurveTo(
                        p0.x + wg, p0.y,
                        (p0.x + p1.x) / 2 + wg, (p0.y + p1.y) / 2
                    );
                }
                ctx.stroke();

                // Subtle fill
                ctx.globalAlpha = 0.15;
                ctx.fillStyle = color;
                ctx.fill();

                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }

        function drawCoralEntities() {
            const now = Date.now();
            const canvasW = canvas.width / (window.devicePixelRatio || 1);
            const canvasH = canvas.height / (window.devicePixelRatio || 1);

            coral.forEach((c, ci) => {
                if (!c.shape) return;

                const shape = c.shape;
                const color = aquaColors.coral[c.id % aquaColors.coral.length];
                const altColor = aquaColors.coral[(c.id + 1) % aquaColors.coral.length];

                // Sink to bottom with space-filling behavior
                if (!c.settled) {
                    const targetY = canvasH - 5;
                    c.y += 1.8; // Sink speed

                    // Space-filling: push away from other coral while sinking
                    coral.forEach((other, oi) => {
                        if (oi === ci) return;
                        const dx = c.x - other.x;
                        const dist = Math.abs(dx);
                        const minDist = (shape.width + (other.shape?.width || 50)) * 0.5 + 20;

                        if (dist < minDist) {
                            // Push apart horizontally
                            const push = (minDist - dist) * 0.05 * (dx > 0 ? 1 : -1);
                            c.x += push;
                        }
                    });

                    // Keep in horizontal bounds
                    const margin = shape.width * 0.5 + 20;
                    if (c.x < margin) c.x = margin;
                    if (c.x > canvasW - margin) c.x = canvasW - margin;

                    // Gentle drift while sinking
                    c.x += Math.sin(now / 1500 + c.id) * 0.15;

                    if (c.y >= targetY) {
                        c.y = targetY;
                        c.settled = true;
                    }
                }

                // Gentle sway - each stalk sways slightly different
                const baseSway = Math.sin(now / 3500 + shape.swayOffset) * (c.settled ? 2.5 : 0.5);

                ctx.save();
                ctx.translate(c.x + baseSway, c.y);

                // Draw each stalk with branches
                shape.stalks.forEach((stalk, si) => {
                    const stalkSway = Math.sin(now / 2800 + si * 0.7 + shape.swayOffset) * 1.8;
                    const stalkX = stalk.x + stalkSway;

                    // Alternate colors between stalks with variation
                    const stalkColor = si % 3 === 0 ? color : (si % 3 === 1 ? altColor : color);

                    ctx.strokeStyle = stalkColor;
                    // Thicker stalks based on stalk.width property
                    ctx.lineWidth = stalk.width || 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.globalAlpha = 0.85;

                    // Draw main stalk (growing upward, so negative Y)
                    ctx.beginPath();
                    ctx.moveTo(stalkX, 0);

                    // Curved stalk with more character
                    const curveMid = -stalk.height * 0.5;
                    const curveAmt = stalkSway * 1.2 + (si % 2 === 0 ? 3 : -3);
                    ctx.quadraticCurveTo(
                        stalkX + curveAmt, curveMid,
                        stalkX + stalkSway * 0.4, -stalk.height
                    );
                    ctx.stroke();

                    // Draw tip bulb (larger, more visible)
                    ctx.globalAlpha = 0.7;
                    const tipSize = 4 + (stalk.width || 2);
                    ctx.beginPath();
                    ctx.arc(stalkX + stalkSway * 0.4, -stalk.height - tipSize * 0.5, tipSize, 0, Math.PI * 2);
                    ctx.fillStyle = stalkColor;
                    ctx.fill();

                    // Draw branches with sub-branches
                    ctx.globalAlpha = 0.8;
                    stalk.branches.forEach((branch, bi) => {
                        const branchSway = Math.sin(now / 2200 + bi * 1.1 + shape.swayOffset) * 1.2;
                        ctx.lineWidth = branch.width || 2;

                        // Branch starts from stalk at given Y position
                        const branchStartY = -branch.y;
                        const branchStartX = stalkX + (branchStartY / -stalk.height) * stalkSway * 0.4;

                        // Branch end position
                        const branchEndX = branchStartX + Math.sin(branch.angle) * branch.length + branchSway;
                        const branchEndY = branchStartY - Math.cos(branch.angle) * branch.length * 0.85;

                        ctx.beginPath();
                        ctx.moveTo(branchStartX, branchStartY);
                        ctx.lineTo(branchEndX, branchEndY);
                        ctx.stroke();

                        // Branch tip
                        if (branch.hasTip) {
                            ctx.globalAlpha = 0.6;
                            const tipSize = 3 + (branch.width || 2) * 0.5;
                            ctx.beginPath();
                            ctx.arc(branchEndX, branchEndY - tipSize * 0.3, tipSize, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 0.8;
                        }
                    });
                });

                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }

        function drawJellyfishEntities() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);

            jellyfish.forEach(j => {
                if (!j.shape) return;

                const color = aquaColors.jellyfish[j.id % aquaColors.jellyfish.length];
                const shape = j.shape;

                // Gentle figure-8 drift pattern
                j.orbitAngle += j.orbitSpeed * 0.4;

                const phaseOffset = j.id * 2.5;
                const currentAngle = j.orbitAngle + phaseOffset;

                // Drift path
                const centerX = w * 0.5;
                const centerY = h * 0.45;
                const radiusX = w * 0.28;
                const radiusY = h * 0.18;

                const targetX = centerX + Math.sin(currentAngle) * radiusX;
                const targetY = centerY + Math.sin(currentAngle * 2) * radiusY;

                // Very gentle, capped attraction - no erratic movement
                const dx = targetX - j.x;
                const dy = targetY - j.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Constant gentle force, capped acceleration
                const maxAccel = 0.008;
                if (dist > 10) {
                    const accel = Math.min(maxAccel, dist * 0.00008);
                    j.vx += (dx / dist) * accel;
                    j.vy += (dy / dist) * accel;
                }

                // Strong damping for smooth movement
                j.vx *= 0.96;
                j.vy *= 0.96;

                // Cap max velocity
                const maxSpeed = 0.8;
                const speed = Math.sqrt(j.vx * j.vx + j.vy * j.vy);
                if (speed > maxSpeed) {
                    j.vx = (j.vx / speed) * maxSpeed;
                    j.vy = (j.vy / speed) * maxSpeed;
                }

                // Gentle minimum drift
                const minSpeed = 0.1;
                if (speed < minSpeed && speed > 0) {
                    j.vx = (j.vx / speed) * minSpeed;
                    j.vy = (j.vy / speed) * minSpeed;
                } else if (speed === 0) {
                    // Kick-start if completely stopped
                    const kickAngle = currentAngle;
                    j.vx = Math.cos(kickAngle) * minSpeed;
                    j.vy = Math.sin(kickAngle) * minSpeed;
                }

                // Avoid other jellyfish
                jellyfish.forEach(other => {
                    if (other.id === j.id || !other.shape) return;
                    const dx = j.x - other.x;
                    const dy = j.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = shape.bellRadius + other.shape.bellRadius + 40;
                    if (dist < minDist && dist > 0) {
                        const pushForce = 0.02 * (minDist - dist) / minDist;
                        j.vx += (dx / dist) * pushForce;
                        j.vy += (dy / dist) * pushForce;
                    }
                });

                // Avoid fish
                fish.forEach(f => {
                    const dx = j.x - f.x;
                    const dy = j.y - f.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = shape.bellRadius + f.size * 0.5 + 30;
                    if (dist < minDist && dist > 0) {
                        const pushForce = 0.015 * (minDist - dist) / minDist;
                        j.vx += (dx / dist) * pushForce;
                        j.vy += (dy / dist) * pushForce;
                    }
                });

                // Pumping propulsion - slower, gentler pulse
                const pulsePhase = (now * 0.0015 + j.pulsePhase) % (Math.PI * 2); // Slower pulse
                const isPulsing = pulsePhase < 0.5;
                if (isPulsing && pulsePhase > 0.1) {
                    j.vy -= 0.008; // Gentler upward thrust
                }

                j.x += j.vx;
                j.y += j.vy;

                // Strong edge avoidance - bounce off walls
                const margin = 50;
                const bounceForce = 0.08;
                if (j.x < margin) { j.vx += bounceForce; j.x = margin; }
                if (j.x > w - margin) { j.vx -= bounceForce; j.x = w - margin; }
                if (j.y < margin) { j.vy += bounceForce; j.y = margin; }
                if (j.y > h - margin - 30) { j.vy -= bounceForce * 1.5; j.y = h - margin - 30; }

                // Pulse animation for bell
                const pulse = Math.sin(pulsePhase);
                const bellSquash = 1 - pulse * 0.15;
                const bellStretch = 1 + pulse * 0.1;

                // Render jellyfish
                ctx.save();
                ctx.translate(j.x, j.y);

                const r = shape.bellRadius;
                const bellH = shape.bellHeight;

                // Draw bell (dome shape)
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.85;

                ctx.beginPath();
                ctx.ellipse(0, 0, r * bellSquash, bellH * bellStretch, 0, Math.PI, 0);
                ctx.stroke();

                // Bell fill
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = color;
                ctx.fill();

                // Inner bell detail
                ctx.globalAlpha = 0.35;
                ctx.beginPath();
                ctx.ellipse(0, bellH * 0.1, r * 0.5 * bellSquash, bellH * 0.4 * bellStretch, 0, Math.PI, 0);
                ctx.stroke();

                // Draw trailing tentacles
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.65;

                const tentacleTime = now * 0.002 + shape.wobbleOffset;
                for (let t = 0; t < shape.numTentacles; t++) {
                    const tx = -r * 0.8 + (t / (shape.numTentacles - 1)) * r * 1.6;

                    ctx.beginPath();
                    ctx.moveTo(tx * bellSquash, bellH * 0.05);

                    // Draw wavy tentacle trailing down
                    for (let s = 1; s <= shape.tentacleLength; s++) {
                        const segY = bellH * 0.05 + s * (r * 0.4);
                        const wave = Math.sin(tentacleTime + t * 0.7 + s * 0.5) * (8 + s * 2);
                        const drift = Math.sin(tentacleTime * 0.5 + t) * 3;
                        ctx.lineTo(tx * bellSquash + wave + drift, segY);
                    }
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
                ctx.restore();
            });
        }

        function drawBubbleEntities() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);

            // Helper to spawn pop particles
            function popBubble(b) {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    particles.push({
                        x: b.x, y: b.y,
                        vx: Math.cos(angle) * 1.5,
                        vy: Math.sin(angle) * 1.5 - 0.8,
                        life: 1, createdAt: now
                    });
                }
            }

            bubbles = bubbles.filter((b, bi) => {
                // Initialize variety properties if not set
                if (b.wobbleSpeed === undefined) {
                    b.wobbleSpeed = 300 + Math.random() * 400;
                    b.wobbleAmt = 0.2 + Math.random() * 0.4;
                    b.riseSpeed = b.vy || (0.4 + Math.random() * 0.4);
                    b.hueOffset = Math.random() * 30 - 15;
                }

                // Bubble-bubble avoidance
                let avoidX = 0;
                bubbles.forEach((other, oi) => {
                    if (oi === bi) return;
                    const dx = b.x - other.x;
                    const dy = b.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = b.radius + other.radius + 10;
                    if (dist < minDist && dist > 0) {
                        avoidX += (dx / dist) * (minDist - dist) * 0.1;
                    }
                });
                b.x += avoidX;

                // Rise upward with wobble
                b.y -= b.riseSpeed;
                b.x += Math.sin(now / b.wobbleSpeed + b.id) * b.wobbleAmt;

                // Slight horizontal drift
                b.x += Math.sin(now / 2000 + b.id * 0.3) * 0.15;

                // Keep in bounds horizontally
                if (b.x < b.radius + 10) b.x = b.radius + 10;
                if (b.x > w - b.radius - 10) b.x = w - b.radius - 10;

                // Pop when reaching top
                if (b.y + b.radius < -10) {
                    popBubble(b);
                    return false;
                }

                // Check collision with fish
                for (const f of fish) {
                    const dx = b.x - f.x;
                    const dy = b.y - f.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < b.radius + f.size * 0.4) {
                        popBubble(b);
                        return false;
                    }
                }

                // Check collision with jellyfish
                for (const j of jellyfish) {
                    if (!j.shape) continue;
                    const dx = b.x - j.x;
                    const dy = b.y - j.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < b.radius + j.shape.bellRadius * 1.5) {
                        popBubble(b);
                        return false;
                    }
                }

                // Draw bubble with variety
                const hue = 195 + b.hueOffset;
                const bubbleColor = `hsla(${hue}, 70%, 65%, 0.6)`;
                const glowColor = `hsla(${hue}, 70%, 65%, 0.4)`;

                // Subtle squash/stretch as it rises
                const squash = 1 + 0.05 * Math.sin(now / 300 + b.id);

                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.strokeStyle = bubbleColor;
                ctx.lineWidth = 1.5;

                ctx.beginPath();
                ctx.ellipse(b.x, b.y, b.radius * squash, b.radius / squash, 0, 0, Math.PI * 2);
                ctx.stroke();

                // Shine highlight
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.ellipse(
                    b.x - b.radius * 0.25,
                    b.y - b.radius * 0.25,
                    b.radius * 0.2,
                    b.radius * 0.15,
                    -0.4,
                    0, Math.PI * 2
                );
                ctx.fill();

                ctx.globalAlpha = 1;
                ctx.restore();
                return true;
            });
        }

        function drawFoodEntities() {
            const now = Date.now();
            food = food.filter(f => {
                const age = now - f.createdAt;
                if (age > FOOD_LIFETIME) return false;

                // Fade out in last 3 seconds
                let opacity = 1;
                if (age > FOOD_LIFETIME - 3000) {
                    opacity = (FOOD_LIFETIME - age) / 3000;
                }

                ctx.save();
                ctx.shadowColor = aquaColors.food;
                ctx.shadowBlur = 8 * opacity;
                ctx.globalAlpha = opacity;

                // Pulsing dot
                const pulse = 1 + 0.2 * Math.sin(now / 400 + f.id);
                const radius = 4 * pulse;

                ctx.fillStyle = aquaColors.food;
                ctx.beginPath();
                ctx.arc(f.x, f.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Outer glow ring
                ctx.globalAlpha = opacity * 0.3;
                ctx.strokeStyle = aquaColors.food;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(f.x, f.y, radius + 4, 0, Math.PI * 2);
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                ctx.restore();
                return true;
            });
        }

        function drawTempLineEntities() {
            const now = Date.now();
            tempLines = tempLines.filter(ln => {
                const age = now - ln.createdAt;
                if (age > LINE_DURATION) return false;

                const opacity = 1 - (age / LINE_DURATION);
                const pts = ln.points;
                if (pts.length < 2) return true;

                // Line-to-bubble popping: check each segment against bubbles
                const step = Math.max(1, Math.floor(pts.length / 20));
                for (let i = step; i < pts.length; i += step) {
                    const p1 = pts[i - step];
                    const p2 = pts[i];
                    for (let bi = bubbles.length - 1; bi >= 0; bi--) {
                        const b = bubbles[bi];
                        if (segmentIntersectsCircle(p1, p2, b.x, b.y, b.radius)) {
                            for (let j = 0; j < 6; j++) {
                                const a = (j / 6) * Math.PI * 2;
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: Math.cos(a) * 1.2,
                                    vy: Math.sin(a) * 0.5 - 0.5,
                                    life: 1, createdAt: now
                                });
                            }
                            bubbles.splice(bi, 1);
                        }
                    }
                }

                ctx.save();
                ctx.strokeStyle = `rgba(77, 201, 246, ${0.6 * opacity})`;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                for (let i = 1; i < pts.length; i++) {
                    const p0 = pts[i - 1];
                    const p1 = pts[i];
                    ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
                }
                ctx.stroke();
                ctx.restore();
                return true;
            });
        }

        // Cursor with glow
        let cursorPos = { x: -100, y: -100 };
        let cursorVisible = false;
        
        function drawCursor() {
            if (!cursorVisible) return;
            
            const x = cursorPos.x;
            const y = cursorPos.y;
            const size = isDrawing ? 14 : 10;
            
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
            gradient.addColorStop(0, isDrawing ? 'rgba(251, 146, 60, 0.25)' : 'rgba(59, 130, 246, 0.2)');
            gradient.addColorStop(0.5, isDrawing ? 'rgba(251, 146, 60, 0.08)' : 'rgba(59, 130, 246, 0.05)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, 60, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = isDrawing ? colors.cursor : 'rgba(147, 197, 253, 0.7)';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = isDrawing ? colors.cursor : colors.glow;
            ctx.shadowBlur = 8;
            
            ctx.beginPath();
            ctx.moveTo(x - size, y); ctx.lineTo(x - 4, y);
            ctx.moveTo(x + 4, y); ctx.lineTo(x + size, y);
            ctx.moveTo(x, y - size); ctx.lineTo(x, y - 4);
            ctx.moveTo(x, y + 4); ctx.lineTo(x, y + size);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            if (isDrawing) {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = colors.cursor;
                ctx.fill();
            }
        }
        
        // Draw ripple effects (for tap/dot feedback)
        function drawRipples() {
            const now = Date.now();
            const rippleDuration = 600;
            
            ripples = ripples.filter(ripple => {
                const age = now - ripple.createdAt;
                if (age > rippleDuration) return false;
                
                const progress = age / rippleDuration;
                const eased = 1 - Math.pow(1 - progress, 3); // ease out cubic
                const radius = ripple.maxRadius * eased;
                const opacity = 1 - progress;
                
                ctx.strokeStyle = `rgba(96, 165, 250, ${0.6 * opacity})`;
                ctx.lineWidth = 2 * (1 - progress * 0.5);
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Second ring
                if (progress > 0.15) {
                    const innerProgress = (progress - 0.15) / 0.85;
                    const innerRadius = ripple.maxRadius * 0.6 * innerProgress;
                    ctx.strokeStyle = `rgba(147, 197, 253, ${0.4 * (1 - innerProgress)})`;
                    ctx.lineWidth = 1.5 * (1 - innerProgress * 0.5);
                    ctx.beginPath();
                    ctx.arc(ripple.x, ripple.y, innerRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                return true;
            });
        }
        
        // Draw particle burst (for shape recognition feedback)
        function drawParticles() {
            const now = Date.now();
            const particleDuration = 800;
            
            particles = particles.filter(p => {
                const age = now - p.createdAt;
                if (age > particleDuration) return false;
                
                const progress = age / particleDuration;
                const opacity = 1 - progress;
                
                // Update position with slight gravity
                p.x += p.vx;
                p.y += p.vy + progress * 0.5;
                p.vx *= 0.97;
                p.vy *= 0.97;
                
                // Draw crystalline particle - hexagonal shard
                const size = 4 * (1 - progress * 0.5);

                // Gradient from cyan to purple (bioluminescent crystallization)
                const hue = 180 + progress * 100; // cyan to purple transition
                const r = Math.round(0 + progress * 199);
                const g = Math.round(217 - progress * 92);
                const b = 255;

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.createdAt * 0.002); // Subtle rotation based on creation time

                // Hexagonal crystal shard
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.9 * opacity})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const x = Math.cos(angle) * size;
                    const y = Math.sin(angle) * size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();

                ctx.restore();
                
                return true;
            });
        }
        
        // Draw ambient floating particles
        function initAmbientParticles() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            for (let i = 0; i < 15; i++) {
                ambientParticles.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    size: 1 + Math.random() * 2,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }
        initAmbientParticles();

        // Spawn a starter jellyfish to invite interaction
        (function spawnStarterJellyfish() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            const cx = w * 0.35 + Math.random() * w * 0.3;
            const cy = h * 0.35 + Math.random() * h * 0.3;
            const size = 50;

            // Use the new shape structure
            const shape = generateJellyfishShape(size);
            const orbitAngle = Math.random() * Math.PI * 2;

            jellyfish.push({
                id: entityIdCounter++,
                shape: shape,
                x: cx, y: cy,
                size: size,
                vx: 0,
                vy: 0,
                orbitAngle: orbitAngle,
                orbitRadius: 80 + Math.random() * 60,
                orbitSpeed: 0.0003 + Math.random() * 0.0002,
                orbitCenterX: w / 2,
                orbitCenterY: h * 0.4,
                pulsePhase: Math.random() * Math.PI * 2,
                createdAt: Date.now()
            });
        })();

        function drawAmbientParticles() {
            const now = Date.now();
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            ambientParticles.forEach(p => {
                // Drift movement
                p.x += p.vx;
                p.y += p.vy;
                
                // Wrap around edges
                if (p.x < 0) p.x = w;
                if (p.x > w) p.x = 0;
                if (p.y < 0) p.y = h;
                if (p.y > h) p.y = 0;
                
                // Pulsing opacity
                const pulse = 0.15 + 0.1 * Math.sin(now / 2000 + p.phase);
                
                ctx.fillStyle = `rgba(147, 197, 253, ${pulse})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Animation loop - smart pausing when idle
        let animationFrameId = null;
        let isAnimating = false;

        function hasActiveAnimation() {
            return isDrawing ||
                   particles.length > 0 ||
                   ripples.length > 0 ||
                   strokes.length > 0 ||
                   jellyfish.length > 0 ||
                   fish.length > 0 ||
                   coral.length > 0 ||
                   bubbles.length > 0 ||
                   food.length > 0 ||
                   tempLines.length > 0 ||
                   currentStroke !== null;
        }

        function animate() {
            drawGrid();
            drawAmbientParticles();
            drawCoralEntities();
            drawFoodEntities();
            drawFishEntities();
            drawJellyfishEntities();
            drawBubbleEntities();
            drawTempLineEntities();
            drawRawStrokes();
            drawRipples();
            drawParticles();
            drawCursor();

            // Only continue animation if there's something active
            if (hasActiveAnimation()) {
                animationFrameId = requestAnimationFrame(animate);
            } else {
                isAnimating = false;
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (!isAnimating) {
                isAnimating = true;
                animate();
            }
        }

        // Start initial animation
        startAnimation();
        
        // ============================================
        // Event Handlers
        // ============================================
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function startDraw(e) {
            e.preventDefault();
            isDrawing = true;
            hero.classList.add('drawing');
            startAnimation(); // Ensure animation loop is running

            const pos = getPos(e);
            currentStroke = {
                points: [pos],
                startTime: Date.now(),
                fadeStart: TIMING.strokeHold
            };
            strokes.push(currentStroke);
        }
        
        function draw(e) {
            const pos = getPos(e);
            cursorPos = pos;
            cursorVisible = true;
            
            if (!isDrawing || !currentStroke) return;
            e.preventDefault();
            currentStroke.points.push(pos);
        }
        
        function endDraw() {
            if (!currentStroke) {
                isDrawing = false;
                return;
            }

            const points = [...currentStroke.points];
            const classified = classifyStroke(points);

            if (classified) {
                const id = entityIdCounter++;
                const now = Date.now();

                if (classified.type === 'food') {
                    // FIFO: remove oldest if at limit
                    if (food.length >= MAX_FOOD) food.shift();
                    food.push({
                        id,
                        x: classified.center.x,
                        y: classified.center.y,
                        createdAt: now
                    });

                    // Ripple feedback
                    ripples.push({
                        x: classified.center.x,
                        y: classified.center.y,
                        createdAt: now,
                        maxRadius: 30
                    });

                } else if (classified.type === 'bubble') {
                    if (bubbles.length >= MAX_BUBBLES) bubbles.shift();
                    bubbles.push({
                        id,
                        x: classified.center.x,
                        y: classified.center.y,
                        radius: classified.radius,
                        vy: 0.3 + Math.random() * 0.4,
                        createdAt: now
                    });

                } else if (classified.type === 'coral') {
                    if (coral.length >= MAX_CORAL) coral.shift();
                    coral.push({
                        id,
                        shape: classified.shape,
                        x: classified.center.x,
                        y: classified.center.y,
                        size: classified.size,
                        settled: false,
                        createdAt: now
                    });

                } else if (classified.type === 'fish') {
                    if (fish.length >= MAX_FISH) fish.shift();
                    // Use initial heading from stroke orientation
                    const fishShape = classified.fishShape;
                    const heading = fishShape.initialHeading;
                    // Generate unique color hue for each fish
                    const hueShift = (id * 47) % 360;
                    fish.push({
                        id,
                        points: fishShape.points,
                        bodyWidth: fishShape.bodyWidth,
                        bodyHeight: fishShape.bodyHeight,
                        x: classified.center.x,
                        y: classified.center.y,
                        size: classified.size,
                        vx: Math.cos(heading) * 0.4,
                        vy: Math.sin(heading) * 0.4,
                        heading: heading,
                        targetHeading: heading,
                        state: 'idle',
                        hueShift: hueShift,
                        scaleX: 0.9 + Math.random() * 0.2,
                        scaleY: 0.9 + Math.random() * 0.2,
                        createdAt: now
                    });

                } else if (classified.type === 'jellyfish') {
                    if (jellyfish.length >= MAX_JELLYFISH) jellyfish.shift();
                    const w = canvas.width / (window.devicePixelRatio || 1);
                    const h = canvas.height / (window.devicePixelRatio || 1);
                    // Initialize orbit around center of tank
                    const orbitAngle = Math.random() * Math.PI * 2;
                    jellyfish.push({
                        id,
                        shape: classified.shape,
                        x: classified.center.x,
                        y: classified.center.y,
                        size: classified.size,
                        vx: 0,
                        vy: 0,
                        orbitAngle: orbitAngle,
                        orbitRadius: 80 + Math.random() * 60,
                        orbitSpeed: 0.0003 + Math.random() * 0.0002,
                        orbitCenterX: w / 2,
                        orbitCenterY: h * 0.4,
                        pulsePhase: Math.random() * Math.PI * 2,
                        createdAt: now
                    });

                } else if (classified.type === 'line') {
                    tempLines.push({
                        id,
                        points: classified.points,
                        createdAt: now
                    });
                }

                // Particle burst feedback for recognized entity types (not lines)
                if (classified.type !== 'line') {
                    const burstCount = classified.type === 'food' ? 4 : 8;
                    for (let i = 0; i < burstCount; i++) {
                        const angle = (i / burstCount) * Math.PI * 2;
                        particles.push({
                            x: classified.center.x,
                            y: classified.center.y,
                            vx: Math.cos(angle) * (1 + Math.random()),
                            vy: Math.sin(angle) * (1 + Math.random()),
                            life: 1,
                            createdAt: Date.now()
                        });
                    }
                }

                // Hide raw stroke quickly since entity is now rendered
                currentStroke.fadeStart = 0;
                startAnimation();
            }

            isDrawing = false;
            currentStroke = null;
            setTimeout(() => {
                if (!isDrawing) hero.classList.remove('drawing');
            }, 500);
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseleave', () => { endDraw(); cursorVisible = false; });
        canvas.addEventListener('mouseenter', () => { cursorVisible = true; });
        
        canvas.addEventListener('touchstart', startDraw, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', endDraw);
        canvas.addEventListener('touchcancel', endDraw);

        // ============================================
        // Cursor Spotlight Effect
        // ============================================
        const spotlight = document.getElementById('cursorSpotlight');
        let spotlightX = window.innerWidth / 2;
        let spotlightY = window.innerHeight / 2;
        let isSpotlightActive = false;

        function updateSpotlight(x, y) {
            spotlightX = x;
            spotlightY = y;
            const xPercent = (x / window.innerWidth) * 100;
            const yPercent = (y / window.innerHeight) * 100;
            spotlight.style.background = `radial-gradient(600px circle at ${xPercent}% ${yPercent}%, rgba(77, 201, 246, 0.12), rgba(212, 175, 55, 0.06) 40%, transparent 70%)`;
        }

        // Mouse events
        document.addEventListener('mousemove', (e) => {
            if (!isSpotlightActive) {
                spotlight.classList.add('active');
                isSpotlightActive = true;
            }
            updateSpotlight(e.clientX, e.clientY);
        });

        document.addEventListener('mouseleave', () => {
            spotlight.classList.remove('active');
            isSpotlightActive = false;
        });

        // Touch events
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 0) {
                spotlight.classList.add('active');
                isSpotlightActive = true;
                updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                updateSpotlight(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            // Keep spotlight visible for a moment after touch ends
            setTimeout(() => {
                if (!isSpotlightActive) {
                    spotlight.classList.remove('active');
                }
            }, 2000);
        });

        // ============================================
        // Demo Canvas - Interactive Fish Animation
        // ============================================
    </script>
</body>
</html>
