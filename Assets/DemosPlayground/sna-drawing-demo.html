<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Social Network Drawing Demo</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    html, body, #root { margin: 0; padding: 0; height: 100%; width: 100%; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #e8e5e0; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    // --- SNA METRICS ---
    const calculateMetrics = (nodes, edges) => {
      const metrics = {};

      nodes.forEach(node => {
        const connections = edges.filter(e => e.source === node.id || e.target === node.id);
        const degree = connections.length;

        metrics[node.id] = {
          degree,
          centrality: nodes.length > 1 ? degree / (nodes.length - 1) : 0
        };
      });

      // Network-wide metrics
      const totalEdges = edges.length;
      const totalNodes = nodes.length;
      const maxEdges = (totalNodes * (totalNodes - 1)) / 2;
      const density = maxEdges > 0 ? totalEdges / maxEdges : 0;
      const avgDegree = totalNodes > 0 ? (totalEdges * 2) / totalNodes : 0;

      return {
        nodes: metrics,
        network: { density, avgDegree, totalNodes, totalEdges }
      };
    };

    // --- FORCE-DIRECTED LAYOUT ---
    const applyForceLayout = (nodes, edges, canvasWidth = 400, canvasHeight = 320, iterations = 50) => {
      if (nodes.length === 0) return nodes;

      const workingNodes = nodes.map(n => ({ ...n, vx: 0, vy: 0 }));
      const nodeRadius = 28;
      const repulsion = 3000;
      const attraction = 0.01;
      const damping = 0.8;

      for (let iter = 0; iter < iterations; iter++) {
        // Reset forces
        workingNodes.forEach(n => {
          n.fx = 0;
          n.fy = 0;
        });

        // Repulsion between all nodes
        for (let i = 0; i < workingNodes.length; i++) {
          for (let j = i + 1; j < workingNodes.length; j++) {
            const dx = workingNodes[j].x - workingNodes[i].x;
            const dy = workingNodes[j].y - workingNodes[i].y;
            const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
            const force = repulsion / (dist * dist);

            const fx = (dx / dist) * force;
            const fy = (dy / dist) * force;

            workingNodes[i].fx -= fx;
            workingNodes[i].fy -= fy;
            workingNodes[j].fx += fx;
            workingNodes[j].fy += fy;
          }
        }

        // Attraction along edges
        edges.forEach(edge => {
          const source = workingNodes.find(n => n.id === edge.source);
          const target = workingNodes.find(n => n.id === edge.target);
          if (!source || !target) return;

          const dx = target.x - source.x;
          const dy = target.y - source.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          const force = dist * attraction;
          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;

          source.fx += fx;
          source.fy += fy;
          target.fx -= fx;
          target.fy -= fy;
        });

        // Update positions
        workingNodes.forEach(n => {
          n.vx = (n.vx + n.fx) * damping;
          n.vy = (n.vy + n.fy) * damping;
          n.x += n.vx;
          n.y += n.vy;

          // Keep in bounds
          const margin = nodeRadius + 20;
          n.x = Math.max(margin, Math.min(canvasWidth - margin, n.x));
          n.y = Math.max(margin, Math.min(canvasHeight - margin, n.y));
        });
      }

      return workingNodes.map(({ vx, vy, fx, fy, ...n }) => n);
    };

    // --- CORE GRAPH STATE ---
    const useGraph = () => {
      const [nodes, setNodes] = useState([]);
      const [edges, setEdges] = useState([]);

      const addNode = useCallback((node) => {
        setNodes(prev => [...prev, { id: Date.now(), label: '', x: node.x, y: node.y, ...node }]);
      }, []);

      const updateNode = useCallback((id, updates) => {
        setNodes(prev => prev.map(n => n.id === id ? { ...n, ...updates } : n));
      }, []);

      const removeNode = useCallback((id) => {
        setNodes(prev => prev.filter(n => n.id !== id));
        setEdges(prev => prev.filter(e => e.source !== id && e.target !== id));
      }, []);

      const addEdge = useCallback((source, target) => {
        if (source === target) return;
        setEdges(prev => {
          const exists = prev.some(e =>
            (e.source === source && e.target === target) ||
            (e.source === target && e.target === source)
          );
          if (exists) return prev;
          return [...prev, { id: Date.now(), source, target }];
        });
      }, []);

      const removeEdge = useCallback((source, target) => {
        setEdges(prev => prev.filter(e =>
          !((e.source === source && e.target === target) ||
            (e.source === target && e.target === source))
        ));
      }, []);

      const arrangeNodes = useCallback((canvasWidth, canvasHeight) => {
        setNodes(prev => applyForceLayout(prev, edges, canvasWidth, canvasHeight));
      }, [edges]);

      const clearAll = useCallback(() => {
        setNodes([]);
        setEdges([]);
      }, []);

      return { nodes, edges, setNodes, setEdges, addNode, updateNode, removeNode, addEdge, removeEdge, arrangeNodes, clearAll };
    };

    // --- GESTURE RECOGNITION ---
    const analyzeStroke = (points, nodes, nodeRadius) => {
      if (points.length < 8) return { type: 'none' };

      const first = points[0];
      const last = points[points.length - 1];
      const dist = Math.hypot(last.x - first.x, last.y - first.y);

      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      const width = maxX - minX;
      const height = maxY - minY;
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      const avgRadius = (width + height) / 4;

      const isClosed = dist < avgRadius * 0.9;

      // Check for square/rectangle (closed, similar width/height, corners)
      const aspectRatio = width / height;
      const isSquarish = aspectRatio > 0.6 && aspectRatio < 1.4;

      if (isClosed && isSquarish && avgRadius > 12) {
        // Check for corners - calculate path angles
        let corners = 0;
        for (let i = 2; i < points.length - 2; i += 3) {
          const prev = points[i - 2];
          const curr = points[i];
          const next = points[i + 2];

          const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
          const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
          let angleDiff = Math.abs(angle2 - angle1);
          if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;

          if (angleDiff > Math.PI / 3) corners++; // ~60 degrees or more = corner
        }

        if (corners >= 3) {
          const size = Math.max(25, Math.min(40, avgRadius));
          return { type: 'square', x: centerX, y: centerY, size };
        }
      }

      // Check for circle
      const radii = points.map(p => Math.hypot(p.x - centerX, p.y - centerY));
      const avgR = radii.reduce((a, b) => a + b, 0) / radii.length;
      const variance = radii.reduce((a, r) => a + Math.pow(r - avgR, 2), 0) / radii.length;
      const circularity = 1 - Math.min(1, Math.sqrt(variance) / avgR);

      if (isClosed && circularity > 0.45 && avgRadius > 12) {
        return { type: 'circle', x: centerX, y: centerY, radius: Math.max(25, Math.min(40, avgRadius)) };
      }

      // Check for edge
      const hitRadius = nodeRadius + 20;
      const startNode = nodes.find(n => Math.hypot(n.x - first.x, n.y - first.y) < hitRadius);
      const endNode = nodes.find(n => Math.hypot(n.x - last.x, n.y - last.y) < hitRadius);

      if (startNode && endNode && startNode.id !== endNode.id) {
        return { type: 'edge', source: startNode.id, target: endNode.id };
      }

      return { type: 'none' };
    };

    // --- CANVAS COMPONENT ---
    const NetworkCanvas = ({ nodes, edges, onAddNode, onUpdateNode, onRemoveNode, onAddEdge, onCanvasSizeChange }) => {
      const containerRef = useRef(null);
      const canvasRef = useRef(null);
      const [canvasSize, setCanvasSize] = useState({ width: 400, height: 320 });
      const [isDrawing, setIsDrawing] = useState(false);
      const [isDragging, setIsDragging] = useState(false);
      const [dragNodeId, setDragNodeId] = useState(null);
      const [currentStroke, setCurrentStroke] = useState([]);
      const [editingNode, setEditingNode] = useState(null);
      const [inputPos, setInputPos] = useState({ x: 0, y: 0 });
      const [nodeType, setNodeType] = useState('person'); // 'person' or 'concept'
      const inputRef = useRef(null);
      const lastTapRef = useRef(0);

      const nodeRadius = 28;

      useEffect(() => {
        const updateSize = () => {
          if (containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            const newSize = { width: Math.floor(rect.width), height: Math.floor(rect.height) };
            setCanvasSize(newSize);
            onCanvasSizeChange?.(newSize);
          }
        };
        updateSize();
        window.addEventListener('resize', updateSize);
        return () => window.removeEventListener('resize', updateSize);
      }, [onCanvasSizeChange]);
      
      const getCanvasPoint = useCallback((e) => {
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;
        
        if (e.touches && e.touches.length > 0) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else if (e.changedTouches && e.changedTouches.length > 0) {
          clientX = e.changedTouches[0].clientX;
          clientY = e.changedTouches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }
        
        return {
          x: (clientX - rect.left) * (canvas.width / rect.width),
          y: (clientY - rect.top) * (canvas.height / rect.height)
        };
      }, []);
      
      const draw = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#ddd8d2';
        for (let x = 20; x < canvas.width; x += 25) {
          for (let y = 20; y < canvas.height; y += 25) {
            ctx.beginPath();
            ctx.arc(x, y, 1, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        edges.forEach(edge => {
          const source = nodes.find(n => n.id === edge.source);
          const target = nodes.find(n => n.id === edge.target);
          if (source && target) {
            ctx.beginPath();
            ctx.strokeStyle = '#5a7d6d';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.moveTo(source.x, source.y);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
            
            [source, target].forEach(node => {
              const other = node === source ? target : source;
              const angle = Math.atan2(other.y - node.y, other.x - node.x);
              const px = node.x + Math.cos(angle) * nodeRadius;
              const py = node.y + Math.sin(angle) * nodeRadius;
              ctx.beginPath();
              ctx.arc(px, py, 4, 0, Math.PI * 2);
              ctx.fillStyle = '#5a7d6d';
              ctx.fill();
            });
          }
        });
        
        nodes.forEach(node => {
          const isConcept = node.type === 'concept';

          // Shadow
          if (isConcept) {
            ctx.fillStyle = 'rgba(0,0,0,0.08)';
            ctx.fillRect(node.x - nodeRadius + 2, node.y - nodeRadius + 2, nodeRadius * 2, nodeRadius * 2);
          } else {
            ctx.beginPath();
            ctx.arc(node.x + 2, node.y + 2, nodeRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.08)';
            ctx.fill();
          }

          // Node shape
          if (isConcept) {
            ctx.fillStyle = editingNode === node.id ? '#fff' : '#faf8f5';
            ctx.fillRect(node.x - nodeRadius, node.y - nodeRadius, nodeRadius * 2, nodeRadius * 2);
            ctx.strokeStyle = editingNode === node.id ? '#c97856' : '#2d3a35';
            ctx.lineWidth = editingNode === node.id ? 2.5 : 1.5;
            ctx.strokeRect(node.x - nodeRadius, node.y - nodeRadius, nodeRadius * 2, nodeRadius * 2);
          } else {
            ctx.beginPath();
            ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
            ctx.fillStyle = editingNode === node.id ? '#fff' : '#faf8f5';
            ctx.fill();
            ctx.strokeStyle = editingNode === node.id ? '#c97856' : '#2d3a35';
            ctx.lineWidth = editingNode === node.id ? 2.5 : 1.5;
            ctx.stroke();
          }

          // Label
          if (node.label && editingNode !== node.id) {
            ctx.font = isConcept ? 'bold 11px ui-monospace, SFMono-Regular, monospace' : '11px ui-monospace, SFMono-Regular, monospace';
            ctx.fillStyle = '#2d3a35';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const text = node.label.length > 6 ? node.label.slice(0, 5) + '…' : node.label;
            ctx.fillText(text, node.x, node.y);
          }
        });
        
        if (currentStroke.length > 1) {
          ctx.beginPath();
          ctx.strokeStyle = '#c97856';
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.moveTo(currentStroke[0].x, currentStroke[0].y);
          currentStroke.forEach(p => ctx.lineTo(p.x, p.y));
          ctx.stroke();
        }
      }, [nodes, edges, currentStroke, editingNode, nodeRadius]);
      
      useEffect(() => { draw(); }, [draw, canvasSize]);
      
      const openEditor = useCallback((node) => {
        setEditingNode(node.id);
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        setInputPos({
          x: (node.x / canvas.width) * rect.width + rect.left - 35,
          y: (node.y / canvas.height) * rect.height + rect.top - 10
        });
        setTimeout(() => inputRef.current?.focus(), 50);
      }, []);
      
      const startDrawing = useCallback((e) => {
        e.preventDefault();
        const point = getCanvasPoint(e);

        // Smaller grab radius for dragging (center area only)
        const grabRadius = nodeRadius * 0.5; // 14px - center half only
        const clickedNodeForDrag = nodes.find(n => Math.hypot(n.x - point.x, n.y - point.y) < grabRadius);

        // Full radius for editing detection
        const clickedNode = nodes.find(n => Math.hypot(n.x - point.x, n.y - point.y) < nodeRadius);

        // Double-tap detection for touch
        const now = Date.now();
        const isDoubleTap = (now - lastTapRef.current) < 300;
        lastTapRef.current = now;

        if (clickedNode && (e.detail === 2 || isDoubleTap)) {
          openEditor(clickedNode);
          return;
        }

        // Start dragging only if clicking center of node
        if (clickedNodeForDrag) {
          setIsDragging(true);
          setDragNodeId(clickedNodeForDrag.id);
          return;
        }

        // Otherwise start drawing (allows drawing from edge of node)
        setIsDrawing(true);
        setCurrentStroke([point]);
      }, [getCanvasPoint, nodes, nodeRadius, openEditor]);
      
      const continueDrawing = useCallback((e) => {
        e.preventDefault();
        const point = getCanvasPoint(e);

        if (isDragging && dragNodeId) {
          // Update node position while dragging
          onUpdateNode(dragNodeId, { x: point.x, y: point.y });
          return;
        }

        if (isDrawing) {
          setCurrentStroke(prev => [...prev, point]);
        }
      }, [isDrawing, isDragging, dragNodeId, getCanvasPoint, onUpdateNode]);
      
      const endDrawing = useCallback((e) => {
        e?.preventDefault();

        // End dragging
        if (isDragging) {
          setIsDragging(false);
          setDragNodeId(null);
          return;
        }

        // End drawing
        if (isDrawing) {
          setIsDrawing(false);

          const result = analyzeStroke(currentStroke, nodes, nodeRadius);

          if (result.type === 'circle' || result.type === 'square') {
            const newId = Date.now();
            const nodeTypeToUse = result.type === 'square' ? 'concept' : nodeType;
            onAddNode({ id: newId, x: result.x, y: result.y, label: '', type: nodeTypeToUse });
            setTimeout(() => {
              const newNode = { id: newId, x: result.x, y: result.y };
              openEditor(newNode);
            }, 50);
          } else if (result.type === 'edge') {
            onAddEdge(result.source, result.target);
          }

          setCurrentStroke([]);
        }
      }, [isDrawing, isDragging, currentStroke, nodes, nodeRadius, nodeType, onAddNode, onAddEdge, openEditor]);
      
      return (
        <div 
          ref={containerRef}
          style={{ 
            flex: 1, 
            minWidth: 0, 
            minHeight: '200px',
            position: 'relative',
            background: '#f0ede8',
            borderRadius: '6px',
            border: '1.5px solid #2d3a35',
            overflow: 'hidden'
          }}
        >
          <canvas
            ref={canvasRef}
            width={canvasSize.width}
            height={canvasSize.height}
            style={{
              display: 'block',
              width: '100%',
              height: '100%',
              cursor: 'crosshair',
              touchAction: 'none'
            }}
            onMouseDown={startDrawing}
            onMouseMove={continueDrawing}
            onMouseUp={endDrawing}
            onMouseLeave={endDrawing}
            onTouchStart={startDrawing}
            onTouchMove={continueDrawing}
            onTouchEnd={endDrawing}
            onTouchCancel={endDrawing}
          />
          <div style={{
            position: 'absolute',
            top: '8px',
            right: '8px',
            display: 'flex',
            gap: '4px',
            background: 'rgba(250,248,245,0.9)',
            borderRadius: '4px',
            padding: '4px',
            border: '1px solid #2d3a35'
          }}>
            <button
              onClick={() => setNodeType('person')}
              style={{
                padding: '6px 10px',
                background: nodeType === 'person' ? '#5a7d6d' : 'transparent',
                color: nodeType === 'person' ? '#fff' : '#2d3a35',
                border: 'none',
                borderRadius: '3px',
                cursor: 'pointer',
                fontFamily: 'ui-monospace, SFMono-Regular, monospace',
                fontSize: '10px'
              }}
              title="Draw circles for people"
            >
              ○ Person
            </button>
            <button
              onClick={() => setNodeType('concept')}
              style={{
                padding: '6px 10px',
                background: nodeType === 'concept' ? '#5a7d6d' : 'transparent',
                color: nodeType === 'concept' ? '#fff' : '#2d3a35',
                border: 'none',
                borderRadius: '3px',
                cursor: 'pointer',
                fontFamily: 'ui-monospace, SFMono-Regular, monospace',
                fontSize: '10px',
                fontWeight: 'bold'
              }}
              title="Draw squares for concepts"
            >
              ▢ Concept
            </button>
          </div>
          {editingNode && (
            <input
              ref={inputRef}
              type="text"
              value={nodes.find(n => n.id === editingNode)?.label || ''}
              onChange={(e) => onUpdateNode(editingNode, { label: e.target.value })}
              onBlur={() => setEditingNode(null)}
              onKeyDown={(e) => e.key === 'Enter' && setEditingNode(null)}
              style={{
                position: 'fixed',
                left: inputPos.x,
                top: inputPos.y,
                width: '70px',
                padding: '4px 6px',
                fontSize: '12px',
                fontFamily: 'ui-monospace, SFMono-Regular, monospace',
                border: '2px solid #c97856',
                borderRadius: '4px',
                background: '#fff',
                textAlign: 'center',
                outline: 'none',
                zIndex: 1000
              }}
            />
          )}
        </div>
      );
    };

    // --- HELPER: Find valid spawn position ---
    const findValidSpawnPosition = (nodes, canvasWidth = 400, canvasHeight = 320, nodeRadius = 28) => {
      const minDistance = nodeRadius * 3; // Minimum distance from other nodes
      const margin = nodeRadius + 20; // Margin from edges
      const maxAttempts = 100;

      // Try random positions
      for (let i = 0; i < maxAttempts; i++) {
        const x = margin + Math.random() * (canvasWidth - 2 * margin);
        const y = margin + Math.random() * (canvasHeight - 2 * margin);

        // Check if this position is far enough from all existing nodes
        const isFarEnough = nodes.every(node =>
          Math.hypot(node.x - x, node.y - y) >= minDistance
        );

        if (isFarEnough) {
          return { x, y };
        }
      }

      // Fallback: use spiral pattern if random didn't work
      const centerX = canvasWidth / 2;
      const centerY = canvasHeight / 2;
      for (let angle = 0; angle < Math.PI * 8; angle += 0.3) {
        const radius = 60 + angle * 10;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;

        if (x < margin || x > canvasWidth - margin || y < margin || y > canvasHeight - margin) {
          continue;
        }

        const isFarEnough = nodes.every(node =>
          Math.hypot(node.x - x, node.y - y) >= minDistance
        );

        if (isFarEnough) {
          return { x, y };
        }
      }

      // Last resort: just return center with some offset
      return { x: centerX + Math.random() * 40 - 20, y: centerY + Math.random() * 40 - 20 };
    };

    // --- TABLE COMPONENT ---
    const NetworkTable = ({ nodes, edges, onAddNode, onUpdateNode, onRemoveNode, onAddEdge, onRemoveEdge, onArrange, onClear }) => {
      const [newLabel, setNewLabel] = useState('');
      const [edgeSrc, setEdgeSrc] = useState('');
      const [edgeTgt, setEdgeTgt] = useState('');

      const metrics = calculateMetrics(nodes, edges);

      const getConnections = (nodeId) => edges
        .filter(e => e.source === nodeId || e.target === nodeId)
        .map(e => e.source === nodeId ? e.target : e.source);

      const handleAddNode = () => {
        if (newLabel.trim()) {
          const pos = findValidSpawnPosition(nodes);
          onAddNode({ label: newLabel.trim(), type: 'person', ...pos });
          setNewLabel('');
        }
      };
      
      const handleAddEdge = () => {
        if (edgeSrc && edgeTgt && edgeSrc !== edgeTgt) {
          onAddEdge(parseInt(edgeSrc), parseInt(edgeTgt));
          setEdgeSrc(''); setEdgeTgt('');
        }
      };
      
      const inputStyle = {
        flex: 1, minWidth: 0, padding: '6px 8px', fontSize: '12px',
        fontFamily: 'ui-monospace, SFMono-Regular, monospace', border: '1px solid #ccc', borderRadius: '4px'
      };
      
      const btnStyle = {
        padding: '6px 12px', background: '#5a7d6d', color: '#fff', border: 'none',
        borderRadius: '4px', cursor: 'pointer', fontFamily: 'ui-monospace, SFMono-Regular, monospace', 
        fontSize: '11px', flexShrink: 0
      };
      
      return (
        <div style={{
          width: '240px', flexShrink: 0, background: '#faf8f5', borderRadius: '6px',
          border: '1.5px solid #2d3a35', padding: '12px', display: 'flex', flexDirection: 'column', 
          gap: '12px', overflow: 'hidden'
        }}>
          <div style={{ display: 'flex', gap: '6px' }}>
            <input
              value={newLabel} onChange={e => setNewLabel(e.target.value)}
              onKeyDown={e => e.key === 'Enter' && handleAddNode()}
              placeholder="+ Node name" style={inputStyle}
            />
            <button onClick={handleAddNode} style={btnStyle}>Add</button>
          </div>
          
          <div style={{ display: 'flex', gap: '4px', alignItems: 'center', flexWrap: 'wrap' }}>
            <select value={edgeSrc} onChange={e => setEdgeSrc(e.target.value)} style={{ ...inputStyle, padding: '5px' }}>
              <option value="">From…</option>
              {nodes.map(n => <option key={n.id} value={n.id}>{n.label || '○'}</option>)}
            </select>
            <span style={{ color: '#999', fontSize: '11px' }}>→</span>
            <select value={edgeTgt} onChange={e => setEdgeTgt(e.target.value)} style={{ ...inputStyle, padding: '5px' }}>
              <option value="">To…</option>
              {nodes.map(n => <option key={n.id} value={n.id}>{n.label || '○'}</option>)}
            </select>
            <button onClick={handleAddEdge} style={btnStyle}>Link</button>
          </div>

          <div style={{ display: 'flex', gap: '6px' }}>
            {nodes.length > 1 && (
              <button
                onClick={onArrange}
                style={{
                  ...btnStyle,
                  flex: 1,
                  background: '#c97856',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '4px'
                }}
              >
                ⚡ Auto-Arrange
              </button>
            )}
            <button
              onClick={onClear}
              style={{
                ...btnStyle,
                flex: nodes.length > 1 ? 0 : 1,
                background: '#999',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '4px'
              }}
              title="Reset to default state"
            >
              ↺ Clear
            </button>
          </div>
          
          <div style={{ flex: 1, overflow: 'auto', borderTop: '1px solid #e5e2dc', paddingTop: '10px' }}>
            {nodes.length === 0 ? (
              <p style={{ fontSize: '11px', color: '#999', margin: 0, fontStyle: 'italic' }}>
                Draw circles on canvas…
              </p>
            ) : (
              <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                {nodes.map(node => {
                  const conns = getConnections(node.id);
                  return (
                    <div key={node.id} style={{ background: '#f0ede8', padding: '8px 10px', borderRadius: '5px' }}>
                      <div style={{ display: 'flex', gap: '6px', alignItems: 'center' }}>
                        <input
                          value={node.label} onChange={e => onUpdateNode(node.id, { label: e.target.value })}
                          placeholder="…" style={{ flex: 1, minWidth: 0, padding: '3px 5px', fontSize: '12px',
                            fontFamily: 'ui-monospace, SFMono-Regular, monospace', fontWeight: 600, 
                            border: 'none', background: 'transparent' }}
                        />
                        <button onClick={() => onRemoveNode(node.id)} style={{
                          padding: '2px 7px', background: '#c97856', color: '#fff', border: 'none', 
                          borderRadius: '3px', cursor: 'pointer', fontSize: '11px'
                        }}>×</button>
                      </div>
                      <div style={{ marginTop: '4px', display: 'flex', gap: '8px', fontSize: '10px',
                        fontFamily: 'ui-monospace, SFMono-Regular, monospace', color: '#999' }}>
                        <span title="Degree (connections)">deg: {metrics.nodes[node.id]?.degree || 0}</span>
                        <span title="Degree centrality">cen: {(metrics.nodes[node.id]?.centrality || 0).toFixed(2)}</span>
                      </div>
                      {conns.length > 0 && (
                        <div style={{ marginTop: '4px', color: '#666',
                          fontFamily: 'ui-monospace, SFMono-Regular, monospace', fontSize: '10px' }}>
                          → {conns.map((cId, i) => {
                            const c = nodes.find(n => n.id === cId);
                            return (
                              <span key={cId}>
                                <span onClick={() => onRemoveEdge(node.id, cId)}
                                  style={{ color: '#5a7d6d', cursor: 'pointer', textDecoration: 'underline dotted' }}
                                  title="Click to disconnect">
                                  {c?.label || '○'}
                                </span>{i < conns.length - 1 ? ', ' : ''}
                              </span>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            )}
          </div>
          
          <div style={{ fontSize: '10px', color: '#999', fontFamily: 'ui-monospace, SFMono-Regular, monospace',
            borderTop: '1px solid #e5e2dc', paddingTop: '8px', display: 'flex', flexDirection: 'column', gap: '3px' }}>
            <div>{nodes.length} nodes · {edges.length} edges</div>
            {nodes.length > 1 && (
              <div>
                density: {metrics.network.density.toFixed(3)} · avg deg: {metrics.network.avgDegree.toFixed(1)}
              </div>
            )}
          </div>
        </div>
      );
    };

    // --- MAIN APP ---
    function SocialNetworkDemo() {
      const graph = useGraph();
      const [isVertical, setIsVertical] = useState(window.innerWidth < 600);
      const [canvasSize, setCanvasSize] = useState({ width: 400, height: 320 });

      useEffect(() => {
        const checkLayout = () => setIsVertical(window.innerWidth < 600);
        window.addEventListener('resize', checkLayout);
        return () => window.removeEventListener('resize', checkLayout);
      }, []);

      const handleArrange = useCallback(() => {
        graph.arrangeNodes(canvasSize.width, canvasSize.height);
      }, [graph, canvasSize]);

      return (
        <div style={{
          display: 'flex', flexDirection: 'column', gap: '8px',
          padding: '12px', height: '100%', maxWidth: '800px',
          margin: '0 auto', boxSizing: 'border-box'
        }}>
          <div style={{ fontSize: '10px', color: '#666', fontFamily: 'ui-monospace, SFMono-Regular, monospace' }}>
            Draw ◯ for people, ▢ for concepts · Draw lines to connect · Drag to move · Double-click/tap to edit
          </div>
          <div style={{
            display: 'flex',
            flexDirection: isVertical ? 'column' : 'row',
            gap: '10px',
            flex: 1,
            minHeight: 0
          }}>
            <NetworkCanvas
              nodes={graph.nodes} edges={graph.edges}
              onAddNode={graph.addNode} onUpdateNode={graph.updateNode}
              onRemoveNode={graph.removeNode} onAddEdge={graph.addEdge}
              onCanvasSizeChange={setCanvasSize}
            />
            <NetworkTable
              nodes={graph.nodes} edges={graph.edges}
              onAddNode={graph.addNode} onUpdateNode={graph.updateNode}
              onRemoveNode={graph.removeNode} onAddEdge={graph.addEdge} onRemoveEdge={graph.removeEdge}
              onArrange={handleArrange}
              onClear={graph.clearAll}
              style={isVertical ? { width: '100%' } : {}}
            />
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<SocialNetworkDemo />);
  </script>
</body>
</html>
